<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>从new对象感受JVM体系</title>
      <link href="/forworl.github.io/2024/04/19/%E4%BB%8Enew%E5%AF%B9%E8%B1%A1%E6%84%9F%E5%8F%97JVM%E4%BD%93%E7%B3%BB/"/>
      <url>/forworl.github.io/2024/04/19/%E4%BB%8Enew%E5%AF%B9%E8%B1%A1%E6%84%9F%E5%8F%97JVM%E4%BD%93%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="前情概要"><a href="#前情概要" class="headerlink" title="前情概要"></a>前情概要</h1><h2 id="对象的结构"><a href="#对象的结构" class="headerlink" title="对象的结构"></a>对象的结构</h2><ul><li><p><strong>对象头</strong>：</p><ul><li>Mark Word：存储对象自身运行时的数据，如哈希码、GC分代年龄、锁状态标志</li><li>类型指针：知道是哪个类的实例，指向Class对象</li></ul></li><li><p><strong>实例数据</strong>：存储Java类中各个类型的字段，包括基本类型和引用类型</p></li><li><p><strong>对齐填充</strong>：无意义，对象分配的内存是 8byte 的整数倍</p></li></ul><h2 id="对象创建的代码"><a href="#对象创建的代码" class="headerlink" title="对象创建的代码"></a>对象创建的代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br></pre></td></tr></table></figure><p>执行以上代码的时候，会经历以下几个步骤：</p><ol><li>类加载</li><li>实例化</li><li>初始化</li><li>引用赋值</li></ol><h1 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h1><p>如果在方法区的运行时常量池没有找到Person类的符号引用，那么就会进行类加载，<strong>类加载器</strong>就会把Person.class文件经过<strong>三大步</strong>后加载到JVM内存（运行时数据区的运行时常量池）。</p><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>Person类信息一开始保存在一个Person.java文件，经过编译之后生成对应的Person.class文件，<strong>类加载器就会把Person.class文件加载进JVM内存，同时在堆内存中生成相应的Class对象。</strong></p><p>一般有三种重要的类加载器：</p><ul><li>启动类加载器：C++实现，默认类都会被它所加载，避免核心类冲突</li><li>扩展类加载器：</li><li>应用类加载器：加载classpath路径下的类</li></ul><h3 id="自定义类加载器和双亲委派"><a href="#自定义类加载器和双亲委派" class="headerlink" title="自定义类加载器和双亲委派"></a>自定义类加载器和双亲委派</h3><p>当有特殊需要，也可以自己实现类加载器，如.class文件不在classpath路径下，或者.class文件被加密了需要特殊处理才能加载进JVM内存，可以通过继承ClassLoader类，重写findClass()即可，如果需要打破双亲委派模型，就重写loadClass()覆写加载类的逻辑（如tomcat就是先用自定义的APP类加载器加载再考虑应用类加载器）。</p><h2 id="三大步"><a href="#三大步" class="headerlink" title="三大步"></a>三大步</h2><ul><li><strong>加载</strong>：把Person.class文件通过二进制字节流加载到JVM内存，同时在堆内存生成对应的Class对象</li><li><strong>连接</strong>：验证、static变量赋初值、符号引用转换地址引用（也可能在初始化之后才进行，也叫多态动态绑定）</li><li><strong>初始化</strong>：调用构造函数，执行静态代码块</li></ul><h1 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h1><p><a href="https://fuleyou.icu/2024/03/02/%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B/">https://fuleyou.icu/2024/03/02/%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B/</a></p><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><ul><li><strong>初始化零值</strong>：给对象的实例字段分配默认值，避免使用的时候出现null</li><li><strong>设置对象头</strong>：类的元数据信息、hashCode、GC分代年龄、锁状态标志等</li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>简单了解线程安全</title>
      <link href="/forworl.github.io/2024/04/17/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
      <url>/forworl.github.io/2024/04/17/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><p>对象的状态：对象状态不只和自身有关，还可能和自身的元素有关，如HashMap和内部的Entry</p><p><strong>线程安全就是程序能够在多线程下正确的执行</strong>，如果在多线程执行某段代码出现错误，以下几个方面都可能影响线程安全：</p><ul><li>变量可共享</li><li>变量可修改</li><li>访问修改变量是否使用同步机制</li></ul><h1 id="竞态条件"><a href="#竞态条件" class="headerlink" title="竞态条件"></a>竞态条件</h1><p>当代码的正确性需要取决于多线程的<strong>执行时序</strong>的时候，就会发生竞态条件，此时结果是不确定的。</p><p>通常是<strong>先检查再修改</strong>的情况，如 i++、或者对象延迟初始化（先判断对象为null，然后创建对象）。</p><h1 id="合理使用synchronized"><a href="#合理使用synchronized" class="headerlink" title="合理使用synchronized"></a>合理使用synchronized</h1><p>我们可以用synchronized限制临界区代码被多线程同时访问，但是同时也会有一些问题：</p><ul><li><strong>线程安全类的不安全使用</strong>：如先检查vector集合内是否有某个元素，没有进行添加，虽然vector是线程安全类，但是方法组合同样会发生竞态条件</li><li><strong>性能问题</strong>：锁的粒度太大，直接对整个方法加锁；或者在一些耗时较长的地方加锁（如I&#x2F;O等）</li></ul>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>简单了解线程池</title>
      <link href="/forworl.github.io/2024/04/12/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/forworl.github.io/2024/04/12/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<p>本文参考<a href="https://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651751537&idx=1&sn=c50a434302cc06797828782970da190e&chksm=bd125d3c8a65d42aaf58999c89b6a4749f092441335f3c96067d2d361b9af69ad4ff1b73504c&scene=21#wechat_redirect">Java线程池实现原理及其在美团业务中的实践 (qq.com)</a></p><h1 id="池化思想"><a href="#池化思想" class="headerlink" title="池化思想"></a>池化思想</h1><p>线程池运用了池化的思想，类似的还有连接池、对象池，具有以下的一些好处：</p><ul><li>减少线程创建、销毁的损耗</li><li>更快的响应任务请求</li><li>更好的管理线程以及监控线程</li></ul><h1 id="深入线程池工作流程"><a href="#深入线程池工作流程" class="headerlink" title="深入线程池工作流程"></a>深入线程池工作流程</h1><p>主要关注一下几个方面</p><ol><li>线程池自身状态</li><li>任务管理</li><li>线程管理</li></ol><h2 id="线程池自身状态"><a href="#线程池自身状态" class="headerlink" title="线程池自身状态"></a>线程池自身状态</h2><p>线程池内部用一个AtomicInteger的变量ctl来维护线程池状态（RunState）和线程数量（WorkCount），类似的也可以用一个Integer保存一个小写字符串中哪些字母出现过。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AtomicInteger</span> <span class="variable">ctl</span> <span class="operator">=</span> rs（前三位）+ wc（线程数量） </span><br></pre></td></tr></table></figure><p>线程池有5个状态：</p><ul><li>RUNNING：正常运行状态</li><li>SHUTDOWN：不接受新的任务，可以处理队列还未处理的任务</li><li>STOP：不接受新的任务，也不处理队列的任务，同时中断在执行任务的线程</li><li>TIDYING：所有任务终止，没有工作线程</li><li>TERMINATED：结束</li></ul><h2 id="任务管理"><a href="#任务管理" class="headerlink" title="任务管理"></a>任务管理</h2><h3 id="任务执行流程"><a href="#任务执行流程" class="headerlink" title="任务执行流程"></a>任务执行流程</h3><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240412192936326.png" alt="image-20240412192936326"></p><h3 id="任务缓冲"><a href="#任务缓冲" class="headerlink" title="任务缓冲"></a>任务缓冲</h3><p>通过任务队列缓冲解耦任务和线程，实现经典的消费者-生产者模式，当核心线程都在工作，线程池先把任务添加到阻塞队列，当核心线程结束任务，会从阻塞队列拉取新的任务执行。</p><h3 id="任务拒绝"><a href="#任务拒绝" class="headerlink" title="任务拒绝"></a>任务拒绝</h3><p>当线程池的阻塞队列满了，并且线程数达到最大值，有新任务到来的时候，就会执行相应的拒绝策略，有4种常见的拒绝策略：</p><ul><li><strong>AbortPolicy</strong>：<strong>抛出RejectedExecutionException异常</strong>，默认的策略，当出现问题容易让开发人员知道</li><li><strong>DiscardPolicy</strong>：<strong>丢弃任务</strong>，无异常抛出，适合一些边缘的业务</li><li><strong>DiscardOldestPolicy</strong>：<strong>丢弃队列中最早的任务</strong>，重新提交新任务</li><li><strong>CallerRunsPolicy</strong>：<strong>交给调用者线程执行</strong>，适合让所有任务都执行的情况</li></ul><h2 id="线程管理"><a href="#线程管理" class="headerlink" title="线程管理"></a>线程管理</h2><h3 id="Worker线程"><a href="#Worker线程" class="headerlink" title="Worker线程"></a>Worker线程</h3><p>工作线程可以是创建的时候被分配了任务，也可以是空闲的时候通过getTask()去阻塞队列拉取任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">     <span class="keyword">final</span> Thread thread;<span class="comment">//Worker持有的线程</span></span><br><span class="line">     Runnable firstTask;<span class="comment">//初始化的任务，可以为null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h3><p>线程池通过addWorker()方法增加线程，需要先判断线程池状态，以及当前线程数，才会新建线程，新建线程的时候可能会给线程分配任务。</p><h3 id="线程回收"><a href="#线程回收" class="headerlink" title="线程回收"></a>线程回收</h3><p>线程回收一般是指非核心线程的回收，线程池内部维护了一个线程引用的Hash表，当非核心线程在限定的存活时间内没有获取到新任务，Hash表会删除指向该线程的引用，在GC的时候就会回收该线程。</p><h3 id="线程执行"><a href="#线程执行" class="headerlink" title="线程执行"></a>线程执行</h3><p>空闲线程会在一个while循环里面不断地尝试获取队列的任务执行，对于核心线程是不限时的，而对于非核心线程是限时的。</p><h1 id="线程池最佳实践"><a href="#线程池最佳实践" class="headerlink" title="线程池最佳实践"></a>线程池最佳实践</h1><p>线程池的参数不好配置，特别是线程数要根据不同的场景（CPU密集和IO密集）和机器的CPU核心数合理配置。</p><p><strong>是否可以有比线程池更好的方案？</strong></p><p><strong>是否有可供参考的合理的参数配置方案？</strong></p><h2 id="动态化线程池配置"><a href="#动态化线程池配置" class="headerlink" title="动态化线程池配置"></a>动态化线程池配置</h2><ul><li><strong>关注核心参数</strong>：corePoolSize、maximumPoolSize、workQueue，并发性的场景主要是两种：<ul><li>并行执行子任务，提高响应速度。这种情况下，应该使用同步队列；</li><li>并行执行大批次任务，提升吞吐量。这种情况下，应该使用有界队列，使用队列去缓冲大批量的任务，也要注意核心线程数不能太小，速度会太慢</li></ul></li><li><strong>参数可动态修改</strong>：通过线程池提供的set方法可以动态修改参数</li><li><strong>增加线程池监控</strong>：当发生了抛出RejectedExecutionException异常，或者是线程数达到了阈值（阈值根据最大线程数设定）</li></ul>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>AOP</title>
      <link href="/forworl.github.io/2024/04/12/AOP/"/>
      <url>/forworl.github.io/2024/04/12/AOP/</url>
      
        <content type="html"><![CDATA[<h1 id="添加组件"><a href="#添加组件" class="headerlink" title="添加组件"></a>添加组件</h1><p>@EnableAspectJAutoProxy使用了@Import注解，在调用beanFactoryPostProcessor的时候给Spring容器注册了一个组件AnnotationAwareAspectJAutoProxyCreator，这是一个beanPostProcessor，他会先创建，在创建的时候会获取所有的组件，判断那些需要增强，构建切面类和增强器（增强的方法）</p><h1 id="AOP干预bean的生命周期"><a href="#AOP干预bean的生命周期" class="headerlink" title="AOP干预bean的生命周期"></a>AOP干预bean的生命周期</h1><p>doCreateBean()实例化之前第一次拦截看看是否返回代理对象</p><p>第二次拦截在属性赋值</p><p><strong>第三次拦截在初始化initailize之后的后置增强⭐：</strong></p><ul><li>创建代理对象，保存代理工厂ProxyFactory（里面有通知方法advisor和一些回调函数）</li></ul><h1 id="如何运行对应方法？"><a href="#如何运行对应方法？" class="headerlink" title="如何运行对应方法？"></a>如何运行对应方法？</h1><p>把所有增强器adviser编程拦截器intercepter</p><p>然后真正执行目标方法和增强，<strong>链式调用</strong></p><h2 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h2><p>调用方法会先进入CGLIB的方法回调，然后才会去执行拦截器链；两个MethodInterceptor不同</p><p>正常：前置通知 -》方法调用 -》返回通知通知 -》 后置通知 </p><p>异常：前置通知 -》方法调用 -》异常通知 -》后置通知 （返回通知因为异常没有返回值并且后续都不执行） </p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>子数组和target</title>
      <link href="/forworl.github.io/2024/04/11/%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8Ctarget/"/>
      <url>/forworl.github.io/2024/04/11/%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8Ctarget/</url>
      
        <content type="html"><![CDATA[<p>子数组的和或者乘积&#x3D;&#x3D;target可以考虑这两种办法：前缀和+哈希表、滑动窗口</p><p><strong>滑动窗口</strong></p><p>有限制条件，每个元素都是正数，并且可以找到明确的窗口移动条件</p><p><strong>前缀和+哈希表</strong></p><p>一般都能用，注意是和不是乘积</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>简单了解ThreadLocal</title>
      <link href="/forworl.github.io/2024/04/10/ThreadLocal/"/>
      <url>/forworl.github.io/2024/04/10/ThreadLocal/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是ThreadLocal？"><a href="#什么是ThreadLocal？" class="headerlink" title="什么是ThreadLocal？"></a>什么是ThreadLocal？</h1><p><strong>ThreadLocal是线程变量，每个线程可以在一个ThreadLocal里面存放一个变量，这个变量是线程安全的</strong>，除了ThreadLocal还可以用栈的本地变量或者锁来保证线程安全，并且可以用于方法间的数据传递。</p><p>ThreadLocalMap是ThreadLocal的一个内部类，用于保存数据，key是ThreadLocal的一个<strong>弱引用</strong>（可以有很多个ThreadLocal），那如果是强引用就不会被回收了，value是存放的变量值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 强引用</span></span><br><span class="line">ThreadLocal&lt;Object&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">threadLocal.get();</span><br><span class="line"><span class="comment">// 弱引用</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;().get();</span><br></pre></td></tr></table></figure><p>Thread类有一个类型为ThreadLocal.ThreadLocalMap的实例变量threadLocals，也就是说每个线程有自己的ThreadLocalMap</p><p><strong>简单来说就是每个线程一个ThreadLocalMap，存放很多个 &lt;不同的ThreadLocal，不同的变量值&gt;</strong></p><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>保存某个信息在线程的任意时刻可以使用，如保存用户user信息，可以获取userId或者其他什么信息</p><h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><h2 id="hash冲突"><a href="#hash冲突" class="headerlink" title="hash冲突"></a>hash冲突</h2><p>和HashMap的链地址法不同，ThreadLocal采用nextIndex()和prevIndex()往前后找位置</p><h2 id="nextIndex-和prevIndex"><a href="#nextIndex-和prevIndex" class="headerlink" title="nextIndex()和prevIndex()"></a>nextIndex()和prevIndex()</h2><p>向后或者向前遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">nextIndex</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">prevIndex</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ((i - <span class="number">1</span> &gt;= <span class="number">0</span>) ? i - <span class="number">1</span> : len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h2><ol><li>计算下标位置</li><li>下标位置就是<strong>空白</strong>的，则直接加入</li><li>下标位置有节点，则往后遍历，如果发现<strong>key相同的节点，进行值替换</strong></li><li>如果<strong>没有过期节点</strong>，一直找到空白位置</li><li>如果<strong>有过期节点</strong>，进行替换，并且进行清理</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;</span><br><span class="line"></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="comment">// 对于同一个线程的下标位置都会相同 </span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 找到合适的位置存放新节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i];</span><br><span class="line">         e != <span class="literal">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">// key相同替换</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 有节点，但是节点的key为null，说明节点被回收了，替换之</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到了空白的位置，准备加入新节点</span></span><br><span class="line">    tab[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line">    <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> ++size;</span><br><span class="line">    <span class="comment">// 超过阈值进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="replaceStaleEntry"><a href="#replaceStaleEntry" class="headerlink" title="replaceStaleEntry()"></a>replaceStaleEntry()</h2><p>过期节点替换和垃圾清理（往前找到空白前的第一个过期节点作为开始清理点）</p><p>slotToExpunge：从这个位置开始垃圾清理</p><p>staleSlot：需要替换的过期节点位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value,</span></span><br><span class="line"><span class="params">                               <span class="type">int</span> staleSlot)</span> &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    Entry e;</span><br><span class="line"><span class="comment">// 遍历检测还有没有其它过期的元素，直到null，用slotToExpunge记录开始点，之后用于清理数据</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">slotToExpunge</span> <span class="operator">=</span> staleSlot;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> prevIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="literal">null</span>;</span><br><span class="line">         i = prevIndex(i, len))</span><br><span class="line">        <span class="keyword">if</span> (e.get() == <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">// 当前节点过期了，更新slotToExpunge</span></span><br><span class="line">            slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从staleSlot往后遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="literal">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里主要是为了配合调用者方法，也有一个key相同的处理方式</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line"></span><br><span class="line">            tab[i] = tab[staleSlot];</span><br><span class="line">            tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 相等的意思是，staleSlot前边没有过期节点，从当前位置开始垃圾清理</span></span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新slotToExpunge</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 替换staleSlot位置为新节点，也是这个方法的主要目的</span></span><br><span class="line">    tab[staleSlot].value = <span class="literal">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相等的意思是，staleSlot前边没有过期节点，从当前位置开始垃圾清理</span></span><br><span class="line">    <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="垃圾清理"><a href="#垃圾清理" class="headerlink" title="垃圾清理"></a>垃圾清理</h2><h3 id="expungeStaleEntry"><a href="#expungeStaleEntry" class="headerlink" title="expungeStaleEntry()"></a>expungeStaleEntry()</h3><p><strong>线性清理，遇到空白则停止清理</strong>，这里的staleSlot实际上是传进来的slotToExpunge</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">expungeStaleEntry</span><span class="params">(<span class="type">int</span> staleSlot)</span> &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// expunge entry at staleSlot</span></span><br><span class="line">    tab[staleSlot].value = <span class="literal">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="literal">null</span>;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rehash until we encounter null</span></span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">// 往后遍历</span></span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="literal">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">// 直接清理</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">            e.value = <span class="literal">null</span>;</span><br><span class="line">            tab[i] = <span class="literal">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 进行rehash重新存放位置</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                tab[i] = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class="line">                <span class="comment">// null because multiple entries could have been stale.</span></span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="literal">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="cleanSomeSlots"><a href="#cleanSomeSlots" class="headerlink" title="cleanSomeSlots()"></a>cleanSomeSlots()</h3><p>每次循环n&#x2F;&#x3D;2，n是table[]数组的长度，直到n&#x3D;&#x3D;0停止清理，也是<strong>线性清理</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">cleanSomeSlots</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">removed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        i = nextIndex(i, len);</span><br><span class="line">        <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.get() == <span class="literal">null</span>) &#123;</span><br><span class="line">            n = len;</span><br><span class="line">            removed = <span class="literal">true</span>;</span><br><span class="line">            i = expungeStaleEntry(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> ( (n &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// threshold 默认 2/3 * len</span></span><br><span class="line"><span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">    rehash();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rehash</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 从开头开始清理所有过期节点，然后移动零散节点到一起</span></span><br><span class="line">    expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为有些过期节点被清理，减少扩容的阈值判断</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">        <span class="comment">// 2倍扩容，重新rehash</span></span><br><span class="line">        resize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>简单了解三级缓存解决循环依赖</title>
      <link href="/forworl.github.io/2024/04/10/%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/"/>
      <url>/forworl.github.io/2024/04/10/%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是循环依赖问题？"><a href="#什么是循环依赖问题？" class="headerlink" title="什么是循环依赖问题？"></a>什么是循环依赖问题？</h1><p>Spring框架有个特点就是大量使用缓存，<strong>当Spring需要某个bean对象的时候，它不会直接创建这个bean，而是会先从缓存里面找</strong>，如果缓存中没有才会创建这个bean对象，比如Person对象有个Car属性，当Person对象属性赋值的时候就会去容器（缓存）里面拿，那么如果Car对象又有个Person属性，就会不断地重复这个过程，Person获取Car，Car又获取Person，<strong>最终方法无限递归造成栈溢出</strong>。</p><h1 id="有什么办法进行属性赋值？"><a href="#有什么办法进行属性赋值？" class="headerlink" title="有什么办法进行属性赋值？"></a>有什么办法进行属性赋值？</h1><p>在Spring可以通过构造器或者set()方法进行属性赋值，又分为byName（如@Resource）或者byType（如@Autowired）。</p><p>Spring能够解决的只能解决<strong>单例bean</strong>和<strong>set()方法注入</strong>的循环依赖。</p><h2 id="单例bean和多例bean"><a href="#单例bean和多例bean" class="headerlink" title="单例bean和多例bean"></a>单例bean和多例bean</h2><p>Spring是用了三级缓存存放提前暴露的半成品bean</p><p>而对于多例bean，没有使用缓存所以当Spring遇到多例bean的循环依赖将会直接抛出异常</p><h2 id="set-方法和构造器"><a href="#set-方法和构造器" class="headerlink" title="set()方法和构造器"></a>set()方法和构造器</h2><p>set()方法是属性赋值使用的办法，配合反射实现</p><p>构造器在对象实例化的时候被调用，将会调用getBean属性赋值，但是这里赋值的时候不会加载三级缓存，就会报错</p><h1 id="三级缓存解决循环依赖"><a href="#三级缓存解决循环依赖" class="headerlink" title="三级缓存解决循环依赖"></a>三级缓存解决循环依赖</h1><h2 id="有哪些缓存？"><a href="#有哪些缓存？" class="headerlink" title="有哪些缓存？"></a>有哪些缓存？</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一级缓存，beanName -&gt; 实例化并且初始化的成品</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二级缓存，beanName -&gt; 实例化但是未初始化的成品</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 三级缓存，beanName -&gt; ObjectFactory</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure><h2 id="缓存加入时机"><a href="#缓存加入时机" class="headerlink" title="缓存加入时机"></a>缓存加入时机</h2><h3 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h3><p>在singletonObject &#x3D; singletonFactory.getObject();创建完完整的单例bean实例之后会把这个单例bean加入到一级缓存。</p><h3 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h3><p>this.earlySingletonObjects.put(beanName, singletonObject);把未完全初始化的bean从三级缓存提升到二级缓存。</p><h3 id="三级缓存"><a href="#三级缓存" class="headerlink" title="三级缓存"></a>三级缓存</h3><p>在初始化之前，调用addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));把bean提前暴露到第三级缓存，防止循环依赖。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实本质上只有二级缓存，二级缓存提前暴露未完全初始化的单例bean，一级缓存是完整的单例bean，我们用二级缓存给属性赋值，而一级缓存来获取bean，如果有代理bean，那么就会造成beanA和b.属性beanA不同，那第三级缓存实际上是为了代理bean而存在的，我们需要通过第三层缓存SingletonFactory来生成代理对象，注意这里缓存是不能被替换的，只能够新增，所以采用多一级缓存才能对代理bean有效。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>简单了解main启动发生了什么</title>
      <link href="/forworl.github.io/2024/04/07/main%E5%90%AF%E5%8A%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"/>
      <url>/forworl.github.io/2024/04/07/main%E5%90%AF%E5%8A%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<h1 id="前期编译"><a href="#前期编译" class="headerlink" title="前期编译"></a>前期编译</h1><p>那我们一开始是写了很多的.java文件嘛，java是一个编译 + 解释的语言，前期编译把这些**.java文件转换成字节码文件**，也就是.class文件。</p><h1 id="后期编译和类加载"><a href="#后期编译和类加载" class="headerlink" title="后期编译和类加载"></a>后期编译和类加载</h1><p><strong>在调用某个方法的时候，执行引擎会把.class字节码逐行解释为机器码</strong>（二进制的机器码才能让计算机执行，同时这里是<strong>JVM翻译</strong>的，不同的操作系统有不同适配的JVM，这也是Java可移植性的保证），当然解释型（如Java）是没有编译型的效率高的（如C、C++），那Java在这里也会进行了优化，对于热点代码，有即时编译器<strong>JIT进行优化</strong>（把这块热点代码直接翻译成机器码），同时对线程（操作系统分配有一定的栈空间）每次方法调用生成对应的栈帧，一般存放一些临时变量，这些临时变量如果是引用类型可能指向堆内存的对象。</p><p>类是懒加载的，需要的时候才会被加载进内存，<strong>类加载器会把这些.class文件加载进内存（加载、连接、初始化）</strong>，其实也就是一些类的基本信息（如属性、方法、构造器等）放到方法区，同时在堆内存生成一个对应的<strong>Class对象</strong>指向方法区的某块保存着这个类信息的区域，后期我们在需要获取类信息或者是实例化对象的时候就可以通过访问Class对象来间接访问到方法区的类信息</p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20231218094355840.png" alt="image-20231218094355840"></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>位运算的一些想法</title>
      <link href="/forworl.github.io/2024/04/03/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E4%B8%80%E4%BA%9B%E6%83%B3%E6%B3%95/"/>
      <url>/forworl.github.io/2024/04/03/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E4%B8%80%E4%BA%9B%E6%83%B3%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>判断奇偶数：x % 2 &#x3D;&#x3D; 0，可以替换成：x &amp; 1 &#x3D;&#x3D; 0，像HashMap在计算索引的时候就是这么干的</p><p>需要修改二进制数某一bit位的：ans |&#x3D; x &gt;&gt; 1 就是修改低位开始的第二位</p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTTP不同版本的区别</title>
      <link href="/forworl.github.io/2024/04/01/HTTP%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/forworl.github.io/2024/04/01/HTTP%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h1><h2 id="HTTP1-1相对于HTTP1-0的优化"><a href="#HTTP1-1相对于HTTP1-0的优化" class="headerlink" title="HTTP1.1相对于HTTP1.0的优化"></a>HTTP1.1相对于HTTP1.0的优化</h2><ul><li>请求使用<strong>长连接</strong>代替短链接，不必每次请求都进行三次握手建立TCP连接，减少性能损耗（创建销毁进程）同时加快响应速度（没有慢启动、握手时延）</li><li>支持<strong>并发传输</strong>，不用等前一个请求收到响应，就可以发送请求，最大请求数据量可以到发送窗口的上限</li></ul><h2 id="HTTP1-1有什么不足？"><a href="#HTTP1-1有什么不足？" class="headerlink" title="HTTP1.1有什么不足？"></a>HTTP1.1有什么不足？</h2><ul><li><strong>请求头部未经压缩数据量大</strong>：影响传输延时</li><li><strong>请求头部字段冗余</strong>：每次请求浪费较多</li><li><strong>HTTP队头阻塞</strong>：服务端按照请求的顺序响应，如果服务端响应慢，可能有HTTP队头阻塞</li><li><strong>单向请求</strong>：只有由客户端发送请求，服务端响应请求</li></ul><h1 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h1><h2 id="HTTP2相对于HTTP1-1的优化"><a href="#HTTP2相对于HTTP1-1的优化" class="headerlink" title="HTTP2相对于HTTP1.1的优化"></a>HTTP2相对于HTTP1.1的优化</h2><ul><li><strong>头部压缩</strong>：如果同时发送多个请求，通信双方有一张<strong>头信息表</strong>，只需要发送<strong>索引</strong>，可以找到对应的头部字段</li><li><strong>二进制数据</strong>：头部和数据部分都换成<strong>二进制存储</strong>，减少传输的大小，同时对计算机友好，不用进行转换，提高解析效率</li><li><strong>并发传输</strong>：HTTP1.1没有对请求或者响应进行区分，所以只能要求服务端顺序响应，否则服务端响应的数据客户端无法组装（会组装不同请求的响应数据到一起），在HTTP2将<strong>每个HTTP请求或者响应封装成一个Stream</strong>，每个Stream有自己的Stream ID（对应某个请求或者响应），用于数据组装</li><li><strong>双向传输</strong>：<strong>服务端可以主动推送资源</strong>，也可以创建Stream ID，但是必须是双数，而客户端必须是单数</li></ul><h2 id="HTTP-x2F-2有什么不足？"><a href="#HTTP-x2F-2有什么不足？" class="headerlink" title="HTTP&#x2F;2有什么不足？"></a>HTTP&#x2F;2有什么不足？</h2><p><strong>TCP队头阻塞</strong>：HTTP2是基于TCP协议的，而TCP是基于字节流的，TCP只有收到完整的字节数据，内核才会把缓冲区的数据传给对应的应用层，当某个HTTP请求没有收到完整的响应，即发生了丢包，即使后面的Stream已经是完整的也没办法接收，要等到本Stream接收到重传的报文段才能顺利接收</p><h1 id="HTTP3"><a href="#HTTP3" class="headerlink" title="HTTP3"></a>HTTP3</h1><h2 id="HTTP3相对于HTTP2的优化"><a href="#HTTP3相对于HTTP2的优化" class="headerlink" title="HTTP3相对于HTTP2的优化"></a>HTTP3相对于HTTP2的优化</h2><p><strong>HTTP&#x2F;3基于UDP协议实现</strong>：UDP是基于报文段的，没有队头阻塞问题，同时在应用层实现QUIC协议保证数据可靠到达</p><h2 id="QUIC协议"><a href="#QUIC协议" class="headerlink" title="QUIC协议"></a>QUIC协议</h2><ul><li><strong>无队头阻塞</strong>：QUIC的每个Stream都有自己独立的滑动窗口，不受其它Stream的影响，所以不会被其它Stream丢包问题的阻塞</li><li><strong>更快的连接建立</strong>：用QUIC三次握手代替TCP三次握手，同时QUIC握手会携带TLS（并且是TLS1.3），所以整个握手时延是1RTT</li><li><strong>连接迁移</strong>：TCP是用四元组来标记一条连接的，如果客户端切换网络，则连接需要重新建立，QUIC通过连接ID标记一条连接（连接ID、TLS密钥），可以无缝切换，无需重新建立连接</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>简单了解策略模式</title>
      <link href="/forworl.github.io/2024/03/30/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
      <url>/forworl.github.io/2024/03/30/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是策略模式？"><a href="#什么是策略模式？" class="headerlink" title="什么是策略模式？"></a>什么是策略模式？</h1><p><strong>策略模式提供生成某一种产品的不同方式</strong></p><p>Strategy策略类定义了某个各种算法的公共方法，不同的算法类通过继承Strategy策略类，实现自己的算法</p><p>Context的作用是减少客户端和Strategy策略类之间的耦合，客户端只需要调用Context并且传递相应的算法参数，来调用不同的算法，Context的内部实现可以用一个Map&lt;id, Strategy&gt;，在Spring启动的时候，会把Strategy类自动装配进Map</p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240104171319410.png" alt="image-20240104171319410"></p><h1 id="Spring的策略模式"><a href="#Spring的策略模式" class="headerlink" title="Spring的策略模式"></a>Spring的策略模式</h1><p>Resource getResource(String location) 根据传入的 location（算法参数）返回一个资源子类（具体算法），如 ClassPathResource 内部定义了解析 xml 的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (location.startsWith(CLASSPATH_URL_PREFIX)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">// Try to parse the location as a URL...</span></span><br><span class="line">       <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> ResourceUtils.toURL(location);</span><br><span class="line">       <span class="keyword">return</span> (ResourceUtils.isFileURL(url) ? <span class="keyword">new</span> <span class="title class_">FileUrlResource</span>(url) : <span class="keyword">new</span> <span class="title class_">UrlResource</span>(url));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (MalformedURLException ex) &#123;</span><br><span class="line">       <span class="comment">// No URL -&gt; resolve as resource path.</span></span><br><span class="line">       <span class="keyword">return</span> getResourceByPath(location);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getInstantiationStrategy().instantiate()，如果需要被反射创建的 bean 的方法没有覆写，直接用无参构造器创建，否则用CGLIB创建。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>简单了解观察者模式（发布 - 订阅模式）</title>
      <link href="/forworl.github.io/2024/03/30/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%EF%BC%89/"/>
      <url>/forworl.github.io/2024/03/30/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是观察者模式？"><a href="#什么是观察者模式？" class="headerlink" title="什么是观察者模式？"></a>什么是观察者模式？</h1><p>观察者根据主题类的内部状态变化来改变自身状态，简单来说就是观察者订阅了主题类，当主题类发布一些消息，观察者就会收到消息，然后做出反应。</p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240117095129017.png" alt="image-20240117095129017"></p><h1 id="Spring的观察者模式"><a href="#Spring的观察者模式" class="headerlink" title="Spring的观察者模式"></a>Spring的观察者模式</h1><p>Spring用了监听器（观察者）来完成观察者模式，有两种方式：</p><ul><li>通过实现ApplicationListener</li><li>或者使用注解@EventListener来完成事件监听</li></ul><p>ApplicationContext底层用SimpleApplicationEventMulticaster发布事件（主题类内部状态变化）的时候，会同步通知这些监听器（如果设置了线程池则异步发送），监听器如果发现自己感兴趣的消息，就会进行相应的处理。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>简单了解HTTP和HTTPS</title>
      <link href="/forworl.github.io/2024/03/30/HTTP%E5%92%8CHTTPS/"/>
      <url>/forworl.github.io/2024/03/30/HTTP%E5%92%8CHTTPS/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP的安全问题？"><a href="#HTTP的安全问题？" class="headerlink" title="HTTP的安全问题？"></a>HTTP的安全问题？</h1><p>我们都知道HTTP是不安全的，而HTTPS是安全的，那HTTP有哪些安全问题呢？（考虑传输过程以及响应方）</p><ul><li><strong>明文传输，有窃听风险</strong>：HTTP协议<strong>无法加密数据</strong>，所有通信数据都在网络中明文传输，通过网络的嗅探设备及一些技术手段，就可轻易窃听并还原HTTP报文内容。</li><li><strong>无法验证数据完整性，有篡改风险</strong>：HTTP协议无法证明通信的<strong>报文完整性</strong>，<strong>发送方发出的请求和接收方接收到的响应是前后相同的</strong>，没有被篡改的。</li><li><strong>无法验证通信方身份，有冒充风险</strong>：在请求或响应到达接收方这段时间内，请求或响应被<strong>第三方拦截伪造</strong>之后再次发出，通信双方也无法知晓。</li></ul><h1 id="HTTPS如何解决的？"><a href="#HTTPS如何解决的？" class="headerlink" title="HTTPS如何解决的？"></a>HTTPS如何解决的？</h1><ul><li><strong>混合加密明文</strong>解决窃听风险</li><li><strong>摘要算法</strong>为数据生成一个唯一的<strong>指纹</strong>，通过指纹验证<strong>报文完整性</strong>，解决篡改风险</li><li>将服务器公钥放入到<strong>数字证书</strong>中，并把证书注册到CA，解决了冒充风险。</li></ul><h2 id="混合加密"><a href="#混合加密" class="headerlink" title="混合加密"></a>混合加密</h2><p>HTTPS采用了<strong>非对称加密</strong>和<strong>对称加密</strong>结合的方式：</p><ul><li>TLS握手期间采用<strong>非对称加密</strong>交换交换随机数生成会话密钥</li><li>此后的通信过程采<strong>用对称加密</strong>的会话密钥进行加密</li></ul><h3 id="为什么用混合加密？"><a href="#为什么用混合加密？" class="headerlink" title="为什么用混合加密？"></a>为什么用混合加密？</h3><p>对称加密虽然加密、解密的运算速度快，但是如果在HTTP明文传输密钥，那密钥可能会被窃取，也就相当于没有加密；</p><p>所以在对称加密之前，用非对称密钥加密随机数生成一个对称加密的会话密钥，保证这个会话密钥不会被窃取。</p><p><strong>那为什么不直接用非对称密钥加密来进行通话的数据加密呢？</strong></p><p>那是因为非对称密钥加密、解密的运算速度会比对称加密慢，对于数据通信我们自然不希望加密、解密的运算速度比传输的RRT还长。</p><h3 id="非对称加密和对称加密的区别？"><a href="#非对称加密和对称加密的区别？" class="headerlink" title="非对称加密和对称加密的区别？"></a>非对称加密和对称加密的区别？</h3><ul><li><strong>非对称加密</strong>：发送方用接收方的公钥加密，接收方用私钥解密；或者发送方用自己的私钥加密，接收方用自己的公钥解密</li><li><strong>对称加密</strong>：双方用同一对密钥进行加密和解密</li></ul><h2 id="摘要算法"><a href="#摘要算法" class="headerlink" title="摘要算法"></a>摘要算法</h2><p>以下的指纹、hash值都是一个意思。</p><p>为了保证传输的内容不被篡改，我们需要对内容计算出一个「指纹」，这个<strong>哈希值是唯一的，且无法通过哈希值推导出内容</strong>。然后同内容一起传输给对方，接收方再次计算数据的hash值，和指纹比对，相同说明数据没有被篡改，但是不能说明内容和hash值没有一起被篡改（也就是消息来源是正确的吗？），这时候就要用到非对称加密：</p><ul><li><strong>公钥加密，私钥解密</strong>。这个目的是为了<strong>保证内容传输的安全</strong>，保证只有私钥拥有者才能获取到数据</li><li><strong>私钥加密，公钥解密</strong>。这个目的是为了<strong>保证消息不会被冒充</strong>，保证消息来源是正确的</li></ul><p>对指纹用<strong>私钥加密</strong>，然后客户端有对应的<strong>公钥，就可以解密</strong>，比对数据的hash值和指纹，相同则说明内容没有被篡改。</p><h2 id="数字证书认证机构（CA）"><a href="#数字证书认证机构（CA）" class="headerlink" title="数字证书认证机构（CA）"></a>数字证书认证机构（CA）</h2><p><strong>万一公钥是被伪造的呢？</strong>这时候就需要有第三方的验证。</p><p>CA是第三方权威机构，服务端把「个人信息 + 公钥」打包成一个<strong>数字证书</strong>，放到CA，CA会用自己的私钥加密数字证书得到一个数字签名，客户端收到数字证书后先去CA验证是否合法（用CA的公钥解密，比对hash值），如果验证成功，就可以获取到服务端的公钥。</p><h1 id="HTTPS建立连接流程"><a href="#HTTPS建立连接流程" class="headerlink" title="HTTPS建立连接流程"></a>HTTPS建立连接流程</h1><p>TLS握手在TCP三次握手之后，那RSA算法举例，主要分为以下几个步骤：</p><ol><li><strong>客户端发送请求</strong>，询问服务端用哪些密码套件和TLS版本</li><li><strong>服务端ACK确认密码套件和TLS版本</strong>，同时会向客户端<strong>发送自己的数字证书</strong>（有服务端的公钥），客户端收到之后进行<strong>验证数字证书有效</strong>，从中获取到服务端公钥，用公钥加密一个随机数发送给服务端，服务端收到后用自己的私钥解密得到随机数，<strong>用这个随机数生成一个对称的会话密钥</strong></li><li>客户端发送请求，请求之后的会话都用这个会话密钥，服务端响应ACK</li><li>服务端发送请求，请求之后的会话都用这个会话密钥，客户端响应ACK</li><li>TLS握手完成，HTTPS建立连接完成</li></ol><h2 id="如何验证数字证书有效？"><a href="#如何验证数字证书有效？" class="headerlink" title="如何验证数字证书有效？"></a>如何验证数字证书有效？</h2><p>正如前面的摘要算法以及CA提到的，会对原文生成一个指纹，CA用私钥加密这个指纹得到数字签名，服务端同样对原文生成一个指纹，用CA公钥解密数字签名得到一个hash值，比对hash值和指纹，如果相同则说明验证成功。</p><h1 id="HTTPS真的安全吗？"><a href="#HTTPS真的安全吗？" class="headerlink" title="HTTPS真的安全吗？"></a>HTTPS真的安全吗？</h1><p>当有第三方在客户端和服务端中间，第三方伪造服务端和客户端TLS握手，同时第三方伪造客户端和服务端TLS握手，不就会产生问题吗？</p><p>换个问题表述，<strong>可以理解为第三方冒充的问题</strong>，主要是数字证书的信任问题，当你点击一个有风险的连接，浏览器会弹出警告，这时候如果你点击拒绝访问，自然TLS握手失效，也就不会有后面的数据通信过程；或者是电脑中病毒了，被第三方恶意植入了它的证书，浏览器不会弹出风险警告，那么通信也不再安全。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode</title>
      <link href="/forworl.github.io/2024/03/29/LeetCode/"/>
      <url>/forworl.github.io/2024/03/29/LeetCode/</url>
      
        <content type="html"><![CDATA[<h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><p>回溯的本质是穷举，列出所有的组合，从中找到符合的答案。</p><h2 id="回溯的模板"><a href="#回溯的模板" class="headerlink" title="回溯的模板"></a>回溯的模板</h2><p>每次递归都是为了找到路径的其中一个组成节点，符合条件的路径就是其中一个答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(参数)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="for循环的开始下标是0还是startIndex"><a href="#for循环的开始下标是0还是startIndex" class="headerlink" title="for循环的开始下标是0还是startIndex"></a>for循环的开始下标是0还是startIndex</h2><p>一般情况下都是0，主要考虑什么时候是startIndex：</p><ul><li>当数组有序，这一层选了某个数字之后，下一层不能选更小的数字，比如大部分组合问题</li><li>字符串，这一层选了某个子串，下一层要从后一个索引位置开始，比如切割问题</li></ul><h2 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h2><h3 id="树层去重"><a href="#树层去重" class="headerlink" title="树层去重"></a>树层去重</h3><p>一般用到used[]数组都是全局的，可用于数层或者树枝；</p><p>有时候也可以放backTracking内部，只用于本树层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用全局used[]数组</span></span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不用used[]数组，改用startIndex</span></span><br><span class="line"><span class="keyword">if</span> ( i &gt; startIndex &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>] ) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="树枝去重"><a href="#树枝去重" class="headerlink" title="树枝去重"></a>树枝去重</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h2><p>TODO</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TCP可靠传输和UDP实现可靠传输</title>
      <link href="/forworl.github.io/2024/03/28/TCP%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%92%8CUDP%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/"/>
      <url>/forworl.github.io/2024/03/28/TCP%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%92%8CUDP%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么有了TCP还要QUIC？"><a href="#为什么有了TCP还要QUIC？" class="headerlink" title="为什么有了TCP还要QUIC？"></a>为什么有了TCP还要QUIC？</h1><p>我们知道TCP可以支持可靠传输，但是为什么还需要基于UDP在应用层再实现一个可靠传输的QUIC协议？QUIC协议在HTTP3被使用，<strong>为了解决HTTP2的TCP队头阻塞的问题（当某个TCP分片丢失，后续的TCP分片都无法被确认）、TCP握手的时延问题、一方更换IP需要重新建立连接等问题</strong>，将传输层协议由TCP改成了UDP，但是UDP是不保证报文段可以到达对方的，只是尽最大努力交付，而下层的IP协议也是不可靠的，我们只好在应用层实现一个可靠的协议，也就是QUIC协议。</p><h1 id="QUIC协议如何实现？"><a href="#QUIC协议如何实现？" class="headerlink" title="QUIC协议如何实现？"></a>QUIC协议如何实现？</h1><p><strong>那么TCP主要干了两件事情，一个是让乱序的包有序（这样可以知道哪些包丢失了）、一个是包重传和流量、拥塞控制。</strong></p><h2 id="QUIC-Frame-Header"><a href="#QUIC-Frame-Header" class="headerlink" title="QUIC Frame Header"></a>QUIC Frame Header</h2><p>先来看看为什么包会乱序，也可以说是HTTP请求乱序？一开始的TCP连接并没有实现HTTP并行，也就是必须要等到上一个HTTP的请求收到响应之后才能发出下一个HTTP请求这种一问一答的形式，后面增加了滑动窗口这个机制（在内核实现一个缓存），让<strong>HTTP可以在窗口大小的范围内实现并发</strong>，每个HTTP请求都对应有发出的顺序（也就是seq序列号）进行排序，只有收到这个HTTP请求的所有响应数据之后，滑动窗口才会移动，每个包在TCP头部都有一个<strong>seq字段（序列号）配合ACK表明数据包是否丢失</strong>，通过包的seq判断包对应的HTTP请求的顺序。</p><p>而QUIC的实现是用了<strong>QUIC Frame Header</strong>的offset字段类似这个seq字段的作用，用于表明HTTP请求的顺序，同时有Stream ID来看看是哪个HTTP请求。</p><h2 id="Packet-Header"><a href="#Packet-Header" class="headerlink" title="Packet Header"></a>Packet Header</h2><p>TCP发现丢包之后，会重传相同seq的包，直到收到ACK或者重传次数超过上限。</p><p>在<strong>Packet Header</strong>实现了类似TCP握手的过程，用Packet Number字段将TCP的seq代替，而Packet Number字段是严格递增的，包重传的Packet Number是不同的，收到的ACK也不同，<strong>这样可以支持乱序确认</strong>，而TCP是需要等到这个请求的所有响应包收到之后才能收下一个HTTP请求的包（TCP不就是需要有序性吗），那如何保证这个包和重传的包是一样的数据呢？或者说如何确是否丢包呢？通过<strong>QUIC Frame Header</strong>的offset字段和Stream ID字段比较可以确定。</p><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>refresh()发生了什么</title>
      <link href="/forworl.github.io/2024/03/27/refresh%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"/>
      <url>/forworl.github.io/2024/03/27/refresh%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是refresh-？"><a href="#什么是refresh-？" class="headerlink" title="什么是refresh()？"></a>什么是refresh()？</h1><p>refresh()相信对于阅读过Spring源码的朋友并不陌生，ApplicationContext的自动装配功能正是通过这个函数完成的，其中有一些重要的子方法，如注册BeanFactoryPostprocessor、注册BeanPostprocessor、注册EventListener监听事件、提前完成非懒加载的bean的实例化。</p><p>refresh()在内部使用了一个对象锁保证线程安全，只能由一个线程进行自动装配或者是销毁。</p><p>&#x2F;&#x2F; 在Spring的低版本只能通过xml加载创建bean，为了适配注解的方式，AnnotationConfigApplicationContext在refresh()之前完成一些事情来实现</p><h1 id="refresh-的12步骤"><a href="#refresh-的12步骤" class="headerlink" title="refresh()的12步骤"></a>refresh()的12步骤</h1><h2 id="1-prepareRefresh"><a href="#1-prepareRefresh" class="headerlink" title="1.prepareRefresh()"></a>1.prepareRefresh()</h2><p>准备此上下文以进行刷新，修改了active &#x3D; true表明当前正在进行的是创建过程。</p><p>初始化属性、初始化环境变量</p><h2 id="2-obtainFreshBeanFactory-⭐"><a href="#2-obtainFreshBeanFactory-⭐" class="headerlink" title="2.obtainFreshBeanFactory()⭐"></a>2.obtainFreshBeanFactory()⭐</h2><p>告诉子类刷新内部 Bean 工厂，对于xml方式，在这里加载xml文件的BeanDefinition；对于注解方式无操作，配置类方式等到第5步解析</p><p>refreshBeanFactory()方法有两个实现类的不同实现：</p><ul><li><strong>AbstractRefreshableApplicationContext</strong>：xml方式，loadBeanDefinitions(beanFactory)在这里加载xml文件的BeanDefinition</li><li><strong>GenericApplicationContext</strong>：注解方式，没有什么感兴趣的过程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title function_">obtainFreshBeanFactory</span><span class="params">()</span> &#123;</span><br><span class="line">    refreshBeanFactory();</span><br><span class="line">    <span class="keyword">return</span> getBeanFactory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-prepareBeanFactory-beanFactory"><a href="#3-prepareBeanFactory-beanFactory" class="headerlink" title="3.prepareBeanFactory(beanFactory)"></a>3.prepareBeanFactory(beanFactory)</h2><p>准备bean factory以在此上下文中使用。</p><p>注册了 2 个 BeanPostProcessor，一个是处理 Aware 接口的回调函数，一个是 ApplicationListenerDetector，还注册了 4 个可以被自动装配的依赖，还注册了 4 个系统环境的 bean 到单例池singletonObjects。</p><p>resolvableDependencies自动装配的属性池，如ApplicationContext可以用@Autowired自动注入</p><h2 id="4-postProcessBeanFactory-beanFactory"><a href="#4-postProcessBeanFactory-beanFactory" class="headerlink" title="4.postProcessBeanFactory(beanFactory)"></a>4.postProcessBeanFactory(beanFactory)</h2><p>模板方法，允许在上下文子类中对 Bean 工厂进行后处理，看到一些web子类实现了</p><h2 id="5-invokeBeanFactoryPostProcessors-beanFactory-⭐"><a href="#5-invokeBeanFactoryPostProcessors-beanFactory-⭐" class="headerlink" title="5.invokeBeanFactoryPostProcessors(beanFactory)⭐"></a>5.invokeBeanFactoryPostProcessors(beanFactory)⭐</h2><p>在实例化 bean 前，先调用 BeanFactoryPostProcessor 后置处理器。</p><ol><li>调用实现了 PriorityOrdered 接口的 BeanDefinitionRegistryPostProcessor，这里会有个默认的internalConfigurationAnnotationProcessor被调用，用于解析配置类，在doProcessConfigurationClass()解析标注了@Configuration的配置类，以及一些@ComponentScan、@Import、@PropertySource、@Bean等注解</li><li>调用实现了 Ordered 接口的 BeanDefinitionRegistryPostProcessor</li><li>最后，调用所有其他没有实现排序接口的 BeanDefinitionRegistryPostProcessor</li><li>调用给定的 BeanFactoryPostProcessor</li></ol><h2 id="6-registerBeanPostProcessors-beanFactory-⭐"><a href="#6-registerBeanPostProcessors-beanFactory-⭐" class="headerlink" title="6.registerBeanPostProcessors(beanFactory)⭐"></a>6.registerBeanPostProcessors(beanFactory)⭐</h2><p>注册截获 Bean 创建的 Bean 处理器</p><ol><li>注册实现了 PriorityOrdered 接口的 BeanPostProcessor（MergedBeanDefinitionPostProcessor）</li><li>注册实现了 Ordered 接口的 BeanPostProcessor</li><li>现在，注册所有常规的 BeanPostProcessor</li><li>最后，重新注册所有 internal BeanPostProcessor</li></ol><h2 id="7-initMessageSource"><a href="#7-initMessageSource" class="headerlink" title="7.initMessageSource()"></a>7.initMessageSource()</h2><p>国际化</p><h2 id="8-initApplicationEventMulticaster"><a href="#8-initApplicationEventMulticaster" class="headerlink" title="8.initApplicationEventMulticaster()"></a>8.initApplicationEventMulticaster()</h2><p>初始化此上下文的事件广播器，new 一个 SimpleApplicationEventMulticaster</p><h2 id="9-onRefresh"><a href="#9-onRefresh" class="headerlink" title="9.onRefresh()"></a>9.onRefresh()</h2><p>模板方法，在特定上下文子类中初始化其他特殊 bean，，看到一些web子类实现了</p><h2 id="10-registerListeners"><a href="#10-registerListeners" class="headerlink" title="10.registerListeners()"></a>10.registerListeners()</h2><p>注册监听器 bean</p><p>只有写了监听器bean才会注册，否则为空</p><h2 id="11-finishBeanFactoryInitialization-beanFactory-⭐"><a href="#11-finishBeanFactoryInitialization-beanFactory-⭐" class="headerlink" title="11.finishBeanFactoryInitialization(beanFactory);⭐"></a>11.finishBeanFactoryInitialization(beanFactory);⭐</h2><p>实例化剩下的 (非懒加载) 单例 bean。</p><p>bean的生命周期</p><h2 id="12-finishRefresh"><a href="#12-finishRefresh" class="headerlink" title="12.finishRefresh();"></a>12.finishRefresh();</h2><p>发布相应的事件，10步注册的监听器bean监听对应事件做出反应</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>简单了解硬中断和软中断</title>
      <link href="/forworl.github.io/2024/03/27/%E7%A1%AC%E4%B8%AD%E6%96%AD%E5%92%8C%E8%BD%AF%E4%B8%AD%E6%96%AD/"/>
      <url>/forworl.github.io/2024/03/27/%E7%A1%AC%E4%B8%AD%E6%96%AD%E5%92%8C%E8%BD%AF%E4%B8%AD%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是中断？"><a href="#什么是中断？" class="headerlink" title="什么是中断？"></a>什么是中断？</h1><p>中断是硬件设备发出请求的一种方式，当计算机收到硬件的请求之后，会暂停当前处理的任务，转而调用内核的中断处理程序响应硬件的请求。要求中断处理程序尽可能快的执行完，否则会影响原本程序的执行，在中断处理的时候还可能会临时关闭中断，导致无法响应其它硬件的请求。</p><p>中断是一种异步的请求方式，在发生中断之前，CPU可以正常的执行程序。</p><h1 id="如何让中断能尽快执行完成？"><a href="#如何让中断能尽快执行完成？" class="headerlink" title="如何让中断能尽快执行完成？"></a>如何让中断能尽快执行完成？</h1><p>将中断拆分成两部分：</p><p><strong>硬中断</strong>：快速响应硬件发出的中断请求</p><p><strong>软中断</strong>：在内核线程继续完成硬中断的任务</p><p>比如网卡在接收数据包的时候，先通过DMA将数据包写入内核缓存，再硬件中断通知CPU把数据包传递给对应的进程，临时关闭中断，避免影响内核的效率，硬中断的任务就完成了，接下来内核触发软中断，执行软中断处理程序，把数据包从内核缓存找到，再逐步拆解头部信息，把数据包交给对应的应用程序。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>硬中断是硬件发出的请求，会打断CPU正在执行的程序，执行速度很快</p><p>软中断在硬中断之后，交由内核线程继续完成硬中断的后续任务</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>简单了解GC垃圾回收</title>
      <link href="/forworl.github.io/2024/03/25/GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
      <url>/forworl.github.io/2024/03/25/GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是垃圾回收"><a href="#什么是垃圾回收" class="headerlink" title="什么是垃圾回收"></a>什么是垃圾回收</h1><p>一般在内存不足的时候，JVM会发生垃圾回收释放掉一些无用的内存，那么哪些是无用的内存：</p><h2 id="数据存放的区域来说"><a href="#数据存放的区域来说" class="headerlink" title="数据存放的区域来说"></a>数据存放的区域来说</h2><p>运行时数据区里面被分成很多部分，我们一般关注的就是<strong>堆和方法区</strong>（这里也是内存变动较大的区域），对于程序计数器、栈等区域，我们一般认为内存大小在创建的时候就已经确定了（除了编译器的一些优化，不过无关紧要）。</p><h2 id="存放的数据来说"><a href="#存放的数据来说" class="headerlink" title="存放的数据来说"></a>存放的数据来说</h2><p>堆中存放着大量对象：</p><p><strong>死亡的对象</strong>：没有被引用到的对象</p><p>而方法区常量池中存放着常量和类的元信息：</p><p><strong>废弃的常量</strong>：没有被引用到的常量，如串池的一些字符串常量</p><p><strong>废弃的类</strong>：</p><ul><li>该类所有对象实例都被回收</li><li>该类的类加载器ClassLoader被回收</li><li>该类的Class对象没有被引用，比如没有用反射方法</li></ul><h1 id="如何判断对象死亡以及四种引用类型"><a href="#如何判断对象死亡以及四种引用类型" class="headerlink" title="如何判断对象死亡以及四种引用类型"></a>如何判断对象死亡以及四种引用类型</h1><h2 id="如何判断对象死亡"><a href="#如何判断对象死亡" class="headerlink" title="如何判断对象死亡"></a>如何判断对象死亡</h2><p>判断死亡对象一般有两种方式：</p><p><strong>循环计数算法</strong>：在对象内部增加一个引用计数器，当被局部变量引用一次，计数器加一；当方法结束栈销毁的时候计数器就会减一，但是可能会出现<strong>循环引用</strong>导致两个对象都无法被正确的回收</p><p><strong>可达性分析算法</strong>：从<strong>GC Root开始遍历</strong>，无法到达的对象都被判定为死亡对象，需要被垃圾回收</p><h2 id="可达性分析算法详解"><a href="#可达性分析算法详解" class="headerlink" title="可达性分析算法详解"></a>可达性分析算法详解</h2><h3 id="什么是GC-Root？"><a href="#什么是GC-Root？" class="headerlink" title="什么是GC Root？"></a>什么是GC Root？</h3><p>可以简单理解为一些不会被回收的对象。如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那么它就可以被看作为一个根节点。</p><ul><li><strong>虚拟机栈</strong>的栈帧内的局部变量引用的对象</li><li><strong>本地方法栈</strong>的栈帧内的局部变量引用的对象</li><li><strong>方法区</strong>的类静态属性引用的对象</li><li><strong>方法区</strong>的常量引用的对象</li><li>被同步锁（<strong>synchronized</strong>）锁定的对象</li><li>虚拟机的<strong>内部引用</strong>，如基本数据类型的Class对象、异常对象、系统类加载器</li></ul><h3 id="三色标记法"><a href="#三色标记法" class="headerlink" title="三色标记法"></a>三色标记法</h3><p>三色标记法用来解决遍历过程中对象引用关系变动导致某些对象被误会标记为死亡对象。</p><h4 id="节点颜色含义"><a href="#节点颜色含义" class="headerlink" title="节点颜色含义"></a>节点颜色含义</h4><p>在节点树扫描的时候，灰色在白色和黑色之间。</p><p>有以下三种颜色：</p><ul><li>白色：垃圾收集器没有扫描到的节点，<strong>需要被清除</strong></li><li>黑色：垃圾收集器已经扫描到的节点，并且所有该黑色节点的引用也被扫描到</li><li>灰色：垃圾收集器已经扫描到的节点，至少一个该灰色节点的引用没有被扫描到</li></ul><h4 id="对象消失"><a href="#对象消失" class="headerlink" title="对象消失"></a>对象消失</h4><p>并发标记过程中，前面遍历的节点引用关系变化，建立黑色和该白色的引用关系，同时将灰色到白色之间引用删除了，那么下一步就不会遍历到白色节点，导致白色节点被误删。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ul><li><p>增量更新（Incremental Update）：针对黑-白新增，记录这些黑色建立白色引用关系，并发扫描后，重新扫描这些黑色，这些黑色就会转换成灰色，白色就转换成灰色</p></li><li><p>原始快照（SATB）：针对灰-白删除，记录被删掉的原来这些灰色和白色引用关系，并发扫描后，重新按照原来的视图扫描一次</p></li></ul><h2 id="四种引用类型"><a href="#四种引用类型" class="headerlink" title="四种引用类型"></a>四种引用类型</h2><p><strong>强引用</strong>：类似new出来的对象</p><p><strong>软引用</strong>：有用但是不是必须的对象，在内存不足的时候会被回收</p><p><strong>弱引用</strong>：非必须的对象，只能存活到下次垃圾回收</p><p><strong>虚引用</strong>：无法通过虚引用获取对象实例，只是为了在对象被回收的时候得到一个通知，可用于追踪对象的垃圾回收过程</p><h1 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h1><h2 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h2><p>正是由于堆被划分出那么多的区域，才有了针对某些区域的一些垃圾回收：</p><ul><li>部分收集（Partial GC）：收集部分堆w<ul><li>新生代收集（Minor GC or Young GC）：收集整个新生代</li><li>老年代收集（Major GC or Old GC）：收集整个老年代，只有CMS有单独收集老年代的行为</li><li>混合收集（Mixed GC）：收集整个新生代和部分老年代，只有G1有</li></ul></li><li>全面收集（Full GC）：收集整个堆和方法区<ul><li>当方法区满了</li><li>新对象担保机制触发</li><li>System.gc()</li><li>除CMS外的垃圾收集器在老年代空间不足</li></ul></li></ul><h3 id="记忆集与卡表"><a href="#记忆集与卡表" class="headerlink" title="记忆集与卡表"></a>记忆集与卡表</h3><p>针对分代收集理论，<strong>在部分收集（Partial GC）的时候，可能会出现跨代引用的问题</strong>，在可达性算法分析死亡对象的时候，为了避免收集新生代的时候把整个老年代都加入 GC Root，或者是收集老年代把整个新生代加入 GC Root，这样会增加第一步搜寻GC Root的时间（这步需要STW），就使用了记忆集与卡表的方式，<strong>卡表是记忆集的其中一种实现方式</strong>，<strong>卡表是一个数组，每个元素对应一个512MB的卡页</strong>（内存被分为很多卡页），如果卡页内的一个或者多个对象跨代引用，那么把这个卡页对应的卡表索引元素置为脏，也就是标识为1，这样就可以把这些变脏的元素对应的卡页的对象加入GC Root，而不用加入所有的老年代对象。</p><p>简单来说，如果 card 1 是脏的（值为1），通过卡表的索引 1 * 512MB 可以得到 page 1，然后把 page 1 里面的对象加入GC Root。                                              </p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240327200723174.png" alt="image-20240327200723174"></p><h2 id="标记-清除算法（一般不用）"><a href="#标记-清除算法（一般不用）" class="headerlink" title="标记-清除算法（一般不用）"></a>标记-清除算法（一般不用）</h2><p>通过可达性分析算法标记死亡对象，再清除死亡对象</p><ul><li>优点：执行较快，因为不涉及移动存活对象</li><li>缺点：大量不连续的外部碎片</li></ul><p>如果需要用这些外部碎片分配对象，就需要使用空闲列表的方式存储这些空闲内存，但是随机访问效率是不如下面两种算法的顺序访问的。</p><p>如果新对象分配不够空间，就需要对象担保机制介入了。</p><h2 id="标记-复制算法（新生代）"><a href="#标记-复制算法（新生代）" class="headerlink" title="标记-复制算法（新生代）"></a>标记-复制算法（新生代）</h2><p>堆被分为两块区域，回收只在一块区域s1进行。</p><p>通过可达性分析算法标记死亡对象，再清除死亡对象，最后把存活对象搬到另一块区域s2</p><ul><li>优点：常用于新生代，存活对象较少，执行较快，并且无外部碎片</li><li>缺点：可用内存只有原来的一半</li></ul><h2 id="标记-整理算法（老年代）"><a href="#标记-整理算法（老年代）" class="headerlink" title="标记-整理算法（老年代）"></a>标记-整理算法（老年代）</h2><p>通过可达性分析算法标记死亡对象，再清除死亡对象，最后把存活对象搬到一起</p><ul><li>优点：无外部碎片</li><li>缺点：常用于老年代，因为大多数对象存活，所以执行较慢</li></ul><h1 id="STW和安全点"><a href="#STW和安全点" class="headerlink" title="STW和安全点"></a>STW和安全点</h1><h2 id="初始标记GC-Root为什么要STW？"><a href="#初始标记GC-Root为什么要STW？" class="headerlink" title="初始标记GC Root为什么要STW？"></a>初始标记GC Root为什么要STW？</h2><ul><li>一方面是为了避免浮动垃圾</li><li>另一方面是避免标记过程发生引用关系的变化导致GC错误</li></ul><h2 id="什么是安全点？"><a href="#什么是安全点？" class="headerlink" title="什么是安全点？"></a>什么是安全点？</h2><p>当我们需要阻塞线程必须要到达安全点，当线程到达安全点，堆对象的状态是一致的，此时可以进行GC、偏向锁撤销等操作。</p><ul><li>循环结束的末尾段</li><li>方法调用之后</li><li>抛出异常的位置</li><li>方法返回之前</li></ul><p>当JVM需要发生GC、偏向锁撤销等操作时，如何才能让所有线程到达安全点阻塞或停止？</p><ul><li>①主动式中断(JVM采用的方式)：不中断线程，而是设置一个标志，而后让每条线程执行时主动轮询这个标志，当一个线程到达安全点后，发现中断标志为<code>true</code>时就自己中断挂起。</li><li>②抢断式中断：先中断所有线程，如果发现线程未执行到安全点则恢复线程让其运行到安全点位置。</li></ul><h2 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h2><p>当线程处于阻塞或者挂起状态，无法响应JVM的中断请求，同时这段代码不会影响堆对象的引用，这段代码就是安全区域，当挂起的线程恢复执行，需要先判断可达性分析即初始标记是否结束才能继续执行。</p><h1 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h1><h2 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h2><p>CMS是JDK5~JDK8应用在老年代的回收器，配合的是分代理论。</p><p><strong>回收过程</strong></p><h2 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h2><p>G1在JDK9~JDK16被应用， 逻辑分代但是物理不分代，改为一个个的Region区，大对象有个特殊的区域（只要超过Region区的一半就直接放入大对象区）。</p><p><strong>回收过程</strong></p><h2 id="ZGC"><a href="#ZGC" class="headerlink" title="ZGC"></a>ZGC</h2><p>JDK17以后被应用，逻辑和物理都不分代，有几种不同内存大小类型的Region区。</p><p><strong>回收过程</strong></p><h1 id="OOM"><a href="#OOM" class="headerlink" title="OOM"></a>OOM</h1><h2 id="什么情况会发生OOM？"><a href="#什么情况会发生OOM？" class="headerlink" title="什么情况会发生OOM？"></a>什么情况会发生OOM？</h2><p>OOM一般是由于无法分配足够大的内存给新对象的，JVM有垃圾回收机制来尽可能的保证内存空间的富足，但是如果Full GC之后还是无法提供足够的内存，就会抛出OOM异常。</p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240415095811035.png" alt="image-20240415095811035"></p><h2 id="哪块区域会发生OOM？"><a href="#哪块区域会发生OOM？" class="headerlink" title="哪块区域会发生OOM？"></a>哪块区域会发生OOM？</h2><h3 id="堆OOM"><a href="#堆OOM" class="headerlink" title="堆OOM"></a>堆OOM</h3><p>-Xms -Xmx</p><p>原因：</p><ul><li>代码问题，出现死循环或者无限递归产生大量对象</li><li>程序设置的堆最大内存过小</li><li>出现内存泄露，逐渐蚕食内存</li></ul><h3 id="栈OOM"><a href="#栈OOM" class="headerlink" title="栈OOM"></a>栈OOM</h3><p>-Xss最大深度</p><p>HotSpot虚拟机将虚拟机栈和本地方法栈的溢出都归到虚拟机栈的溢出。</p><p>对于栈来说，不只有OOM还有SOF：</p><ul><li>SOF：如果虚拟机栈大小固定，当前线程请求栈的深度大于虚拟机的最大值，则抛出SOF异常；一般是无限递归引起的</li><li>OOM：如果虚拟机栈大小可动态扩展，扩展时无法申请到足够的内存就会抛出OOM异常；可能是虚拟机栈最大值分配太小</li></ul><h3 id="方法区OOM"><a href="#方法区OOM" class="headerlink" title="方法区OOM"></a>方法区OOM</h3><p>方法区保存类的元信息，还有运行时常量池会保存一些JIT热点编译后的机器码和一些代理类</p><p>原因：</p><ul><li>加载类信息过多</li><li>JIT热点代码过多</li><li>CGLIB生成的代理类过多</li></ul><h3 id="直接内存OOM"><a href="#直接内存OOM" class="headerlink" title="直接内存OOM"></a>直接内存OOM</h3><p>-XX:MaxDirectMemorySize</p><p>原因：</p><ul><li>一直用Unsafe类申请直接内存并且不释放，在Full GC之前耗尽所有的资源</li><li>申请的内存超过最大值</li></ul><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>程序申请的内存空间在使用完没有被正确释放，同时还有引用链指向这块内存导致无法被GC回收，逐渐会蚕食有效内存。</p><p>如ThreadLocal、一些资源连接、static对象、字符串对象等。</p><p>ThreadLocal内存泄漏：</p><p>外部创建的ThreadLocal没有强引用指向，并且线程一直不结束如线程池核心线程，那么ThreadLocal的弱引用（这个ThreadLocalMap的key），可能就会被GC回收，但是ThreadLocalMap是和Thread相关的，线程不结束，value就一直没有办法被回收就会导致内存泄漏。</p><p><strong>和内存溢出OOM的区别？</strong></p><ul><li>你有一个箱子，你往里面放杂物，但是你的杂物太多放不下就会导致<strong>OOM</strong></li><li>同样的箱子，里面有你上次装的杂物，这次的杂物太多也会放不下导致<strong>内存泄漏</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>简单了解synchronized</title>
      <link href="/forworl.github.io/2024/03/25/synchronized/"/>
      <url>/forworl.github.io/2024/03/25/synchronized/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是synchronized"><a href="#什么是synchronized" class="headerlink" title="什么是synchronized"></a>什么是synchronized</h1><p>synchronized是Java提供的一个关键字，用于方法或者代码块，保证并发安全。</p><h1 id="synchronized使用场景"><a href="#synchronized使用场景" class="headerlink" title="synchronized使用场景"></a>synchronized使用场景</h1><h2 id="同步代码块（原子性）"><a href="#同步代码块（原子性）" class="headerlink" title="同步代码块（原子性）"></a>同步代码块（原子性）</h2><p>synchronized可以用在方法上，或者用在代码块。</p><p>可锁的对象可以是普通对象，或者是类（也就是Class对象）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">monitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (monitor) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;对象锁同步代码块访问&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (SynchronizedTest.class) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;类锁同步代码块访问&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h2><p>线程交替打印1~100</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">monitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Print</span>(), <span class="string">&quot;thread-1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Print</span>(), <span class="string">&quot;thread-2&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Print</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count &lt;= MAX) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (monitor) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (count &lt;= MAX) &#123;</span><br><span class="line">                            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + count);</span><br><span class="line">                            count++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        monitor.notify();</span><br><span class="line">                        monitor.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="synchronized原理"><a href="#synchronized原理" class="headerlink" title="synchronized原理"></a>synchronized原理</h1><h2 id="字节码层面"><a href="#字节码层面" class="headerlink" title="字节码层面"></a>字节码层面</h2><ul><li>同步代码块使用monitorenter和monitorexit实现</li><li>同步方法使用ACC_SYNCHRONIZED实现</li></ul><h2 id="数据结构方面"><a href="#数据结构方面" class="headerlink" title="数据结构方面"></a>数据结构方面</h2><p>和ReentrantLock有着类似的实现结构：</p><ul><li>monitor：锁对象，有一个count计数器用来实现重入</li><li>value：互斥量</li><li>Owner：持有锁的线程</li><li>EntryList：同步队列，没有获取到锁的线程会在这里阻塞</li><li>WaitSet：条件队列，持有锁的线程调用了wait()之后会被放到条件队列，并唤醒同步队列的第一个阻塞节点</li></ul><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240325185308438.png" alt="image-20240325185308438"></p><h1 id="synchronized锁升级"><a href="#synchronized锁升级" class="headerlink" title="synchronized锁升级"></a>synchronized锁升级</h1><p>synchronized的锁有四种状态：无锁、偏向锁、轻量级锁、重量级锁</p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240325191122481.png" alt="image-20240325191122481"></p><p><strong>对于没有锁定的对象，锁标志位是01</strong>，此时可能是无锁或者偏向锁状态，对于轻量级锁，锁标志位是00，对于重量级锁，锁标志位是10。</p><p>在JDK6以后引入了偏向锁以及轻量级锁来优化synchronized的性能，这才使得synchronized的性能和ReentrantLock的性能差不多。</p><h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>轻量级锁是为了只有<strong>两个线程来交替获取同一个锁</strong>的状况进行的优化，对于没有锁定的对象，会先在本线程的栈帧生成一个锁记录（Lock Record）的空间，用于拷贝当前的Mark Word，随后用CAS把Mark Word指向栈帧的指针指向本线程：</p><ul><li>如果成功了，则代表当前线程获取到该对象的锁，并且修改锁标志位为00。</li><li>如果失败了，则说明至少有一条线程在争抢锁，先检查Mark Word当前指针是否指向本线程的栈帧，是则直接进入同步代码块执行，如果有多条线程争抢，则锁需要膨胀到重量级锁。</li></ul><p>对于轻量级锁的释放，同样用到CAS操作，把栈帧的锁记录（Lock Record）替换回Mark Word：</p><ul><li>如果成功了，则说明同步过程完成</li><li>如果失败了，也就是锁膨胀了，说明其它（第三个或者更多）线程尝试获取过该锁，需要唤醒其它线程</li></ul><h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>偏向锁是为了消除无竞争的情况下的一个锁优化，当线程获取一个无锁状态的对象，会先用CAS尝试修改Thread ID设置为自己的线程ID，如果设置成功，同时会把偏向锁标志位设置为1，此后的线程访问这个同步代码块将不用再执行同步操作。</p><p>当有其他线程尝试获取锁的时候，偏向锁失效，发生锁升级为轻量级锁，撤销偏向锁标志位为0，后续操作在轻量级锁已经叙述过。</p><h2 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h2><p>利用操作系统进程通信信号量的互斥量来实现，锁标志位为10，在多线程竞争锁的时候，重量级锁更加合适，避免了线程空转占用CPU</p><h1 id="synchronized锁优化"><a href="#synchronized锁优化" class="headerlink" title="synchronized锁优化"></a>synchronized锁优化</h1><p><strong>锁自旋</strong></p><p>锁自旋（不断重试）代替锁阻塞（放弃CPU时间片，直接挂起）</p><p><strong>锁消除</strong></p><p>逃逸分析（锁的对象是本地变量，不会共享），某个代码块只会被单一线程访问</p><p><strong>锁粗化</strong></p><p>不要连续的加锁和解锁，适当加大锁的粒度可能效率更高，避免在循环次数很多的循环内部使用synchronized</p>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>简单了解原型模式</title>
      <link href="/forworl.github.io/2024/03/25/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/forworl.github.io/2024/03/25/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是原型模式"><a href="#什么是原型模式" class="headerlink" title="什么是原型模式"></a>什么是原型模式</h1><p>区别于单例模式，原型模式的一个类可以有多个实例化的对象。</p><p>原型模式通过拷贝来产生新的对象，而不是new，并且可以根据自己的需求修改对象的属性。</p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240114094925346.png" alt="image-20240114094925346"></p><h1 id="实现Cloneable接口实现拷贝"><a href="#实现Cloneable接口实现拷贝" class="headerlink" title="实现Cloneable接口实现拷贝"></a>实现Cloneable接口实现拷贝</h1><p>而拷贝又分为浅拷贝和深拷贝，两者在基本字段的拷贝没有区别，主要区别在于引用字段的拷贝</p><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>调用super.clone()完成拷贝，不拷贝引用类型对象，也就是两个引用的字段都指向同一个对象</p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240327154653079.png" alt="image-20240327154653079"></p><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>可以重新clone()完成拷贝，自己新建一个引用类型对象，让两个引用的字段都指向不同的对象</p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240327154735665.png" alt="image-20240327154735665"></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>简单了解单例模式</title>
      <link href="/forworl.github.io/2024/03/25/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/forworl.github.io/2024/03/25/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是单例模式"><a href="#什么是单例模式" class="headerlink" title="什么是单例模式"></a>什么是单例模式</h1><p>对于一个类，只有一个实例化的对象，我们构建单例模式一般有两种：饿汉式和懒汉式</p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240119092547006.png" alt="image-20240119092547006"></p><h1 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h1><ul><li>优点是无线程安全问题，类加载就创建对象</li><li>缺点是占内存</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton01</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton01</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton01</span>();<span class="comment">//声明对象同时私有化</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton01 <span class="title function_">getInstance</span><span class="params">()</span>&#123;<span class="comment">//向外声明访问该类对象的方法</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h1><ul><li>优点是延迟加载，创建后才占用内存</li><li>缺点是有线程安全问题，需要双重检查锁保证</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.线程不安全 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton02</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">Singleton02</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//声明对象，不实例化</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton02 <span class="title function_">getInstance</span><span class="params">()</span>&#123;<span class="comment">//向外提供访问该类对象的方法</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton02</span>();</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2.double-check锁保证线程安全</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton02</span> &#123;</span><br><span class="line">    <span class="comment">// 由于锁已经保证了可见性，这里volatile的作用是防止new过程中的指令重排</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">Singleton02</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//声明对象，不实例化</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton02 <span class="title function_">getInstance</span><span class="params">()</span>&#123;<span class="comment">//向外提供访问该类对象的方法</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton02.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton02</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3.CAS实现无锁线程安全创建单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton02</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicReference&lt;Singleton02&gt; instanceRef = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton02 <span class="title function_">getInstance</span><span class="params">()</span> &#123;<span class="comment">//向外提供访问该类对象的方法</span></span><br><span class="line">        <span class="comment">// CAS配合自旋，CAS有volatile的语义，AtomicReference的实现是value用volatile修饰</span></span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            <span class="type">Singleton02</span> <span class="variable">instance</span> <span class="operator">=</span> instanceRef.get();</span><br><span class="line">            <span class="keyword">if</span> (instance != <span class="literal">null</span>) <span class="keyword">return</span> instance;</span><br><span class="line">            instanceRef.compareAndSet(<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Singleton02</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Spring的单例模式"><a href="#Spring的单例模式" class="headerlink" title="Spring的单例模式"></a>Spring的单例模式</h1><p>在Spring中，bean的scope有几种，常见的如singleton、prototype、request、session等，默认是singleton，也就是Spring的bean默认是单例的，在getBean()的时候默认先从缓存拿，如果没有才懒加载创建bean，并且创建完成之后加入缓存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一级缓存，beanName -&gt; 实例化并且初始化的成品</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">256</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>AOP简单使用的时候的问题</title>
      <link href="/forworl.github.io/2024/03/24/AOP%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E7%9A%84%E6%97%B6%E5%80%99%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/forworl.github.io/2024/03/24/AOP%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E7%9A%84%E6%97%B6%E5%80%99%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>问题主要出在测试类</p><h1 id="目标类"><a href="#目标类" class="headerlink" title="目标类"></a>目标类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Target</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TargetImpl</span> <span class="keyword">implements</span> <span class="title class_">Target</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="切面类"><a href="#切面类" class="headerlink" title="切面类"></a>切面类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;DoAOP&quot;)</span></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">// 告知Spring容器当前DoAOP类是一个切面类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoAOP</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.example.leetcode.aop..*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointcut</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;pointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法之前执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;pointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        joinPoint.proceed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h1><p>这里要从IoC获取bean，我一开始自己new对象，发现怎么都不对，后来想到AOP是在bean的生命周期完成代理bean的替换，自己new不是代理类，自然无法用到那些增强的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span> <span class="comment">// 创建spring的测试环境</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span> <span class="comment">// 用JDK还是CGLIB动态代理</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.example.leetcode.aop&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AOPTest</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span> &#123;</span><br><span class="line"></span><br><span class="line">    ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 这里要从IoC获取bean</span></span><br><span class="line">        <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> applicationContext.getBean(TargetImpl.class);</span><br><span class="line">        target.fun();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="built_in">this</span>.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>简单了解TCP</title>
      <link href="/forworl.github.io/2024/03/24/TCP/"/>
      <url>/forworl.github.io/2024/03/24/TCP/</url>
      
        <content type="html"><![CDATA[<h1 id="TCP是什么？"><a href="#TCP是什么？" class="headerlink" title="TCP是什么？"></a>TCP是什么？</h1><p>由于应用层IP协议的不可靠传输，主要是无法保证数据报到达目的地以及包乱序的问题，<strong>在运输层实现了TCP协议，提供可靠的传输</strong>，对于TCP来说，在发送数据之前需要先建立连接，同时每个报文段的大小不能超过MSS，对于IP协议来说，MSS + IP头和TCP头的大小不能超过MTU（一般是1500字节）。</p><h1 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h1><p>TCP和UDP都是运输层的协议，提供进程到进程的一个逻辑连接，两者的主要区别体现在：</p><ul><li><strong>连接</strong>：TCP是面向连接的，用一个四元组标记一个TCP连接，UDP则不用握手就可以传输，只需要一个二元组（目标IP，目标端口）标记一个UDP</li><li><strong>字节流</strong>：TCP是基于字节流的，有粘包问题（所以要记录数据长度），而UDP是基于报文的</li><li><strong>可靠</strong>：TCP是可靠传输（重传、网络控制、拥塞控制），而UDP的数据报可能丢失</li><li><strong>头部长度</strong>：TCP的头部长度一般是20字节，而UDP的头部长度只有8字节</li><li><strong>使用场景</strong>：TCP一般用于文件传输或者浏览器HTTP请求等，UDP主要用于视频通话或者DNS等</li></ul><h1 id="TCP的面向连接是什么"><a href="#TCP的面向连接是什么" class="headerlink" title="TCP的面向连接是什么"></a>TCP的面向连接是什么</h1><p>如果传输层协议选择了TCP，那么在首次发送报文段之前需要通过三次握手先建立TCP连接。</p><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p><strong>第一次握手</strong>：客户端初始一个序列号client_isn，发送SYN报文给服务端</p><p><strong>第二次握手</strong>：服务端响应客户端的SYN报文，同时初始一个序列号server_isn，发送SYNACK报文给客户端</p><p>客户端收到第二次握手已经成功建立连接，第三次握手可以携带数据</p><p><strong>第三次握手</strong>：客户端响应服务端的SYN报文</p><h3 id="socket编程"><a href="#socket编程" class="headerlink" title="socket编程"></a>socket编程</h3><p>TODO</p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240325095221964.png" alt="image-20240325095221964"></p><p>如果某一方因为某些原因（关闭了浏览器、进程崩溃、宕机等因素）会主动关闭连接，此时就会发生四次挥手来完成关闭连接</p><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p><strong>第一次挥手</strong>：一般是客户端发起，发送FIN报文给服务端</p><p><strong>第二次挥手</strong>：服务器端响应ACK给客户端，同时进入CLOSE_WAIT状态</p><p>如果服务器端有数据要发送，在此时发送，等到发送完成之后才继续进行第三次挥手</p><p><strong>第三次挥手</strong>：服务器端发送FIN报文给客户端</p><p>客户端收到第三次握手，进入TIME_WAIT状态</p><p><strong>第四次挥手</strong>：客户端响应ACK给服务器端</p><h3 id="CLOSE-WAIT状态"><a href="#CLOSE-WAIT状态" class="headerlink" title="CLOSE_WAIT状态"></a>CLOSE_WAIT状态</h3><p>TODO</p><h3 id="TIME-WAIT状态"><a href="#TIME-WAIT状态" class="headerlink" title="TIME_WAIT状态"></a>TIME_WAIT状态</h3><p>TODO</p><p><img src="C:\Users\fuleyou\AppData\Roaming\Typora\typora-user-images\image-20240325100624153.png" alt="image-20240325100624153"></p><h1 id="TCP如何保证可靠传输"><a href="#TCP如何保证可靠传输" class="headerlink" title="TCP如何保证可靠传输"></a>TCP如何保证可靠传输</h1><h2 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h2><h2 id="网络控制"><a href="#网络控制" class="headerlink" title="网络控制"></a>网络控制</h2><h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>简单了解volatile</title>
      <link href="/forworl.github.io/2024/03/22/volatile/"/>
      <url>/forworl.github.io/2024/03/22/volatile/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是volatile"><a href="#什么是volatile" class="headerlink" title="什么是volatile"></a>什么是volatile</h2><p>volatile是Java的一个关键字，用于修饰变量，保证变量的可见性以及有序性。</p><h1 id="volatile的使用场景"><a href="#volatile的使用场景" class="headerlink" title="volatile的使用场景"></a>volatile的使用场景</h1><h2 id="线程通信（可见性）"><a href="#线程通信（可见性）" class="headerlink" title="线程通信（可见性）"></a>线程通信（可见性）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">volatileTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 3s 后修改 flag = false</span></span><br><span class="line">        interruptFun();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;正在循环&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">interruptFun</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="限制指令重排（有序性）"><a href="#限制指令重排（有序性）" class="headerlink" title="限制指令重排（有序性）"></a>限制指令重排（有序性）</h2><p>拿懒汉式单例模式来举例，volatile不仅可以保证对象不会被重复创建，同时还可以保证其它线程不会获取到一个未初始化的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">volatileTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> Object singleton;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">monitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> getSingleTon();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object <span class="title function_">getSingleTon</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (monitor) &#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="volatile原理"><a href="#volatile原理" class="headerlink" title="volatile原理"></a>volatile原理</h1><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>简而言之就是本线程对共享变量的修改对其它线程是可见的，强制线程每次读本地变量都需要从主存同步最新值，每次修改完之后都需要同步到主存，相当于通过主存通知其它线程把本地变量置为无效状态。</p><h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>简而言之就是线程的某个语句的底层指令不会被重排优化（编译器或者处理器优化）而导致最后的语义不同，通过内存屏障来解决这个问题，有4种内存屏障：</p><ul><li>StoreStore：在volatile写之前，保证之前的普通写不会重排到volatile写之后</li><li><strong>StoreLoad</strong>：在volatile写之后，保证之后的volatile读&#x2F;写不会重排volatile写之前</li><li>LoadStore：在volatile读之后，保证之后的普通读不会重排到volatile读之前</li><li>LoadStore：在volatile读之后，保证之后的普通写不会重排到volatile读之前</li></ul><p>对于x86处理器，只会重排写-读，不会重排读-读、写-写，所以只需要使用StoreLoad屏障就可以保证有序性。</p><p>拿上述的单例模式来说，保证了对volatile的singleton的读取在volatile写之后，就可以保证对象是完全创建好的。</p>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode的LRU缓存实现</title>
      <link href="/forworl.github.io/2024/03/22/LeetCode%E7%9A%84LRU%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0/"/>
      <url>/forworl.github.io/2024/03/22/LeetCode%E7%9A%84LRU%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="LRU是什么意思"><a href="#LRU是什么意思" class="headerlink" title="LRU是什么意思"></a>LRU是什么意思</h1><p>LRU是操作系统底层的一个页面置换算法，当空间不够需要换出最长时间没有使用的页面，在本题中的意思就是当到达容量上限的时候要换出最长时间没有被访问过的节点。</p><h1 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h1><p>LRU的实现可以使用链表的方式，参照MySQL的实现，将热数据每次都放到链表头，删除链表尾的冷数据。</p><p>题目需要get()和put()方法都是O(1)的事件复杂度，但是链表遍历需要O(n)的时间复杂度，无法满足题目要求，可以想到数组下标索引或者HashMap辅助我们访问，本题如果用数组还需要多写一步hash()来确认key存放的位置，所以我们使用HashMap。</p><p>通过HashMap我们可以快速找到节点，也就满足了get()的O(1)，但是对于put()的O(1)，考虑到我们需要删除节点，单链表显然无法满足，因为单链表需要O(n)找到前驱节点，所以我们修改为双链表。</p><p>最终的结构就是HashMap + 双链表。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>简单了解JMM</title>
      <link href="/forworl.github.io/2024/03/18/JMM/"/>
      <url>/forworl.github.io/2024/03/18/JMM/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是JMM"><a href="#什么是JMM" class="headerlink" title="什么是JMM"></a>什么是JMM</h1><p>对于不同的硬件和操作系统，有着自己的底层内存模型，可能导致Java程序在一些的平台可以正确并发，而在另一些平台出现并发错误，JMM是Java内存模型，是语言级别的内存模型，用于<strong>屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的并发效果</strong>，JMM主要考虑的就是<strong>各种变量的访问规则</strong>，正确实现线程间的通信以及线程间的同步，对于JMM，把各种硬件抽象为本地内存和主存来存放变量。</p><p>总的来说JMM把硬件和操作系统的差异屏蔽了，让Java在不同机器上都可以正确的实现并发。</p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240318203150822.png" alt="image-20240318203150822"></p><h1 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h1><p>关于变量如何从主存拷贝到本地线程以及变量如何从本地线程同步到主存的细节，JMM定义了8中操作来完成，对于每个线程来说，只能操作本地内存的变量，规定read、load要顺序执行，store、write要顺序执行。</p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240318205713894.png" alt="image-20240318205713894"></p><h1 id="操作系统的三大问题"><a href="#操作系统的三大问题" class="headerlink" title="操作系统的三大问题"></a>操作系统的三大问题</h1><p>在谈论JMM之前，首先我们需要了解操作系统的几个问题，JMM正是解决了操作系统这些问题。</p><p>随着时代的发展，计算机逐步更新换代，人们对于计算机的要求越来越高，对于家庭或者公司的电脑需要人机交互，这就要求计算机需要有较短的响应时间，为此工程师引入了CPU的多级缓存、时间片轮转调度算法、指令优化重排，但是也相应的带来了问题：</p><ul><li>CPU缓存一致性问题（可见性），解决方案：总线锁、MESI协议</li><li>代码被多个线程访问的并发问题（原子性），解决方案：锁</li><li>指令没有按照程序员的意愿执行（有序性）</li></ul><h1 id="JMM抽象的问题"><a href="#JMM抽象的问题" class="headerlink" title="JMM抽象的问题"></a>JMM抽象的问题</h1><p>可见性：线程本地变量和内存的可见性问题，规定线程只能操作本地内存变量，线程对内存的修改无法及时被其它线程看到</p><p>原子性：如 i++ 语句，底层由多条指令组成，CPU实际执行的是指令，在指令执行期间可能会发生时钟中断切换线程，最终导致程序执行结果出问题</p><p>有序性：如 Java 创建对象过程，类加载 -&gt; 实例化 -&gt; 初始化 -&gt; 引用赋值，由于指令重排可能导致引用赋值在初始化之前，导致其它线程使用到未初始化的对象</p><h1 id="Java关键字如何解决问题"><a href="#Java关键字如何解决问题" class="headerlink" title="Java关键字如何解决问题"></a>Java关键字如何解决问题</h1><ul><li>可见性：<ul><li>可通过volatile关键字解决，强制线程每次修改本地变量需要同步到主存，同时每次读取本地变量都需要从主存读取</li><li>可通过synchrinized关键字解决，锁获取和volatile读有相同的语义，将本地变量置为无效状态，锁释放和volatile写有相同的语义，变量需要同步到主存</li><li>可通过final关键字解决，构造函数返回后，任何线程都可以看到final字段正确初始化之后的值</li></ul></li><li>原子性：可通过synchrinized关键字解决，底层是通过monitorenter和monitorexit字节码指令</li><li>有序性：<ul><li>可通过volatile关键字解决，volatile规则</li><li>可通过synchrinized关键字解决，程序次序规则（只有一个线程访问同步代码块，单线程重排优化语义是一样的）</li></ul></li></ul><h1 id="Happens-Before原则"><a href="#Happens-Before原则" class="headerlink" title="Happens-Before原则"></a>Happens-Before原则</h1><p>如果JMM中所有的有序性仅靠volatile和synchronized来完成，未免很多操作有点啰嗦，<strong>我们在日常编码的过程中并不会过多关注有序性，因为有个Happens-Before原则来辅助保证代码操作的顺序性</strong>。</p><p>常见的Happens-Before原则：</p><ul><li>程序次序规则：同一个线程内，对于顺序执行，前面的操作先行于后面的操作</li><li>管程锁定规则：对于一个锁，unlock先行于lock</li><li>volatile规则：对于一个用volatile修饰的变量，写操作先行于读操作</li><li>线程启动规则：start()先行于这个线程的其它动作</li><li>线程终止规则：线程所有动作先行于终止检查</li><li>线程中断规则：interrupt()先行于检测到中断事件的发生</li><li>对象终止规则：对象的初始化完成先行于销毁</li><li>传递性：A操作先行于B操作，B操作先行于C操作，那么A操作先行于C操作</li></ul><p>如下面这个程序，你不能保证 i &#x3D; 1 一定会在 j &#x3D; 2 前执行，但是这也不影响Happens-Before原则的正确性，因为这并不影响整个程序执行结果的正确性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>简单了解内存管理</title>
      <link href="/forworl.github.io/2024/03/18/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>/forworl.github.io/2024/03/18/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h1><p>操作系统需要管理的就是各个进程的内存，对于进程，需要存储代码、堆、栈等信息，如果让程序员直接来操控物理内存管理进程的话，难度会更大，需要考虑进程在哪个位置分配、会不会冲突等问题，那么操作系统提供了虚拟内存给程序员使用，背后的实现这些脏活累活都交给操作系统去完成了，对于虚拟内存，有一些追求的目标：</p><ul><li>透明：每个进程看上去都有自己的内存，从0地址开始</li><li>效率：在虚拟内存转换到物理内存的时候兼顾时间（TLB哈希表）和空间（多级页表懒加载）</li><li>保护：每个进程是隔离的</li></ul><p>除了硬件的底层实现，同时也需要有一些上层的策略（如可用内存如何管理、内存不够哪些内存可以释放）</p><h1 id="硬件的地址转换"><a href="#硬件的地址转换" class="headerlink" title="硬件的地址转换"></a>硬件的地址转换</h1><p>硬件的地址转换也可以叫做虚拟内存和物理内存的联系：<strong>物理内存 &#x3D;&#x3D; 虚拟地址 配合 基址寄存器</strong>，可以理解为基址寄存器保存着虚拟地址转换来的物理地址的起始点，界限寄存器用来保证访问不越界。</p><p><strong>这两个寄存器是CPU的重要部分，具体来说是CPU的内存管理单元MMU的重要部分</strong>，MMU是操作系统在进程上下文切换用来临时保存将要执行的进程的信息，而对于首次运行的进程，需要从进程列表（保存所有的进程信息）中的进程结构PCB拿出进程信息恢复到MMU，然后返回用户态执行进程。</p><p>对于越界访问的进程，界限寄存器会判断并跳转到内核态的异常处理程序。</p><h1 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h1><p>对于进程内部的虚拟内存，<strong>栈和堆之间有很大一块空闲空间</strong>，我们可以通过分段把这块空闲空间放到进程外部，把进程内存细分为几个段（如代码段、堆段、栈段），<strong>每个段有自己独立的基址寄存器和界限寄存器，也就是说MMU里面有多个寄存器对</strong>，进程上下文切换的时候需要恢复多个寄存器对。</p><p>我们如何才能知道访问到哪个段？将虚拟地址切割，前两位表示哪个段（对应使用哪个寄存器对），后几位表示段内偏移量，还有几位表示保护位（规定进程的访问权限，用于进程共享时检查）。</p><h2 id="分段的空闲内存管理"><a href="#分段的空闲内存管理" class="headerlink" title="分段的空闲内存管理"></a>分段的空闲内存管理</h2><p>对于<strong>分段</strong>这种机制，拿堆的内存分配举例，会产生许多的<strong>外部碎片</strong>，我们可以使用<strong>空闲列表</strong>的方式去管理这些空闲的内存（外部碎片），对于每块空闲内存，他都有一个<strong>头部</strong>用来存放当前空闲内存的字节数（进程使用完后free()释放这块内存）、以及指向下一个空闲内存的指针。当需要申请增大堆空间的时候，只需要把空闲列表尾节点的指针指向新申请到的内存。</p><p>当归还的内存和原有的空闲内存的地址相邻的时候，我们需要去合并他们，这里简单介绍一下简单合并的方法，<strong>伙伴系统</strong>（不针对分段）：将一块堆内存空间分成很多小块以及更小的块，每个小块或者更小的块都是2^n字节大小（递归分配），在进程需要内存的时候，分配一块2^n字节大小的给进程（没有外部碎片但是有内部碎片），归还的时候只需要看看兄弟节点是否是空闲的，然后递归合并。</p><h1 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h1><p>对于<strong>分段，每个段的大小是不相同的</strong>，产生的外部碎片会比较多，不利于空间的分配，我们需要一种<strong>分页的机制，每个内存页的大小相同</strong>，就不存在外部碎片了，空闲页同样会用空闲列表保存。那么<strong>分页是如何进行地址转换的呢？</strong>虚拟内存会被分为多个部分，比如VPN（虚拟内存页号）、偏移量，存放在内存的页表将VPN转换成PFN（物理页号）再 + 偏移量，就得到实际的物理地址了，分页这里用页表替换了基址寄存器的功能。</p><p>当然相应的也会存在一些问题：分页需要内存的页表进行虚拟地址到物理地址的映射转换，就需要额外多一次访问内存、以及页表也是需要占用内存空间的，我们无法忍受多进程下页表占用大量的内存空间。</p><h2 id="TLB（快速地址转换）"><a href="#TLB（快速地址转换）" class="headerlink" title="TLB（快速地址转换）"></a>TLB（快速地址转换）</h2><p><strong>对于多一次访问内存，我们可以在CPU加入地址映射缓存TLB来加快访问速率</strong>，CPU对于CPU缓存的访问是比访问内存快的，但是缓存一般会比较小，同时需要去维护缓存。</p><p><strong>在进程上下文切换的时候，和分段不同，不用保存和恢复寄存器对的内容，而是使用TLB代替，需要恢复TLB，但是还是需要保存恢复程序计数器等其他的硬件信息的</strong>，同时会将旧的进程的页表映射缓存设置为无效（逻辑删除），当新的进程需要访问物理内存的时候，硬件发出异常，进程陷入到内核态，操作系统去完成异常中断程序（将需要的页表映射加载到TLB），进程再回到用户态再次执行刚刚访问物理内存的指令，这一次就会命中TLB缓存。</p><p>上述还有一个问题，在将需要的页表映射加载到TLB的时候，如果TLB是满的，如何选择替换哪个无效的页表映射呢？就需要用到类似于内存硬盘数据页换入换出的算法了，比如LRU等。</p><h2 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h2><p>页表也是需要占用内存空间的，我们一开始采用的是线性页表，即一开始分配一块线性的空间用来存储页表，对于多进程的现代计算机来说，需要提前分配好足够大的内存，并且使用过程中可能出现很大的空间浪费，后面我们采用了类似于树的结构，也就是多级页表这样的结构存储页表，虽然牺牲了一部分查找的时间，但是显然我们觉得<strong>内存是更加宝贵的资源，采取这种时间-空间折中的办法</strong>，而线性页表完全是用空间换取了时间。</p><p>在进程需要访问物理内存的时候，同样会到TLB先查询缓存，如果缓存未命中，才会去查询多级页表，对于多级页表的查询过程：</p><ol><li>先查询低级的页表索引目录</li><li>再逐步查找更高级的N级页表索引目录</li><li>最后加上偏移量找到页内数据</li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>简单了解ReentrantReadWriteLock</title>
      <link href="/forworl.github.io/2024/03/15/ReentrantReadWriteLock/"/>
      <url>/forworl.github.io/2024/03/15/ReentrantReadWriteLock/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是ReentrantReadWriteLock？"><a href="#什么是ReentrantReadWriteLock？" class="headerlink" title="什么是ReentrantReadWriteLock？"></a>什么是ReentrantReadWriteLock？</h1><p>ReentrantLock是Java的一个锁，用于协作多线程，对于读锁来说是一个共享锁，而写锁呢是一个独占锁，支持锁降级（占用写锁同时再获取读锁，但是占用读锁同时不能再获取写锁）</p><h1 id="ReentrantReadWriteLock的使用场景"><a href="#ReentrantReadWriteLock的使用场景" class="headerlink" title="ReentrantReadWriteLock的使用场景"></a>ReentrantReadWriteLock的使用场景</h1><p>读多于写的场景下保证并发安全同时提高效率</p><h2 id="读写缓存"><a href="#读写缓存" class="headerlink" title="读写缓存"></a>读写缓存</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缓存对象，这里用jvm缓存</span></span><br><span class="line">Map&lt;String, String&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 读写锁</span></span><br><span class="line"><span class="type">ReadWriteLock</span> <span class="variable">readWriteLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 读取操作</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getData</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="comment">// 加读锁，防止其他线程修改缓存</span></span><br><span class="line">    readWriteLock.readLock().lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        <span class="comment">// 如果缓存命中，返回</span></span><br><span class="line">        <span class="keyword">if</span>(value != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放读锁</span></span><br><span class="line">        readWriteLock.readLock().unlock();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//如果缓存没有命中，从数据库中加载</span></span><br><span class="line">    readWriteLock.writeLock().lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 细节，为防止重复查询数据库, 再次验证</span></span><br><span class="line">        <span class="comment">// 因为get 方法上面部分是可能多个线程进来的, 可能已经向缓存填充了数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        <span class="keyword">if</span>(value == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 这里可以改成从数据库查询</span></span><br><span class="line">            value = <span class="string">&quot;alvin&quot;</span>;</span><br><span class="line">            cache.put(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        readWriteLock.writeLock().unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ReentrantReadWriteLock源码解析"><a href="#ReentrantReadWriteLock源码解析" class="headerlink" title="ReentrantReadWriteLock源码解析"></a>ReentrantReadWriteLock源码解析</h1><h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><p>默认也是非公平锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantReadWriteLock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantReadWriteLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">    readerLock = <span class="keyword">new</span> <span class="title class_">ReadLock</span>(<span class="built_in">this</span>);</span><br><span class="line">    writerLock = <span class="keyword">new</span> <span class="title class_">WriteLock</span>(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读锁的偏移量，用来计算持有读锁的线程数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHARED_SHIFT</span>   <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读锁高16位，读锁个数加1，其实是状态值加 2^16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHARED_UNIT</span>    <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; SHARED_SHIFT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 锁最大数量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_COUNT</span>      <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写锁掩码，用于标记低16位，00...0011...11</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">EXCLUSIVE_MASK</span> <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读锁计数，当前持有读锁的线程数，c的高16位</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sharedCount</span><span class="params">(<span class="type">int</span> c)</span>    &#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写锁的计数，也就是它的重入次数，c的低16位</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">exclusiveCount</span><span class="params">(<span class="type">int</span> c)</span> &#123; <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前线程持有的读锁重入数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> ThreadLocalHoldCounter readHolds;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最近一个获取读锁成功的线程计数器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HoldCounter cachedHoldCounter;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个获取读锁的线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">Thread</span> <span class="variable">firstReader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// firstReader的持有数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> firstReaderHoldCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">Sync() &#123;</span><br><span class="line">    readHolds = <span class="keyword">new</span> <span class="title class_">ThreadLocalHoldCounter</span>();</span><br><span class="line">    setState(getState()); <span class="comment">// ensures visibility of readHolds</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 持有读锁的线程计数器</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">HoldCounter</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//持有数</span></span><br><span class="line">    <span class="comment">// Use id, not reference, to avoid garbage retention</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">tid</span> <span class="operator">=</span> getThreadId(Thread.currentThread());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本地线程计数器，每个线程有自己的计数器，互相隔离</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalHoldCounter</span></span><br><span class="line">        <span class="keyword">extends</span> <span class="title class_">ThreadLocal</span>&lt;HoldCounter&gt; &#123;</span><br><span class="line">    <span class="comment">// 重写初始化方法，在没有进行set的情况下，获取的都是该HoldCounter值</span></span><br><span class="line">    <span class="keyword">public</span> HoldCounter <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HoldCounter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="lock"><a href="#lock" class="headerlink" title="lock()"></a>lock()</h2><p><strong>读锁</strong></p><p>调用AQS的acquireShared()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读锁tryAcquireShared"><a href="#读锁tryAcquireShared" class="headerlink" title="读锁tryAcquireShared()"></a>读锁tryAcquireShared()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> unused)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="comment">// 写锁被持有并且不是自己持有，返回-1</span></span><br><span class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        getExclusiveOwnerThread() != current)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// r 是当前持有读锁的线程数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> sharedCount(c);</span><br><span class="line">    <span class="comment">// 尝试加读锁</span></span><br><span class="line">    <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">        r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">        <span class="comment">// 首次获取读锁,初始化firstReader和firstReaderHoldCount</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">            firstReader = current;</span><br><span class="line">            firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 当前线程是首个获取读锁的线程，持有资源数+1</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 更新cachedHoldCounter</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">HoldCounter</span> <span class="variable">rh</span> <span class="operator">=</span> cachedHoldCounter;</span><br><span class="line">            <span class="comment">// 如果需要初始化或者最近获取到读锁的线程计数器不是本线程，设置最近获取到读锁的线程计数器是本线程的计数器</span></span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="literal">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            <span class="comment">// 更新获取的读锁数量</span></span><br><span class="line">            rh.count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回1，获取锁成功</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>写锁</strong></p><p>调用AQS的acquire()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="写锁tryAcquire"><a href="#写锁tryAcquire" class="headerlink" title="写锁tryAcquire()"></a>写锁tryAcquire()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 持有读锁的线程数或者写锁的重入次数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="comment">// 当前写锁的重入次数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> exclusiveCount(c);</span><br><span class="line">    <span class="comment">// c != 0 说明当前有读锁或者写锁存在</span></span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前是读锁或者持有写锁的不是自己，返回false</span></span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 重入次数达到上限</span></span><br><span class="line">        <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置state</span></span><br><span class="line">        setState(c + acquires);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 到达这里说明当前没有锁，尝试加写锁</span></span><br><span class="line">    <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">        !compareAndSetState(c, c + acquires))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="unlock"><a href="#unlock" class="headerlink" title="unlock()"></a>unlock()</h2><p><strong>读锁</strong></p><p>调用AQS的releaseShared()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读锁tryReleaseShared"><a href="#读锁tryReleaseShared" class="headerlink" title="读锁tryReleaseShared()"></a>读锁tryReleaseShared()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> unused)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 当前为第一个获取读锁的线程</span></span><br><span class="line">    <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">        <span class="comment">// 更新线程持有数</span></span><br><span class="line">        <span class="keyword">if</span> (firstReaderHoldCount == <span class="number">1</span>)</span><br><span class="line">            firstReader = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            firstReaderHoldCount--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">HoldCounter</span> <span class="variable">rh</span> <span class="operator">=</span> cachedHoldCounter;</span><br><span class="line">        <span class="keyword">if</span> (rh == <span class="literal">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">            <span class="comment">// 获取当前线程的计数器</span></span><br><span class="line">            rh = readHolds.get();</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> rh.count;</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            readHolds.remove();</span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> unmatchedUnlockException();</span><br><span class="line">        &#125;</span><br><span class="line">        --rh.count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="comment">// 获取剩余资源</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c - SHARED_UNIT;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="comment">// Releasing the read lock has no effect on readers,</span></span><br><span class="line">            <span class="comment">// but it may allow waiting writers to proceed if</span></span><br><span class="line">            <span class="comment">// both read and write locks are now free.</span></span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>写锁</strong></p><p>调用AQS的release()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="写锁tryRelease"><a href="#写锁tryRelease" class="headerlink" title="写锁tryRelease()"></a>写锁tryRelease()</h3><p>这里的操作和ReentrantLock的释放锁很像，都是只考虑独占锁的释放</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (free)</span><br><span class="line">        setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">    setState(nextc);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>简单了解ReentrantLock</title>
      <link href="/forworl.github.io/2024/03/15/ReentrantLock/"/>
      <url>/forworl.github.io/2024/03/15/ReentrantLock/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是ReentrantLock？"><a href="#什么是ReentrantLock？" class="headerlink" title="什么是ReentrantLock？"></a>什么是ReentrantLock？</h1><p>ReentrantLock是Java的一个锁，用于协作多线程，同时也是一个独占锁</p><h1 id="ReentrantLock应用场景"><a href="#ReentrantLock应用场景" class="headerlink" title="ReentrantLock应用场景"></a>ReentrantLock应用场景</h1><h2 id="保证并发安全"><a href="#保证并发安全" class="headerlink" title="保证并发安全"></a>保证并发安全</h2><p>代替synchronized实现同步</p><h2 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h2><p>如线程交替打印1~100</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JUCTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Print</span>(), <span class="string">&quot;thread-1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Print</span>(), <span class="string">&quot;thread-2&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Print</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count &lt;= MAX) &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (count &lt;= MAX) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + count);</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    condition.signalAll();</span><br><span class="line">                    condition.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ReentrantLock源码解析"><a href="#ReentrantLock源码解析" class="headerlink" title="ReentrantLock源码解析"></a>ReentrantLock源码解析</h1><h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><p>默认是非公平锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="lock"><a href="#lock" class="headerlink" title="lock()"></a>lock()</h2><p>对于lock()方法，先是在ReentrantLock内部实现了自己的非公平以及公平的同步器，可以自定义tryAcquire()方法的实现，这是lock()方法获取锁的一个重要步骤，同时对于没有获取到锁的线程，我们需要有一个数据结构保存起来，让他们能够等待时机获取锁，这也就是同步队列。</p><p>重要的三个步骤：</p><ol><li>tryAcquire：每个新的线程都会尝试获取锁</li><li>addWaiter：获取锁成功可以执行自己的任务，获取锁失败把自己包装成节点加入同步队列（同步队列是有一个虚拟头节点的，用来唤醒下一个抢锁的线程）</li><li>acquireQueued：把刚刚加入同步队列内的线程阻塞</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>公平锁</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="公平锁tryAcquire"><a href="#公平锁tryAcquire" class="headerlink" title="公平锁tryAcquire()"></a><strong>公平锁</strong>tryAcquire()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="comment">// 当前资源没人占用才能尝试获取锁</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 先看看有没有前面的节点，如果没有其他节点再CAS尝试获取锁</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 可重入锁原理</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>非公平锁</strong></p><p>只不过多一个先CAS抢锁的判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非公平锁tryAcquire"><a href="#非公平锁tryAcquire" class="headerlink" title="非公平锁tryAcquire()"></a><strong>非公平锁</strong>tryAcquire()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="comment">// 当前资源没人占用才能尝试获取锁</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// CAS尝试获取锁</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 可重入锁原理</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="unlock"><a href="#unlock" class="headerlink" title="unlock()"></a>unlock()</h2><p>对于unlock()方法，实现比较简单，不存在考虑竞争等问题，只需要把自己的资源释放并且唤醒排队的第一个节点就行了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="await"><a href="#await" class="headerlink" title="await()"></a>await()</h2><p>对于await()方法，功能类似于synchronized的Object.wait()，不过synchronized只能用一个Object对象，而ReentrantLock可以有很多个Condition，await()是把持有锁的线程转移到条件队列，可以实现线程间的通信。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="comment">// 把线程包装成节点加入条件队列，设置waitstatus == CONDITION</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter();</span><br><span class="line">    <span class="comment">// 释放线程持有的锁</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node);</span><br><span class="line">    <span class="type">int</span> <span class="variable">interruptMode</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 判断线程是否在同步队列</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        <span class="comment">// 到这里说明当前线程在条件队列，可以阻塞</span></span><br><span class="line">        LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="literal">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="addConditionWaiter"><a href="#addConditionWaiter" class="headerlink" title="addConditionWaiter()"></a>addConditionWaiter()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">addConditionWaiter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> lastWaiter;</span><br><span class="line">    <span class="comment">// If lastWaiter is cancelled, clean out.</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="literal">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">        t = lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">null</span>)</span><br><span class="line">        firstWaiter = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t.nextWaiter = node;</span><br><span class="line">    lastWaiter = node;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="fullyRelease"><a href="#fullyRelease" class="headerlink" title="fullyRelease()"></a>fullyRelease()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">fullyRelease</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="comment">// 释放线程持有的锁，并唤醒后续节点</span></span><br><span class="line">        <span class="keyword">if</span> (release(savedState)) &#123;</span><br><span class="line">            failed = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> savedState;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            node.waitStatus = Node.CANCELLED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="signal"><a href="#signal" class="headerlink" title="signal()"></a>signal()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="type">Node</span> <span class="variable">first</span> <span class="operator">=</span> firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="literal">null</span>)</span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="doSignal"><a href="#doSignal" class="headerlink" title="doSignal()"></a>doSignal()</h3><p>用enq()方法把线程放到同步队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSignal</span><span class="params">(Node first)</span> &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="literal">null</span>)</span><br><span class="line">            lastWaiter = <span class="literal">null</span>;</span><br><span class="line">        first.nextWaiter = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">             (first = firstWaiter) != <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="transferForSignal"><a href="#transferForSignal" class="headerlink" title="transferForSignal()"></a>transferForSignal()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">transferForSignal</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If cannot change waitStatus, the node has been cancelled.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 把当前节点加入同步队列，返回前驱节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> enq(node);</span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> p.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="signalAll"><a href="#signalAll" class="headerlink" title="signalAll()"></a>signalAll()</h2><p>比signal()多一个循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signalAll</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="type">Node</span> <span class="variable">first</span> <span class="operator">=</span> firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="literal">null</span>)</span><br><span class="line">        doSignalAll(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="doSignalAll"><a href="#doSignalAll" class="headerlink" title="doSignalAll()"></a>doSignalAll()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSignalAll</span><span class="params">(Node first)</span> &#123;</span><br><span class="line">    lastWaiter = firstWaiter = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> first.nextWaiter;</span><br><span class="line">        first.nextWaiter = <span class="literal">null</span>;</span><br><span class="line">        transferForSignal(first);</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (first != <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>ReentrantLock是基于AQS实现的，有几个重要的属性：资源&#x2F;锁state、Node节点、同步队列的头尾节点head和tail，条件队列的头为节点headWaiter和tailWaiter，比较难以理解的就是lock()和await()，对于release()和signal()的理解会比较容易一些。</p><p>ReentrantLock和synchronized的结构很像，都由一个资源&#x2F;监视器、一个同步队列、一个条件队列组成，对于线程的控制方法在抽象上是大差不差的，只不过实际上实现有所区别。</p>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>简单了解跨域问题如何解决</title>
      <link href="/forworl.github.io/2024/03/15/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3/"/>
      <url>/forworl.github.io/2024/03/15/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="跨域问题是怎么产生的？"><a href="#跨域问题是怎么产生的？" class="headerlink" title="跨域问题是怎么产生的？"></a>跨域问题是怎么产生的？</h1><p>跨域就是违反了浏览器规定的一个同源策略，同源策略是为了保证不同页面之间不能用到对方的一下信息（如cookie，DOM对象）保证安全，同源策略主要是三个方面相同，用一个URL来举例的话，<a href="http://www.baidu.com,就是当前页面和请求地址的协议相同、端口相同、域名相同,后面的路径无所谓./">http://www.baidu.com，就是当前页面和请求地址的协议相同、端口相同、域名相同，后面的路径无所谓。</a></p><p>那么浏览器如何知道这个请求跨域了，首先请求会到服务器，然后服务器会响应一个响应头Access-Control-Allow-Origin，浏览器就知道是否违反了同源策略，那么只需要浏览器收到的响应的响应头Access-Control-Allow-Origin没有跨域问题就行了。</p><p>那么只需要</p><ul><li>浏览器发送一个不受同源策略限制的请求</li><li>不用浏览器发送请求，使用模拟代理服务器，每次浏览器都先请求本地的模拟代理服务器，就没有同源策略了</li><li>或者服务器返回响应头Access-Control-Allow-Origin是OK的（*）</li><li>使用反向代理的Nginx设置响应头</li></ul><h1 id="如何解决跨域问题"><a href="#如何解决跨域问题" class="headerlink" title="如何解决跨域问题"></a>如何解决跨域问题</h1><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><p><strong>Jsonp</strong>：可以把请求路径放在<script>标签里面，src、link这些属性是不受同源策略限制的</p><h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><p><strong>通过CORS解决跨域</strong>：首先自己写一个过滤器CORSFilter，把响应头的Access-Control-Allow等值都设置为某些字段就可以解决跨域问题</p><p><strong>通过Nginx反向代理</strong> ：同样的来修改添加响应头字段</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>简单了解CyclicBarrier</title>
      <link href="/forworl.github.io/2024/03/14/CyclicBarrier/"/>
      <url>/forworl.github.io/2024/03/14/CyclicBarrier/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是CyclicBarrier？"><a href="#什么是CyclicBarrier？" class="headerlink" title="什么是CyclicBarrier？"></a>什么是CyclicBarrier？</h1><p>CyclicBarrier是Java的一个同步类，用于协作多线程，同时也是一个共享锁</p><h1 id="CyclicBarrier的使用场景"><a href="#CyclicBarrier的使用场景" class="headerlink" title="CyclicBarrier的使用场景"></a>CyclicBarrier的使用场景</h1><h2 id="多线程一起开始"><a href="#多线程一起开始" class="headerlink" title="多线程一起开始"></a><strong>多线程一起开始</strong></h2><p>异步线程之间互相等待</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MyThread</span>(cyclicBarrier).start();</span><br><span class="line">    &#125;</span><br><span class="line">    System.in.read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    CyclicBarrier cyclicBarrier;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(CyclicBarrier cyclicBarrier)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取到锁</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span> + <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">3000</span>));</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;start&quot;</span>);</span><br><span class="line">            cyclicBarrier.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="CyclicBarrier源码解析"><a href="#CyclicBarrier源码解析" class="headerlink" title="CyclicBarrier源码解析"></a>CyclicBarrier源码解析</h1><h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CyclicBarrier</span><span class="params">(<span class="type">int</span> parties)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(parties, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CyclicBarrier</span><span class="params">(<span class="type">int</span> parties, Runnable barrierAction)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="built_in">this</span>.parties = parties;</span><br><span class="line">    <span class="built_in">this</span>.count = parties;</span><br><span class="line">    <span class="built_in">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每次计数都是一个新的Generation</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Generation</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">broken</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">trip</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 到达屏障需要的总线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> parties;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程数到达屏障的时候执行的方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable barrierCommand;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前的Generation</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">Generation</span> <span class="variable">generation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Generation</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 到达屏障还差多少线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> count;</span><br></pre></td></tr></table></figure><h2 id="await"><a href="#await" class="headerlink" title="await()"></a>await()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dowait(<span class="literal">false</span>, <span class="number">0L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(toe); <span class="comment">// cannot happen</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dowait"><a href="#dowait" class="headerlink" title="dowait()"></a>dowait()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dowait</span><span class="params">(<span class="type">boolean</span> timed, <span class="type">long</span> nanos)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span><br><span class="line">           TimeoutException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Generation</span> <span class="variable">g</span> <span class="operator">=</span> generation;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (g.broken)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BrokenBarrierException</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            breakBarrier();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> --count;</span><br><span class="line">        <span class="comment">// 当前线程数到达屏障</span></span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">ranAction</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Runnable</span> <span class="variable">command</span> <span class="operator">=</span> barrierCommand;</span><br><span class="line">                <span class="comment">// 执行方法</span></span><br><span class="line">                <span class="keyword">if</span> (command != <span class="literal">null</span>)</span><br><span class="line">                    command.run();</span><br><span class="line">                ranAction = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// 唤醒条件队列所有线程，并且更新屏障</span></span><br><span class="line">                nextGeneration();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 将当前屏障生成设置为已损坏并唤醒条件队列所有线程</span></span><br><span class="line">                <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                    breakBarrier();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环直到当前线程数到达屏障、线程被中断、超时</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// timed 表示是否采用超时机制</span></span><br><span class="line">                <span class="keyword">if</span> (!timed)</span><br><span class="line">                    <span class="comment">// 加入条件队列阻塞，同时会把占用的锁释放</span></span><br><span class="line">                    trip.await();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> ie;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// We&#x27;re about to finish waiting even if we had not</span></span><br><span class="line">                    <span class="comment">// been interrupted, so this interrupt is deemed to</span></span><br><span class="line">                    <span class="comment">// &quot;belong&quot; to subsequent execution.</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BrokenBarrierException</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g != generation)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TimeoutException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="nextGeneration-：开启下一轮循环，重置count，唤醒条件队列所有的线程"><a href="#nextGeneration-：开启下一轮循环，重置count，唤醒条件队列所有的线程" class="headerlink" title="nextGeneration()：开启下一轮循环，重置count，唤醒条件队列所有的线程"></a>nextGeneration()：开启下一轮循环，重置count，唤醒条件队列所有的线程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">nextGeneration</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// signal completion of last generation</span></span><br><span class="line">    trip.signalAll();</span><br><span class="line">    <span class="comment">// set up next generation</span></span><br><span class="line">    count = parties;</span><br><span class="line">    generation = <span class="keyword">new</span> <span class="title class_">Generation</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="breakBarrier-：设置当前循环为被打断状态，重置count，唤醒条件队列所有的线程"><a href="#breakBarrier-：设置当前循环为被打断状态，重置count，唤醒条件队列所有的线程" class="headerlink" title="breakBarrier()：设置当前循环为被打断状态，重置count，唤醒条件队列所有的线程"></a>breakBarrier()：设置当前循环为被打断状态，重置count，唤醒条件队列所有的线程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">breakBarrier</span><span class="params">()</span> &#123;</span><br><span class="line">    generation.broken = <span class="literal">true</span>;</span><br><span class="line">    count = parties;</span><br><span class="line">    trip.signalAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>简单了解Semaphore</title>
      <link href="/forworl.github.io/2024/03/14/Semaphore/"/>
      <url>/forworl.github.io/2024/03/14/Semaphore/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是Semaphore？"><a href="#什么是Semaphore？" class="headerlink" title="什么是Semaphore？"></a>什么是Semaphore？</h1><p>Semaphore是Java的一个同步类，用于协作多线程，同时也是一个共享锁</p><h1 id="Semaphore使用场景"><a href="#Semaphore使用场景" class="headerlink" title="Semaphore使用场景"></a>Semaphore使用场景</h1><h2 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 限制每次最多只有两个线程执行任务</span></span><br><span class="line">    <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MyThread</span>(semaphore).start();</span><br><span class="line">    &#125;</span><br><span class="line">    System.in.read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"></span><br><span class="line">    Semaphore semaphore;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(Semaphore semaphore)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.semaphore = semaphore;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 每个工作线程获取一个信号量</span></span><br><span class="line">            semaphore.acquire();</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            Thread.sleep(<span class="number">1000</span> + <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">1000</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 结束任务释放信号量</span></span><br><span class="line">            semaphore.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="独占锁"><a href="#独占锁" class="headerlink" title="独占锁"></a>独占锁</h2><p>其实就是把初始信号量改成1，用共享锁的模式实现独占锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MyThread</span>(semaphore).start();</span><br><span class="line">    &#125;</span><br><span class="line">    System.in.read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"></span><br><span class="line">    Semaphore semaphore;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(Semaphore semaphore)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.semaphore = semaphore;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取到锁</span></span><br><span class="line">            semaphore.acquire();</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            Thread.sleep(<span class="number">1000</span> + <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">1000</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            semaphore.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Semaphore源码解析"><a href="#Semaphore源码解析" class="headerlink" title="Semaphore源码解析"></a>Semaphore源码解析</h1><h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><p>默认的同步器是非公平的NonfairSync</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> <span class="keyword">permits</span>)</span> &#123;</span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>(<span class="keyword">permits</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> <span class="keyword">permits</span>, <span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>(<span class="keyword">permits</span>) : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>(<span class="keyword">permits</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="acquire"><a href="#acquire" class="headerlink" title="acquire()"></a>acquire()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="acquireSharedInterruptibly"><a href="#acquireSharedInterruptibly" class="headerlink" title="acquireSharedInterruptibly()"></a>acquireSharedInterruptibly()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="comment">// 尝试获取锁，判断为true，说明没有资源，这个节点需要阻塞</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="tryAcquireShared-：尝试获取锁"><a href="#tryAcquireShared-：尝试获取锁" class="headerlink" title="tryAcquireShared()：尝试获取锁"></a>tryAcquireShared()：尝试获取锁</h4><p><strong>公平锁</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 判断同步队列内有节点，说明本节点需要加入队列，返回-1</span></span><br><span class="line">        <span class="keyword">if</span> (hasQueuedPredecessors())</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">available</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="comment">// 这里acquire可以不是1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">remaining</span> <span class="operator">=</span> available - acquires;</span><br><span class="line">        <span class="comment">// 如果剩下的信号量 &lt; 0 或者获取锁成功，返回剩余的信号量</span></span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>非公平锁</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">nonfairTryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 来了就抢，不用判断同步队列内是否有节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">available</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="type">int</span> <span class="variable">remaining</span> <span class="operator">=</span> available - acquires;</span><br><span class="line">        <span class="comment">// 如果剩下的信号量 &lt; 0 或者获取锁成功，返回剩余的信号量</span></span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="doAcquireSharedInterruptibly-：把节点加入队列"><a href="#doAcquireSharedInterruptibly-：把节点加入队列" class="headerlink" title="doAcquireSharedInterruptibly()：把节点加入队列"></a>doAcquireSharedInterruptibly()：把节点加入队列</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 把节点加入队列，并且设置节点waitstate == SHARED</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 返回当前节点的前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="comment">// 如果当前节点的前驱节点是头节点</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="comment">// 尝试获取锁，返回值r的意思是剩余的信号量</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg);</span><br><span class="line">                <span class="comment">// 还有剩余的信号量，把当前节点设置为新的头节点</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 检查当前节点是否可以阻塞，如果前驱节点的waitstate == SIGNAL才会parkAndCheckInterrupt()阻塞</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                <span class="comment">// 阻塞当前节点的线程</span></span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 上述for循环内的步骤出现了异常，把当前节点移除出同步队列</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="release"><a href="#release" class="headerlink" title="release()"></a>release()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="releaseShared"><a href="#releaseShared" class="headerlink" title="releaseShared()"></a>releaseShared()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 尝试释放锁</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="tryReleaseShared-：尝试释放锁"><a href="#tryReleaseShared-：尝试释放锁" class="headerlink" title="tryReleaseShared()：尝试释放锁"></a>tryReleaseShared()：尝试释放锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> current + releases;</span><br><span class="line">        <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum permit count exceeded&quot;</span>);</span><br><span class="line">        <span class="comment">// CAS将信号量释放</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="doReleaseShared"><a href="#doReleaseShared" class="headerlink" title="doReleaseShared()"></a>doReleaseShared()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReleaseShared</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">// 队列不空</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> h.waitStatus;</span><br><span class="line">            <span class="comment">// 头节点的waitStatus == SIGNAL</span></span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="comment">// 设置头节点的waitStatus == 0</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                <span class="comment">// 设置成功才释放后继节点</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当头节点waitstatus == 0，并且设置头节点waitstatus == PROPAGATE也可以返回</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Semaphore在实现了类似于操作系统进程间通信的信号量，一开始有固定的信号量，acquire就是P操作（减少信号量），release就是V操作（返还信号量），只有获取到信号量（不论多少）才能够执行自己的任务。</p>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>简单理解什么是进程</title>
      <link href="/forworl.github.io/2024/03/14/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E7%A8%8B/"/>
      <url>/forworl.github.io/2024/03/14/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是进程？"><a href="#什么是进程？" class="headerlink" title="什么是进程？"></a>什么是进程？</h1><p>进程可以理解为一个正在<strong>运行的程序</strong>，它有一些比较重要的组成部分：</p><ul><li>内存：进程被创建的时候，指令会被加载在内存中、以及一些初始化的数据也会被加载到内存中</li><li>寄存器：存放着下一步指令在内存中的位置，以及一些特殊的寄存器比如栈指针、堆指针等等</li></ul><h1 id="进程创建的流程"><a href="#进程创建的流程" class="headerlink" title="进程创建的流程"></a>进程创建的流程</h1><p>其实就是来探究一些如何把磁盘中的程序指令转化成一个进程。</p><ol><li>把对应的代码和数据都加载到内存中</li><li>给堆（可能分配）、栈（main()函数的栈帧分配）等结构分配内存</li><li>初始化任务，如I&#x2F;O任务的一些文件描述符</li><li>执行main()</li></ol><h1 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h1><p>那对应的状态大致有5个：创建、就绪、运行、阻塞、结束</p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240314095357847.png" alt="image-20240314095357847"></p><p>对于操作系统如何知道哪些进程是什么状态才能更好的调度进程？</p><p>操作系统使用了进程列表的方式存储不同状态的进程。</p><h1 id="进程上下文切换"><a href="#进程上下文切换" class="headerlink" title="进程上下文切换"></a>进程上下文切换</h1><p>对于上下文切换，主要有CPU上下文切换、进程上下文切换、线程上下文切换这3种，大致的意思都差不多。</p><p>当进程的时间片用完或者是被阻塞需要放弃时间片又或者是被CPU调度等情况，就需要进行进程上下文切换，这里举例进程A转换到进程B，主要呢就是把进程A的寄存器信息保存到内核栈A中，系统调用完成以后，再将内核栈暂存的寄存器B信息恢复到进程的寄存器B中，实现一次换出再换入，接下来CPU就可以根据进程寄存器B内的值来执行B进程的指令了。</p><p>当进程A分到的时间片用完操作系统会产生一个时钟中断，运行预先配置的中断处理程序，操作系统查找陷阱表让进程A从用户态陷入到内核态（此时操作系统重新获得CPU的控制权，把进程A的寄存器保存到内核栈A中），操作系统会调用switch()调整内核栈指针指向内核栈B，然后把内核栈B的进程B的寄存器恢复，然后返回到用户态，此后调用的就是进程B了。</p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240315094634336.png" alt="image-20240315094634336"></p><h1 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h1><p>可以理解为结束状态的进程就是僵尸进程，僵尸进程是已经退出但是还没有被清理的进程。</p><p>它会占有一定的内存空间，但是它的返回值可被创建它的父进程知晓这个子进程是否成功执行任务。（返回0说明成功）</p><h1 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h1><p>我们如何衡量进程任务去调度进程，用到一个周转时间，主要服务于短作业。</p><p><strong>周转时间：完成时间 - 到达时间</strong></p><ul><li>先到先服务（FIFO）：顾名思义，按照到达时间排序来调度进程，但是会出现长作业导致后来的短作业饥饿问题</li><li>短作业优先（SJF）：顾名思义，短作业优先，但是可能导致长作业饥饿，或者是长作业调度期间，短作业才到达导致短作业饥饿问题</li><li>短完成时间优先（STCF）：针对长作业调度期间，短作业才到达导致短作业饥饿问题，有这个抢占式的SJF（SJF本身是非抢占式的），可以抢占长作业的CPU</li></ul><p>因为人类需要在电脑前等待反应，自然就需要提高等待的时间，也就出现了新的度量标准，响应时间，主要服务于长作业。</p><p><strong>响应时间：首次调用时间 - 到达时间</strong></p><ul><li>轮转（RR）：也就是时间分片，需要合理设置好分片的大小，摊销上下文切换的成本（保存和恢复寄存器、更换CPU缓存、TLB等状态），避免了长作业饥饿的问题，但是会损失一定的周转时间</li></ul><p><strong>兼顾周转时间和响应时间</strong></p><ul><li>多级反馈队列（MLFQ）：结合了短作业优先以及轮转的优点，每个任务都先当作短作业放到第一层队列，减少了周转时间；以及配合时间片，避免了长作业饥饿，减少了响应时间</li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>简单了解CountDownLatch</title>
      <link href="/forworl.github.io/2024/03/13/CountDownLatch/"/>
      <url>/forworl.github.io/2024/03/13/CountDownLatch/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是CountDownLatch？"><a href="#什么是CountDownLatch？" class="headerlink" title="什么是CountDownLatch？"></a>什么是CountDownLatch？</h1><p>CountDownLatch是Java的一个同步类，用于协作多线程，同时也是一个共享锁</p><h1 id="CountDownLatch使用场景"><a href="#CountDownLatch使用场景" class="headerlink" title="CountDownLatch使用场景"></a>CountDownLatch使用场景</h1><h2 id="等待所有线程完成任务"><a href="#等待所有线程完成任务" class="headerlink" title="等待所有线程完成任务"></a><strong>等待所有线程完成任务</strong></h2><p>主线程等异步线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MyThread</span>(countDownLatch).start();</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    System.out.println(<span class="string">&quot;3个线程都完成任务了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"></span><br><span class="line">    CountDownLatch countDownLatch;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(CountDownLatch countDownLatch)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.countDownLatch = countDownLatch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 每个线程任务时间不同</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span> + <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">1000</span>));</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多线程一起开始"><a href="#多线程一起开始" class="headerlink" title="多线程一起开始"></a><strong>多线程一起开始</strong></h2><p>异步线程等主线程的指令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MyThread</span>(countDownLatch).start();</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    countDownLatch.countDown();</span><br><span class="line">    System.out.println(<span class="string">&quot;3个线程一起开始&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"></span><br><span class="line">    CountDownLatch countDownLatch;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(CountDownLatch countDownLatch)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.countDownLatch = countDownLatch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 每个线程等待</span></span><br><span class="line">            countDownLatch.await();</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="CountDownLatch源码解析"><a href="#CountDownLatch源码解析" class="headerlink" title="CountDownLatch源码解析"></a>CountDownLatch源码解析</h1><p>很多子方法在AQS内部有类似或者一样的实现，如果你了解过AQS的源码，那么CountDownLatch对于你而言应该问题不大，只需要理解好自定义同步器的tryAcquireShared()的实现就行，主要意思就是state !&#x3D; 0的时候线程都会被包装成节点加入到同步队列。</p><h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><p>内部实现了自己的同步器，设置state的初值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CountDownLatch</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;count &lt; 0&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.sync = <span class="keyword">new</span> <span class="title class_">Sync</span>(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="await"><a href="#await" class="headerlink" title="await()"></a>await()</h2><p>让线程等待</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="acquireSharedInterruptibly"><a href="#acquireSharedInterruptibly" class="headerlink" title="acquireSharedInterruptibly()"></a>acquireSharedInterruptibly()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="comment">// 尝试获取共享锁</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="tryAcquireShared-：尝试获取共享锁"><a href="#tryAcquireShared-：尝试获取共享锁" class="headerlink" title="tryAcquireShared()：尝试获取共享锁"></a>tryAcquireShared()：尝试获取共享锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="comment">// 只要state不是0，都返回-1</span></span><br><span class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="doAcquireSharedInterruptibly-：让所有的线程都阻塞在同步队列"><a href="#doAcquireSharedInterruptibly-：让所有的线程都阻塞在同步队列" class="headerlink" title="doAcquireSharedInterruptibly()：让所有的线程都阻塞在同步队列"></a>doAcquireSharedInterruptibly()：让所有的线程都阻塞在同步队列</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 把节点加入同步队列，设置waitstatus == SHARED</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 死循环是为了shouldParkAfterFailedAcquire()返回false，说明是头节点的后继节点真正入队前，还会再次调用tryAcquireShared()尝试获取锁</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 返回节点的前驱节点，队列为空会抛异常</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="comment">// 前驱节点是头节点，尝试获取共享锁</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg);</span><br><span class="line">                <span class="comment">// 返回的结果&gt;=0，说明获取成功，实际上如果不调用countDown()返回的state都是&gt;0的，导致r一直是-1，无法获取锁，全部节点内的线程都会被阻塞</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 更改头节点为当前节点，并且释放后续的节点</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前节点的线程是否应该暂停，只有前驱节点的waitstatus == SIGNAL才会返回true，否则会再次循环尝试获取共享锁</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                <span class="comment">// shouldParkAfterFailedAcquire返回true，调用LockSupport.park(this)阻塞本节点的线程</span></span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// for循环内的某一步骤发生了异常，会把当前节点移除出同步队列</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="countDown"><a href="#countDown" class="headerlink" title="countDown()"></a>countDown()</h2><p>减少state的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">countDown</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="releaseShared"><a href="#releaseShared" class="headerlink" title="releaseShared()"></a>releaseShared()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 尝试释放共享锁</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="tryReleaseShared-：尝试释放共享锁"><a href="#tryReleaseShared-：尝试释放共享锁" class="headerlink" title="tryReleaseShared()：尝试释放共享锁"></a>tryReleaseShared()：尝试释放共享锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="doReleaseShared-：唤醒后继节点"><a href="#doReleaseShared-：唤醒后继节点" class="headerlink" title="doReleaseShared()：唤醒后继节点"></a>doReleaseShared()：唤醒后继节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReleaseShared</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 死循环，直到调用unparkSuccessor(h)唤醒后继节点、或者设置头节点waitstatus == PROPAGATE</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">// 队列不空</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> h.waitStatus;</span><br><span class="line">            <span class="comment">// 头节点的waitstatus == SIGNAL</span></span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="comment">// 设置头节点的waitstatus == 0</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                <span class="comment">// 设置成功就可以唤醒后继节点</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当头节点waitstatus == 0，并且设置头节点waitstatus == PROPAGATE也可以返回</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>countDownLatch有一个初始的state，只有当state &#x3D;&#x3D; 0，才会让阻塞在同步队列的节点被逐一释放，对于所有的节点，如果state !&#x3D; 0都无法获取锁，也就是说所有的节点从一开始都会被阻塞。</p>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>简单了解TCP/IP四层模型</title>
      <link href="/forworl.github.io/2024/03/10/TCP-IP%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B/"/>
      <url>/forworl.github.io/2024/03/10/TCP-IP%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是计算机网络？"><a href="#什么是计算机网络？" class="headerlink" title="什么是计算机网络？"></a>什么是计算机网络？</h1><p>计算机网络我们可以理解为一个巨大的城市地图，我们想从A地前往B地，其中要走的路、要避开的问题都交给计算机网络解决，直到我们可以正常的到达目的地，那么我们会把其中的过程抽象成一个网络模型，每层负责一个功能。</p><h1 id="TCP-x2F-IP四层模型图"><a href="#TCP-x2F-IP四层模型图" class="headerlink" title="TCP&#x2F;IP四层模型图"></a>TCP&#x2F;IP四层模型图</h1><p>对于传统的OSI七层网络模型，划分的精度太细，不利于实际使用，我们今天来看看TCP&#x2F;IP四层模型的具体组成：</p><ul><li>应用层：主要就是产生原始的数据包</li><li>传输层：让接收方知道数据包是给哪个进程的，并且可以选择提供可靠传输</li><li>网络层：数据包在不同局域网间传输，直到到达接收方</li><li>网络接口层：数据包在局域网内部传输，正确的到达中转站</li></ul><p>下层为上层提供服务，上层不需要管下层的具体实现，就比如说应用层只管产生数据，不用管数据是如何到达接收方进程的。</p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240310092752849.png" alt="image-20240310092752849"></p><h1 id="TCP-x2F-IP四层模型有什么好处呢？"><a href="#TCP-x2F-IP四层模型有什么好处呢？" class="headerlink" title="TCP&#x2F;IP四层模型有什么好处呢？"></a>TCP&#x2F;IP四层模型有什么好处呢？</h1><p>那分层可以理解为拆分，对于拆分到好处我们可以想到将某个方法内部的代码再次封装成一个个的更加小的子方法，那么容易想到：</p><ul><li>每个层级的职责会更加的清晰，只负责本层所负责的问题</li><li>降低了整体的耦合度，如果我们需要修改某一个层级的实现，不会影响到其它的层级</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>简单了解什么是AQS</title>
      <link href="/forworl.github.io/2024/03/08/%E4%BB%80%E4%B9%88%E6%98%AFAQS/"/>
      <url>/forworl.github.io/2024/03/08/%E4%BB%80%E4%B9%88%E6%98%AFAQS/</url>
      
        <content type="html"><![CDATA[<p>本文基于JDK8</p><h1 id="什么是AQS？"><a href="#什么是AQS？" class="headerlink" title="什么是AQS？"></a>什么是AQS？</h1><p>AQS（AbstractQueuedSynchronizer）抽象队列同步器，一个用来<strong>构建锁和同步工具类的框架</strong>，比如构建ReentrantLock、ReentrantReadWriteLock这样的锁或是CountDownLatch、CyclicBarrier、Semaphore这样的同步工具类，底层呢是在锁内部或者同步工具类内部<strong>自定义同步器Sync</strong>，让Sync实现AQS的一些方法完成对资源state的控制效果，从而实现同步。</p><p><strong>AQS有两种模式</strong></p><ul><li>独占：只有一个线程可以获取到资源</li><li>共享：很多线程都可以获取到资源</li></ul><p><strong>独占和共享是对于资源来说的，即一个资源能否被多个线程所占有，而公平和非公平是对于线程来说的，即一个新的线程是否需要排队才能获取资源。</strong></p><p><strong>AQS的几个重要的成员变量</strong>：</p><ul><li>Node：同步队列的节点<ul><li>head、tail：用来维护一个虚拟的双向链表（同步队列，在线程尝试获取资源失败后，会进入同步队列队尾，给前继节点设置一个唤醒信号后，自身进入等待状态（通过<code>LockSupport.park(this)</code>），直到被前继节点唤醒）</li><li>state：用来表示资源的情况</li><li>waitStatus：当前节点的状态</li><li>nextWaiter：当前资源是独占还是共享</li></ul></li><li>ConditionObject：条件队列的节点<ul><li>firstWaiter、lastWaiter：用来维护一个虚拟的双向链表（条件队列）</li></ul></li></ul><p><strong>每个节点的状态waitStatus</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">SHARED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">EXCLUSIVE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 说明当前节点发生异常</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span>  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 说明当前节点是清醒的，后续节点需要依赖本节点唤醒</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span>    <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 说明当前节点在条件队列中</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 暂时理解为共享模式下的传播唤醒</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>;</span><br></pre></td></tr></table></figure><p><strong>独占模式下对state的获取</strong></p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240308202115837.png" alt="image-20240308202115837"></p><p>你会看到AQS大量使用了CAS操作来保证并发安全，例如修改state的值或者说是将新节点尾插到队列等。</p><h1 id="基础同步器"><a href="#基础同步器" class="headerlink" title="基础同步器"></a>基础同步器</h1><p>那么接下来看看AQS两种模式下如何实现加锁和解锁的，本文锁和资源的意思相同。</p><ul><li><code>acquire(int)</code>：<strong>独占模式</strong>下获取资源</li><li><code>release(int)</code>：<strong>独占模式</strong>下释放资源</li><li><code>acquireShared(int)</code>：<strong>共享模式</strong>下获取资源</li><li><code>releaseShared(int)</code>：<strong>共享模式</strong>下释放资源</li></ul><h2 id="acquire"><a href="#acquire" class="headerlink" title="acquire"></a>acquire</h2><p><strong>尝试获取锁，获取锁失败加入同步队列，看看要不要阻塞（等待前节点唤醒）</strong></p><p>对于ReentrantLock，不论是公平锁或者非公平锁，底层都是AQS的acquire()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 尝试加锁</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        <span class="comment">// 获取锁失败，把当前线程加入同步队列</span></span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tryAcquire：尝试获取锁"><a href="#tryAcquire：尝试获取锁" class="headerlink" title="tryAcquire：尝试获取锁"></a><strong>tryAcquire：尝试获取锁</strong></h3><p>模板方法，交给子类的同步器实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ReentrantLock实现如下</p><p>公平锁：返回true说明加锁成功，否则说明加锁失败</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取当前state的值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="comment">// 如果c == 0，说明当前没人占有锁</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果队列没有节点，说明没人在排队等待获取资源，则通过CAS尝试修改state，如果修改成功则设置当前线程为资源占有者</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果当前锁已经被占有并且为自己占有的话，则增加state，这也是可重入锁的原理</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加锁失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非公平锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取当前state的值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="comment">// 如果c == 0，说明当前没人占有锁</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 通过CAS尝试修改state，如果修改成功则设置当前线程为资源占有者</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果当前锁已经被占有并且为自己占有的话，则增加state，这也是可重入锁的原理</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回false表示获取锁失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="hasQueuedPredecessors：判断同步队列有没有节点"><a href="#hasQueuedPredecessors：判断同步队列有没有节点" class="headerlink" title="hasQueuedPredecessors：判断同步队列有没有节点"></a>hasQueuedPredecessors：判断同步队列有没有节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">hasQueuedPredecessors</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; </span><br><span class="line">    <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="comment">// 什么时候返回true：至少有一个节点，并且头节点的下一个节点不是当前线程</span></span><br><span class="line">    <span class="comment">// 什么时候返回false：队列没有节点，head == tail == null</span></span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">        ((s = h.next) == <span class="literal">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="addWaiter：前面tryAcquire获取锁失败把当前线程加入同步队列，并设置为独占模式（Node-EXCLUSIVE）"><a href="#addWaiter：前面tryAcquire获取锁失败把当前线程加入同步队列，并设置为独占模式（Node-EXCLUSIVE）" class="headerlink" title="addWaiter：前面tryAcquire获取锁失败把当前线程加入同步队列，并设置为独占模式（Node.EXCLUSIVE）"></a><strong>addWaiter：前面tryAcquire获取锁失败把当前线程加入同步队列，并设置为独占模式（Node.EXCLUSIVE）</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">    <span class="comment">// 先包装当前线程到一个新节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// 先尝试一遍把当前节点加入同步队列</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="comment">// 如果同步队列不为空，使用尾插法插入</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">// 通过CAS把当前节点设置为尾节点，CAS是为了并发安全</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 尝试第二次把当前节点加入同步队列（里面是一个死循环，多线程可能导致添加失败会自旋直到添加成功）</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="enq：将节点加入同步队列"><a href="#enq：将节点加入同步队列" class="headerlink" title="enq：将节点加入同步队列"></a>enq：将节点加入同步队列</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">    <span class="comment">// 死循环直到加入成功</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="comment">// 队列为空，进行初始化，先创建一个头节点</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 尾插法</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="acquireQueued：真正入队（节点会被阻塞），入队之前如果是头节点的后继节点会再次尝试获取锁，addWaiter只不过是创建了一个节点结构放入队列"><a href="#acquireQueued：真正入队（节点会被阻塞），入队之前如果是头节点的后继节点会再次尝试获取锁，addWaiter只不过是创建了一个节点结构放入队列" class="headerlink" title="acquireQueued：真正入队（节点会被阻塞），入队之前如果是头节点的后继节点会再次尝试获取锁，addWaiter只不过是创建了一个节点结构放入队列"></a><strong>acquireQueued：真正入队（节点会被阻塞），入队之前如果是头节点的后继节点会再次尝试获取锁，addWaiter只不过是创建了一个节点结构放入队列</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 表示当前线程是否被打断</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// p是当前线程的前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="comment">// p是头节点的话尝试获取锁</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取锁失败，检查是否可以park并且调用LockSupport.park()阻塞当前线程</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 如果出现异常，取消正在等待的节点操作，并且找到一个有效的前边节点指向有效的后边节点</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="shouldParkAfterFailedAcquire：获取锁失败或者前驱节点不是头节点，判断是否应该在同步队列阻塞，返回true说明可以阻塞，否则需要再次尝试获取锁"><a href="#shouldParkAfterFailedAcquire：获取锁失败或者前驱节点不是头节点，判断是否应该在同步队列阻塞，返回true说明可以阻塞，否则需要再次尝试获取锁" class="headerlink" title="shouldParkAfterFailedAcquire：获取锁失败或者前驱节点不是头节点，判断是否应该在同步队列阻塞，返回true说明可以阻塞，否则需要再次尝试获取锁"></a>shouldParkAfterFailedAcquire：获取锁失败或者前驱节点不是头节点，判断是否应该在同步队列阻塞，返回true说明可以阻塞，否则需要再次尝试获取锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> pred.waitStatus;</span><br><span class="line">    <span class="comment">// 前面的节点是SIGNAL状态，当前节点可以阻塞</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 前面节点是CANCEL状态，要遍历找到一个SIGNAL的前节点</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 把前节点设置为SIGNAL状态，一般在节点加入同步队列后会到这里，因为需要前驱节点唤醒</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回false，在调用者方法再次尝试获取资源</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="parkAndCheckInterrupt：调用LockSupport-park阻塞当前节点"><a href="#parkAndCheckInterrupt：调用LockSupport-park阻塞当前节点" class="headerlink" title="parkAndCheckInterrupt：调用LockSupport.park阻塞当前节点"></a>parkAndCheckInterrupt：调用LockSupport.park阻塞当前节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="cancelAcquire：遇到异常时要把当前节点移除出队列，同时维护队列节点的状态"><a href="#cancelAcquire：遇到异常时要把当前节点移除出队列，同时维护队列节点的状态" class="headerlink" title="cancelAcquire：遇到异常时要把当前节点移除出队列，同时维护队列节点的状态"></a>cancelAcquire：遇到异常时要把当前节点移除出队列，同时维护队列节点的状态</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">cancelAcquire</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">// Ignore if node doesn&#x27;t exist</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    node.thread = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往前遍历找到状态为SIGNAL的前节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> node.prev;</span><br><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前节点的下一个节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">predNext</span> <span class="operator">=</span> pred.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置当前节点状态为CANCELLED</span></span><br><span class="line">    node.waitStatus = Node.CANCELLED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果我们是队尾节点，CAS移除自己</span></span><br><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">        compareAndSetNext(pred, predNext, <span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> ws;</span><br><span class="line">        <span class="comment">// 前节点不是头节点并且状态为SIGNAL</span></span><br><span class="line">        <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">            ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">             (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">            pred.thread != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 将前节点的后继节点设置为当前节点的下一个节点</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> node.next;</span><br><span class="line">            <span class="keyword">if</span> (next != <span class="literal">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                compareAndSetNext(pred, predNext, next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 前节点为head节点,帮忙唤醒当前节点的后继节点</span></span><br><span class="line">            unparkSuccessor(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node.next = node; <span class="comment">// help GC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="release"><a href="#release" class="headerlink" title="release"></a>release</h2><p>对于ReentrantLock，不论是公平锁或者非公平锁，底层都是AQS的release()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 尝试释放资源</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">// h的状态是SIGNAL</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 唤醒头节点的下一个节点</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tryRelease：尝试释放锁"><a href="#tryRelease：尝试释放锁" class="headerlink" title="tryRelease：尝试释放锁"></a>tryRelease：尝试释放锁</h3><p>模板方法，交给子类的同步器实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ReentrantLock实现如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="comment">// 剩余的资源量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">    <span class="comment">// 防止其它线程释放资源占有者线程的锁</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// c == 0 才说明当前线程要释放资源，因为有可重入锁机制</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 资源释放成功</span></span><br><span class="line">        free = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 设置当前资源没有人占领</span></span><br><span class="line">        setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置state</span></span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="unparkSuccessor：唤醒下一个有效节点"><a href="#unparkSuccessor：唤醒下一个有效节点" class="headerlink" title="unparkSuccessor：唤醒下一个有效节点"></a>unparkSuccessor：唤醒下一个有效节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">// 当前节点状态</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;</span><br><span class="line">    <span class="comment">// 将节点状态SIGNAL转化为0</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前线程的下一个节点是空的或者CANCELLED状态，则从后往前找有效的下一个节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 从后往前找有效的下一个节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用LockSupport.unpark唤醒下一个有效的节点</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="literal">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="acquireShared"><a href="#acquireShared" class="headerlink" title="acquireShared"></a>acquireShared</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="comment">// 尝试加锁</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tryAcquireShared：尝试加锁"><a href="#tryAcquireShared：尝试加锁" class="headerlink" title="tryAcquireShared：尝试加锁"></a>tryAcquireShared：尝试加锁</h3><p>模板方法，交给子类的同步器实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回值：</p><ul><li>正数：成功获取资源，并且还有剩余可用资源，可以唤醒下一个等待线程；</li><li>负数：获取资源失败，准备进入同步队列；</li><li>0：获取资源成功，但没有剩余可用资源。</li></ul><h3 id="doAcquireSharedInterruptibly：线程判断自己如果是头节点的下一个节点，尝试获取锁，并且根据需要唤醒之后的节点"><a href="#doAcquireSharedInterruptibly：线程判断自己如果是头节点的下一个节点，尝试获取锁，并且根据需要唤醒之后的节点" class="headerlink" title="doAcquireSharedInterruptibly：线程判断自己如果是头节点的下一个节点，尝试获取锁，并且根据需要唤醒之后的节点"></a>doAcquireSharedInterruptibly：线程判断自己如果是头节点的下一个节点，尝试获取锁，并且根据需要唤醒之后的节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 将当前节点加入同步队列末尾</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="comment">// 如果当前节点的前驱节点是头节点</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="comment">// 尝试获取锁</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg);</span><br><span class="line">                <span class="comment">// r &gt;= 0 表示还有资源，需要唤醒后续其它的节点</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 唤醒后续其它的节点</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取锁失败，检查是否可以park并且调用LockSupport.park()阻塞当前线程</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 如果获取锁失败，取消正在等待的节点操作，并且找到一个有效的前边节点指向有效的后边节点</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="setHeadAndPropagate：唤醒后续的节点"><a href="#setHeadAndPropagate：唤醒后续的节点" class="headerlink" title="setHeadAndPropagate：唤醒后续的节点"></a>setHeadAndPropagate：唤醒后续的节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setHeadAndPropagate</span><span class="params">(Node node, <span class="type">int</span> propagate)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head; <span class="comment">// Record old head for check below</span></span><br><span class="line">    <span class="comment">// 更新头节点</span></span><br><span class="line">    setHead(node);</span><br><span class="line">    <span class="comment">// 有剩余资源，或者当前节点有唤醒信号</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        (h = head) == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="releaseShared"><a href="#releaseShared" class="headerlink" title="releaseShared"></a>releaseShared</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 尝试释放当前节点占有的资源</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        <span class="comment">// 继续释放后续节点的资源</span></span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tryReleaseShared：尝试释放锁，只有state-x3D-x3D-0才返回true"><a href="#tryReleaseShared：尝试释放锁，只有state-x3D-x3D-0才返回true" class="headerlink" title="tryReleaseShared：尝试释放锁，只有state &#x3D;&#x3D; 0才返回true"></a>tryReleaseShared：尝试释放锁，只有state &#x3D;&#x3D; 0才返回true</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="doReleaseShared：继续释放后续节点的资源"><a href="#doReleaseShared：继续释放后续节点的资源" class="headerlink" title="doReleaseShared：继续释放后续节点的资源"></a>doReleaseShared：继续释放后续节点的资源</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReleaseShared</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 自旋,防止操作时有新的节点加入导致CAS失败</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                <span class="comment">// 节点设置为0之后，唤醒之后的节点</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// waitStatus为0，说明是从setHeadAndPropagate过来的操作，CAS修改为PROPAGATE</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="条件同步器"><a href="#条件同步器" class="headerlink" title="条件同步器"></a>条件同步器</h1><h2 id="await：尝试获取锁"><a href="#await：尝试获取锁" class="headerlink" title="await：尝试获取锁"></a>await：尝试获取锁</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="comment">// 将当前线程加入到条件队列</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter();</span><br><span class="line">    <span class="comment">// 释放同步队列的锁，lock.lock()的锁</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node);</span><br><span class="line">    <span class="type">int</span> <span class="variable">interruptMode</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 当前节点是否在同步队列中</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        <span class="comment">// 当前线程不在同步队列，调用LockSupport.park()阻塞</span></span><br><span class="line">        LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 到这里说明节点被signal()唤醒，需要从条件队列移动到同步队列中</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="comment">// 解除条件队列中已经取消的等待节点的链接</span></span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="literal">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="isOnSyncQueue："><a href="#isOnSyncQueue：" class="headerlink" title="isOnSyncQueue："></a>isOnSyncQueue：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isOnSyncQueue</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">// 当前节点是CONDITION状态或者没有前驱节点，说明不在同步队列中</span></span><br><span class="line">    <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 如果有后继节点，一定在同步队列</span></span><br><span class="line">    <span class="keyword">if</span> (node.next != <span class="literal">null</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 从同步队列最后往前遍历看看是否有当前节点</span></span><br><span class="line">    <span class="keyword">return</span> findNodeFromTail(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="signal：尝试唤醒其他节点"><a href="#signal：尝试唤醒其他节点" class="headerlink" title="signal：尝试唤醒其他节点"></a>signal：尝试唤醒其他节点</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 判断当前线程是否已经持有锁</span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="type">Node</span> <span class="variable">first</span> <span class="operator">=</span> firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="literal">null</span>)</span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="doSignal-："><a href="#doSignal-：" class="headerlink" title="doSignal()："></a>doSignal()：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSignal</span><span class="params">(Node first)</span> &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 更新头节点</span></span><br><span class="line">        <span class="keyword">if</span> ((firstWaiter = first.nextWaiter) == <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">// 没有节点了</span></span><br><span class="line">            lastWaiter = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 解除头节点的连接</span></span><br><span class="line">        first.nextWaiter = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// transferForSignal将头节点转移到同步队列</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">             (first = firstWaiter) != <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="transferForSignal："><a href="#transferForSignal：" class="headerlink" title="transferForSignal："></a>transferForSignal：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">transferForSignal</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If cannot change waitStatus, the node has been cancelled.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前线程加入同步队列，返回节点的前驱节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> enq(node);</span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> p.waitStatus;</span><br><span class="line">    <span class="comment">// 如果前驱节点是CANCELED状态或者设置前继节点的状态失败，调用LockSupport.unpark直接唤醒当前节点</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>简单了解什么是CAS</title>
      <link href="/forworl.github.io/2024/03/08/CAS/"/>
      <url>/forworl.github.io/2024/03/08/CAS/</url>
      
        <content type="html"><![CDATA[<p>本文基于JDK8</p><h1 id="什么是CAS？"><a href="#什么是CAS？" class="headerlink" title="什么是CAS？"></a>什么是CAS？</h1><p>CAS（compare and swap），比较与交换，CAS实际上是操作系统底层提供的一个原子指令，对于CAS来说有三个值，V（需要修改的内存的地址）、A（预期初始的值）、B（预期修改后的值），简单来说就是当V位置的数据为A时，我们尝试把它修改为B。当多个线程同时进行修改的时候，只有一个线程可以成功，其它线程都会失败，对于失败的线程区别于锁不会挂起而是会继续尝试修改。</p><h1 id="那么CAS在JDK里面的应用呢？"><a href="#那么CAS在JDK里面的应用呢？" class="headerlink" title="那么CAS在JDK里面的应用呢？"></a>那么CAS在JDK里面的应用呢？</h1><p>像我们熟悉的原子类的一些方法就是和CAS相关</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">weakCompareAndSet</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">    <span class="comment">// valueOffset == V、expect == A、update == B</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="什么是Unsafe类？"><a href="#什么是Unsafe类？" class="headerlink" title="什么是Unsafe类？"></a>什么是Unsafe类？</h1><p>Unsafe类有着类似于C语言指针一样可以<strong>操作内存</strong>的效果，但是如果不正确的使用Unsafe类可能导致程序出错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unsafe类是单例实现的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe theUnsafe;</span><br></pre></td></tr></table></figure><p><strong>有两种方式可以获得Unsafe类：</strong></p><p>1.把调用Unsafe相关方法的类A所在jar包路径追加到默认的bootstrap路径中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xbootclasspath/a: $&#123;path&#125;   // 其中path为调用Unsafe相关方法的类所在jar包路径 </span><br></pre></td></tr></table></figure><p>2.反射</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">field.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">return</span> (Unsafe) field.get(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p><strong>那Unsafe类和CAS的关系是什么呢？</strong></p><p>AtomicInteger类的一个静态变量valueOffset表示字段value的内存偏移地址，配合AtomicInteger对象的基地址就可以得到CAS的三个基本数中的V</p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240308193852686.png" alt="image-20240308193852686"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> valueOffset;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        valueOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(ex); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mini-spring学习记录</title>
      <link href="/forworl.github.io/2024/03/08/mini-spring%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
      <url>/forworl.github.io/2024/03/08/mini-spring%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="3-8基本的IoC内部构造"><a href="#3-8基本的IoC内部构造" class="headerlink" title="3.8基本的IoC内部构造"></a>3.8基本的IoC内部构造</h1><p>IoC容器本质上其实是一个Map&lt;beanName, bean&gt;</p><p>BeanDefinition：bean的定义信息（包含bean的class类型、构造参数、属性值等信息），我们需要用到BeanDefinition来进行bean的实例化</p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240308171123736.png" alt="image-20240308171123736"></p><p>DefaultListableBeanFactory：常用的一个BeanFactory，本质是一个BeanDefinition的一个注册中心，有一个Map&lt;beanName, beanDefinition&gt;</p><p>DefaultSingletonBeanRegistry：单例bean对象的一个缓存池，有三个map，我们一般称为三级缓存</p><p>AbstractAutowireCapableBeanFactory：执行bean的生命周期（实例化、初始化等）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一级缓存</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二级缓存</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 三级缓存</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure><p>策略模式：</p><p>实例化用到了策略模式，抽象策略类InstantiationStrategy，子类实现比如无参构造实例化bean、Cglib代理实例化bean</p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240308172335401.png" alt="image-20240308172335401"></p><h1 id="3-9属性注入"><a href="#3-9属性注入" class="headerlink" title="3.9属性注入"></a>3.9属性注入</h1><p>PropertyValues：k-v结构，存储bean的字段以及对应的值</p><p>BeanReference：表示bean某个字段的值是一个引用类型（xml文件的ref或者@Autowire、在属性赋值的时候会特殊判断先加载这个引用的bean）</p><h1 id="3-10读取xml文件"><a href="#3-10读取xml文件" class="headerlink" title="3.10读取xml文件"></a>3.10读取xml文件</h1><p>ResourceLoader：把资源（一般是文件，如bean的xml文件）加载到容器中</p><p>Resource：资源，我们通过资源获取其InputStream，再把InputStream转成Document操作dom树读取xml标签，共有三种资源：</p><ul><li>ClassPathResource：类路径（clasthpath）下的文件</li><li>FileSystemResource：某个路径下的文件</li><li>UrlResource：某个网址的资源</li></ul><p><img src="C:\Users\fuleyou\AppData\Roaming\Typora\typora-user-images\image-20240310161725365.png" alt="image-20240310161725365"></p><h1 id="3-11PostProcessor拓展"><a href="#3-11PostProcessor拓展" class="headerlink" title="3.11PostProcessor拓展"></a>3.11PostProcessor拓展</h1><p>BeanFactoryPostProcessor：实例化前修改BeanDefinition</p><p>BeanPostProcessor：初始化前后修改Bean</p><h1 id="3-14ApplicationContext和初始化、销毁方法"><a href="#3-14ApplicationContext和初始化、销毁方法" class="headerlink" title="3.14ApplicationContext和初始化、销毁方法"></a>3.14ApplicationContext和初始化、销毁方法</h1><p>ApplicationContext：也是一个IoC容器，有着比BeanFactory更加丰富的功能（自动识别BeanFactoryPostProcessor、BeanPostProcessor，自动装配xml文件里面的bean、监听器、国际化等），适合我们开发者使用，有两个重要的实现类，以及一个重要方法refresh()：</p><ul><li>ClassPathXmlApplicationContext：从xml加载bean</li><li>AnnotationConfigApplicationContext：从注解中加载bean</li></ul><p>初始化、销毁方法：</p><ul><li>在xml文件中制定init-method和destroy-method</li><li>继承自InitializingBean和DisposableBean</li><li>在方法上加注解PostConstruct和PreDestroy（未做）</li></ul><p>初始化方法在初始化过程的invokeInitMethods()执行，并且初始化方法还会注册销毁方法、注册一个钩子函数registerShutdownHook()在虚拟机进程关闭之前执行销毁方法</p><h1 id="3-15Aware接口"><a href="#3-15Aware接口" class="headerlink" title="3.15Aware接口"></a>3.15Aware接口</h1><p>Aware接口：常用的有 ApplicationContextAware 、BeanFactoryAware</p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240315153626768.png" alt="image-20240315153626768"></p><p>prototype：不是单例的bean，主要就是在doCreateBean()的时候没有加入到一级缓存。</p><p>FactoryBean：较为复杂的bean，在createBean()结束之后，可以更改返回自定义的factoryBean。</p><p>监听器：在事件发布者ApplicationEventMulticaster注册所有的监听器ApplicationListener，当发布事件的时候publishEvent，会循环遍历所有的监听器，取得监听器的泛型的类和事件类对比，监听器处理感兴趣的事件。</p><h1 id="3-17切点表达式、JDK动态代理和Cglib动态代理"><a href="#3-17切点表达式、JDK动态代理和Cglib动态代理" class="headerlink" title="3.17切点表达式、JDK动态代理和Cglib动态代理"></a>3.17切点表达式、JDK动态代理和Cglib动态代理</h1><p>切点表达式：类匹配或者是类匹配同时方法匹配</p><p>JDK动态代理：基于接口，通过Proxy生成代理类，在MethodInterceptor执行invoke()，实现增强</p><p>Cglib动态代理：不基于接口，基于字节码，通过Enhancer生成代理类，在MethodInterceptor执行invoke()，实现增强</p><p>method和methodProxy的区别是methodProxy不会使用反射，直接生成了字节码</p><h1 id="3-18动态代理融入bean生命周期"><a href="#3-18动态代理融入bean生命周期" class="headerlink" title="3.18动态代理融入bean生命周期"></a>3.18动态代理融入bean生命周期</h1><p>doCreateBean()之前先判断是否需要代理对象</p><h1 id="3-20替换配置文件的"><a href="#3-20替换配置文件的" class="headerlink" title="3.20替换配置文件的${}"></a>3.20替换配置文件的${}</h1><p>PropertyPlaceholderConfigurer：一个BeanFactoryPostProcessor，在bean实例化之前修改BeanDefinition，通过加载properties文件的k-v值，来替代有${}的BeanDefinition里的某一个PropertyValue的value值。</p><p>ClassPathBeanDefinitionScanner：完成componentScan包扫描，扫描包里面的用了@Component注解的bean，并把他们加入到注册表DefaultListableFactory的BeanDefinitionMap</p><h1 id="3-21-Value和-Autowired"><a href="#3-21-Value和-Autowired" class="headerlink" title="3.21@Value和@Autowired"></a>3.21@Value和@Autowired</h1><p>在bean实例化之后，初始化之前，调用BeanPostProcessor对bean进行修改，通过反射获取字段上的注解，@Value就获取配置文件的值，@Autowired就通过beanType来getBean()。</p><p>AOP移动到初始化之后的BeanPostProcessor处理</p><p>类型转换：</p><p>三种类型转换器接口：Converter、ConverterFactory、GenericConverter。可以自定义转换器实现以上接口实现自定义的转换</p><ul><li>Converter&lt;S,T&gt;接口适合一对一的类型转换</li><li>ConverterFactory&lt;S, R&gt;接口则适合一对多的类型转换<ul><li>GenericConverter接口适合所有类型转换</li></ul></li></ul><p>ConversionService是类型转换体系的核心接口，将以上三种类型转换器整合到一起。GenericConverterService有点类似于DefaultListableBeanFactory也是个注册表，只不过ConversionService保存的是转换器</p><h1 id="3-22循环依赖"><a href="#3-22循环依赖" class="headerlink" title="3.22循环依赖"></a>3.22循环依赖</h1><p>二级缓存解决没有代理bean的循环依赖：把实例化后的bean加入二级缓存earlySingletonObjects，这样就可以在属性注入之前拿到不完整的bean，避免再次属性注入，从而避免了循环依赖。</p><p>三级缓存解决有代理bean的循环依赖：把生成代理bean的时间提前到实例化之后生成代理bean，多加了一级缓存，可以存放代理bean。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="IoC总结"><a href="#IoC总结" class="headerlink" title="IoC总结"></a>IoC总结</h2><p>什么是IoC（Inversion of Control），也就是<strong>控制反转</strong>，把bean的控制权交给了BeanFactory管理，而不是由程序员管理，程序员想使用某个bean，从BeanFactory调用getBean()获取就可以。</p><p>和IoC经常有个词会放在一起，DI（Dependency Injection），也就是<strong>依赖注入</strong>，也可以理解为bean的属性注入，发生在bean的生命周期中的实例化之后、初始化之前。</p><p>对于IoC来说有几个比较重要的类或者接口：</p><p><strong>BeanDefinition</strong>：bean定义信息（包括类信息beanClass、属性信息propertyValues、作用域scope、等等），我们需要根据BeanDefinition来完成bean的创建。&#x2F;&#x2F; TODO：BeanDefinition在真正的Spring中还有许多子类等待探究，这里只是简单的使用了BeanDefinition</p><p><strong>Resource</strong>：资源总接口，包括ClassPathResource、URLResource、FileResource</p><p><strong>BeanDefinitionReader</strong>：读取BeanDefinition的总接口，需要ResourceLoader以及BeanDefinitionRegistry两个属性，通过ResourceLoader读取xml文件（操作Document接口、DOM文件树），把BeanDefinition保存到BeanDefinitionRegistry</p><p>接下来介绍一些常见的BeanFactory，&#x2F;&#x2F; TODO：以下的图并不完整，和真正的Spring还有较大的差别</p><p><strong>DefaultListableBeanFactory⭐</strong>：底层Spring项目启动的时候默认的BeanFactory，继承了一些重要的类或者实现了一些重要的接口，如AbstractAutowireCapableBeanFactory，用以自动装配完成bean的生命周期、或者是BeanDefinitionRegistry，用以保存BeanDefinition、或者是DefaultSingletonBeanRegistry，用以保存单例bean或是解决循环依赖问题、等等</p><p><strong>ClassPathXmlApplicationContext</strong>或者是<strong>AnnotationConfigApplicationContext</strong>：拥有BeanFactory基本的功能，并且还有一些拓展功能，如继承了DefaultResourceLoader用来读取BeanDefinition、实现了ApplicationEventPublisher，用以设置监听器监听事件、以及一些国际化的操作（未实现），最重要的是<strong>ApplicationContext实现了自动装配功能</strong>，不论是使用xml或者是注解，在refresh()方法中完成了创建BeanFactory、使用BeanFactoryPostProcessor、注册BeanPostProcessor、设置监听器、提前实例化不是懒加载的bean（bean的生命周期）等等</p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240322090615961.png" alt="image-20240322090615961" style="zoom:150%;" /><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240322094026291.png" alt="image-20240322094026291" style="zoom:150%;" /><p>接下来具体来说说bean的生命周期，也就是IoC是如何管理bean的，包括实例化、属性注入、初始化、使用、销毁。</p><p>bean的生命周期主要发生在AbstractAutowireCapableBeanFactory类的doCreateBean()方法，Spring的命名特点在于真正做事情函数都会加上do前缀，接下来我们就来看看这个doCreateBean()发生了什么：</p><ol><li><strong>实例化</strong>：根据策略选择实现方式，默认是无参构造实现、也可以使用CGLIB动态生成</li><li><strong>BeanPostProcessor修改bean属性值</strong>：里面是@Value以及@Autowired的解析实现，其实也就是通过反射看看每个字段上面有没有相关注解，如果有的话，@Value就是加载配置文件的k-v然后配合去除${}完成属性注入，@Autowired就是通过getBean()来获取对应的引用属性</li><li><strong>设置属性</strong>：从BeanDefinition获取bean信息，通过反射填充字段值，如果是BeanReference说明是引用类型，需要先执行引用字段的生命周期</li><li><strong>BeanPostProcessor前置处理</strong>：如一些Aware接口的回调函数的实现</li><li><strong>初始化</strong>：先执行InitializingBean接口方法，反射执行自己的init-method方法</li><li><strong>BeanPostProcessor后置处理</strong>：实现AOP织入，返回代理对象</li><li><strong>注册销毁方法</strong>：</li><li><strong>把创建好的bean加入一级缓存</strong>：</li></ol><h2 id="AOP总结"><a href="#AOP总结" class="headerlink" title="AOP总结"></a>AOP总结</h2><p>什么是AOP（Aspect Oriented Programming），也就是<strong>面向切面编程</strong>，把相同的代码抽出来，利用动态代理对已有方法进行增强。</p><p>对于AOP有几个重要的类或接口：</p><p><strong>Advisor</strong>：切面，结合了 切点 和 通知，常用的实现类AspectJExpressionPointcutAdvisor</p><p><strong>Pointcut</strong>：切点抽象接口，包括 Expression（切点表达式）、 ClassFilter（类匹配器）和 MethodMatcher（方法匹配器）</p><p><strong>Advice</strong>：增强器（也叫做通知），执行增强方法，常用实现类是各种MethodInterceptor</p><p><strong>AdvisedSupport</strong>：存放拦截器、源对象、代理方式等信息</p><p><strong>MethodInvocation</strong>：执行原方法，以及反射调用拦截器增强方法，多次调用 MethodInvocation对象.proceed()，完成链式调用</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>单例模式</p><p>原型模式</p><p>策略模式</p><p>工厂模式</p><p>适配器模式</p><p>代理模式</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>简单了解什么是反射</title>
      <link href="/forworl.github.io/2024/03/08/%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84/"/>
      <url>/forworl.github.io/2024/03/08/%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是反射？"><a href="#什么是反射？" class="headerlink" title="什么是反射？"></a>什么是反射？</h1><p>反射是一种能在运行期分析类以及操作Class对象的机制。这里有两个名词待我们了解：</p><p><strong>一个是运行期是什么？</strong></p><p>在Java项目启动的过程中，程序需要经历两个阶段，首先是编译期（编译器会把.java文件编译成.class文件，然后类加载器会把.class文件加载到内存中）、然后是<strong>解释运行期（JVM会把内存中的.class文件翻译成机器语言交给操作系统执行）</strong></p><p><strong>一个是分析类是什么？</strong></p><p>对于一个类来说，它的元结构信息（构造器、属性、方法等）会被存储在方法区内，同时在堆内存中有一个Class对象与之对应。<strong>我们可以通过操作Class对象方式在运行期获取一个类的元结构信息，也可以通过操作Class对象方式获取或者修改类实例化对象的属性、调用其方法或者构造器</strong>，同时可以根据需要动态加载一些编译期未知的类（<strong>当程序启动，有main方法的类会被加载</strong>，同时相关的类会被递归加载，我们可以通过反射延迟加载类，加快程序的启动速度）</p><h1 id="反射的优缺点？"><a href="#反射的优缺点？" class="headerlink" title="反射的优缺点？"></a>反射的优缺点？</h1><p><strong>优点：</strong></p><p>可以在运行期获取类信息，无需提前知道类，有助于一些框架通用性的实现</p><p><strong>缺点：</strong></p><p>反射无法被JIT优化导致操作对象效率较低</p><p>破坏了封装特性，可能有安全问题</p><h1 id="哪里用到了反射？"><a href="#哪里用到了反射？" class="headerlink" title="哪里用到了反射？"></a>哪里用到了反射？</h1><p>1.JDBC驱动就是用反射加载的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">&#x27;com.mysql.jdbc.Driver&#x27;</span>);</span><br></pre></td></tr></table></figure><p>2.Spring框架的一些内部实现，比如实例化对象期间的默认无参构造器创建对象、初始化对象期间的属性注入等</p><p>3.动态代理反射调用代理对象的方法，并对方法增强</p><h1 id="怎么获取Class对象？"><a href="#怎么获取Class对象？" class="headerlink" title="怎么获取Class对象？"></a>怎么获取Class对象？</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象.getClass</span></span><br><span class="line">obj.getClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类.class</span></span><br><span class="line">Object.class;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类.forName(&quot;全类名&quot;)</span></span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.driver&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ClassLoader.loadClass(&quot;全类名&quot;)</span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">classloader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassLoader</span>();</span><br><span class="line">classloader.loadClass(<span class="string">&quot;xxx&quot;</span>);</span><br></pre></td></tr></table></figure><h1 id="如何获取到类元结构信息？"><a href="#如何获取到类元结构信息？" class="headerlink" title="如何获取到类元结构信息？"></a>如何获取到类元结构信息？</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Object.class;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有访问权限的方法信息</span></span><br><span class="line">Method[] methods = clazz.getDeclaredMethods();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有访问权限的属性信息</span></span><br><span class="line">Field[] field = clazz.getDeclaredFields();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有访问权限的构造器</span></span><br><span class="line">Constructor&lt;?&gt;[] Constructors = clazz.getDeclaredConstructors();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有注解</span></span><br><span class="line">Annotation[] annotations = clazz.getAnnotations();</span><br></pre></td></tr></table></figure><h1 id="如何使用Class对象获取和修改实例化对象？"><a href="#如何使用Class对象获取和修改实例化对象？" class="headerlink" title="如何使用Class对象获取和修改实例化对象？"></a>如何使用Class对象获取和修改实例化对象？</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取属性</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> clazz.getField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化对象</span></span><br><span class="line">Constructor&lt;?&gt; constructor = clazz.getConstructor();</span><br><span class="line"><span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> constructor.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方法</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">f1</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;f1&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">invoke</span> <span class="operator">=</span> f1.invoke(instance);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java SE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>简单了解volatile如何解决可见性</title>
      <link href="/forworl.github.io/2024/03/03/volatile%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%8F%AF%E8%A7%81%E6%80%A7/"/>
      <url>/forworl.github.io/2024/03/03/volatile%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%8F%AF%E8%A7%81%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>volatile是Java的一个关键字，是轻量级的synchronized，用于修饰变量，解决了变量没有可见性和有序性的问题，那什么是变量的可见性和有序性？首先我们先要研究操作系统层面的CPU的缓存一致性问题（对应可见性）和指令优化重排问题（对应有序性），JMM把这些问题封装成了一些关键字（如volatile、synchronized）或者API，我们直接调用就可以解决掉这些问题。</p><h1 id="CPU的缓存和主存之间的数据一致性问题"><a href="#CPU的缓存和主存之间的数据一致性问题" class="headerlink" title="CPU的缓存和主存之间的数据一致性问题"></a>CPU的缓存和主存之间的数据一致性问题</h1><p>首先要谈谈操作系统层面的可见性，也就是CPU和主存之间的缓存一致性的问题，CPU访问数据有局部性，使用缓存可以加快CPU读写数据的速度，但是同时可能造成CPU的缓存和主存之间的数据一致性问题</p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240303214839007.png" alt="image-20240303214839007"></p><p>CPU缓存和主存之间的缓存一致性问题主要有以下原因造成：</p><ul><li><strong>CPU之间无法同步</strong>：当某个CPU修改了主存的数据之后，其它的CPU是不知道的，还是用的是自己内部过期的缓存</li><li><strong>并发问题</strong>：当两个或者更多的CPU需要同时读写主存的时候，没有控制并发的机制存在，可能造成读写顺序反过来，导致读取到旧值</li></ul><h1 id="基于总线解决CPU缓存一致性"><a href="#基于总线解决CPU缓存一致性" class="headerlink" title="基于总线解决CPU缓存一致性"></a>基于总线解决CPU缓存一致性</h1><p>只需要在CPU和主存之间加上一条总线，通过总线就可以通知到其它CPU自己对主存数据的改动，CPU想要和主存交互来读写数据必须要经过总线，获取到总线的控制权（加总线锁）之后才能和主存进行交互。</p><h2 id="总线嗅探"><a href="#总线嗅探" class="headerlink" title="总线嗅探"></a>总线嗅探</h2><p>针对上文的第一个问题，我们需要研究如何让其它的CPU知道自己对于某个共享数据的修改呢？可以想到我们可以<strong>通过总线对其它CPU进行通知</strong>，在自己修改了某个共享数据之后，将新的缓存数据同步到主存的同时，通知其它的CPU该数据已经被修改，那么其他的CPU就会把这个数据缓存行设置为无效状态，下次想要读取或者修改数据之前，都需要先到主存获取到最新的数据再进行自己的操作。</p><p><strong>总线风暴</strong></p><p>当很多线程都共享同一个变量，并且变量被volatile修饰或者用到了CAS修改变量的值，总线上会产生<strong>大量的通信</strong>来通知相应的CPU将相应的缓存行置为无效状态，这就是总线风暴。</p><h2 id="总线仲裁"><a href="#总线仲裁" class="headerlink" title="总线仲裁"></a>总线仲裁</h2><p>针对上文的第二个问题，我们需要研究如何两个及以上的CPU共同修改缓存数据的时候不产生并发问题呢？当然简单的办法就是对这个共享资源上锁，当一个CPU对共享资源上锁之后，其它的CPU只能等待锁释放才能访问共享资源，自然不存在并发问题，<strong>总线仲裁就是以一定的优先算法仲裁哪个应获得对总线的使用权</strong>（那个CPU能上锁成功）。</p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240303215406322.png" alt="image-20240303215406322"></p><h2 id="如何优化总线的使用"><a href="#如何优化总线的使用" class="headerlink" title="如何优化总线的使用"></a>如何优化总线的使用</h2><p>总线性能瓶颈在于基于在总线与主存打交道会造成阻塞，那么反过来想如果不通过总线与内存发生数据交互就可以避免总线加锁：</p><ul><li><strong>先考虑从其它缓存读取而不是从主存读取</strong>：当自己的缓存行数据没有或者无效，我们向总线发起读事务，某个CPU监听到我们的需求，会把它的最新数据放到总线（既然有数据，一定是最新的，因为其它的CPU的缓存行会被总线嗅探通知为无效状态），然后我们把新的缓存行数据拷贝到自己的缓存行</li><li><strong>当其它CPU请求数据才把自己的最新数据同步到主存</strong>：有点类似于懒加载机制，当别的CPU不需要访问这个数据的时候，CPU和主存的数据不一致也没有问题，当别的CPU需要访问这个数据，也是通过前面一小点的方式将数据缓存行同步给其它的CPU，同时将最新数据同步到主存</li></ul><p>总结：读事件优先在其它缓存读，除非其他缓存都没有最新数据；写事件只有在其它CPU也需要这个数据的时候才去获取总线锁把最新数据同步到主存</p><h1 id="MESI协议"><a href="#MESI协议" class="headerlink" title="MESI协议"></a>MESI协议</h1><p>CPU之间没办法直接通信，所以它们之间就必须商定一套机制，<strong>如何通过自己的数据状态就能知道其他CPU的缓存情况</strong>，<strong>从而做出对应的策略，而这套机制就是缓存一致性协议，MESI协议很好的优化了CPU和主存交互效率低的问题</strong>。</p><p>E（独占）：这个数据只有自己的缓存行有</p><p>S（共享）：先考虑从其它缓存读取而不是从主存读取，这个时候就会把自己的缓存行同步到其它</p><p>M（修改）：这个状态表示还有其它CPU有旧的缓存行，我们需要通过总线通信告知其它CPU设置缓存行无效状态</p><p>I（无效）：这时自己需要从其它缓存或者主存获取到最新的数据</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>CPU和主存缓存一致性的解决方案是加个总线</strong>：</p><ul><li>通过总线可以在CPU间通过通信同步缓存状态；</li><li>并且通过总线锁限制和主存的交互，避免并发问题。</li></ul><p>相应的<strong>总线锁也会带来一些效率低</strong>的问题，我们需要尽量少的使用总线，那么需要有一个<strong>MESI协议</strong>辅助，通过自己的数据状态就能知道其他CPU的缓存情况<strong>，</strong>从而做出对应的策略：</p><ul><li>先通过独占或者共享状态的缓存同步自己的缓存状态，否则才需要通过总线锁和主存交互；</li><li>只有在别的CPU需要数据的时候才把自己的修改状态的缓存通过总线锁同步到主存。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>简单了解Redis底层数据结构</title>
      <link href="/forworl.github.io/2024/03/03/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/forworl.github.io/2024/03/03/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>Redis有很多数据类型，这些数据类型对应着很多的数据结构，那么Redis底层是如何存储的呢？</p><p>可以看到默认有两个字典（可以理解为两个HashMap），平时只用一个字典进行数据的存储，另一个字典是在rehash的时候会使用到，那么对于数组的每个位置都存储着一个k-v结构，也就是说平时我们set这些操作都是把数据放到数组里面，那每个key和每个value都被当作一个对象存储，也就是图中的 key 对象和 value 对象，这些对象也就是redisObject，有三个属性：</p><ul><li>type：表明当前key或者value是什么数据类型</li><li>encoding：表明当前数据类型使用了哪种数据结构存储数据（一个数据类型在内存中可以用不同的数据结构存储，这也是Redis高效的原因之一）</li><li>ptr：指向底层的数据结构</li></ul><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240303162345077.png" alt="image-20240303162345077"></p><table><thead><tr><th>数据类型</th><th>底层数据结构</th></tr></thead><tbody><tr><td>String</td><td>SDS</td></tr><tr><td>List</td><td>双向链表、压缩列表</td></tr><tr><td>Hash</td><td>哈希表、压缩列表</td></tr><tr><td>Set</td><td>整数集合、哈希表</td></tr><tr><td>zSet</td><td>跳表、压缩列表</td></tr></tbody></table><h1 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h1><ul><li>通过len可以O(1)获取字符串长度</li><li>通过alloc可以预测是否有空间分配给新修改的value，防止缓冲区溢出，以及动态分配字节给新的字符串</li><li>flags对于小字符串的存储可以用不同的SDS类型减少SDS头部的字节数</li><li>buf [] 以\0 结尾，兼容了部分C语言的函数</li></ul><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240303163421894.png" alt="image-20240303163421894"></p><h1 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h1><ul><li>head和tail可以O(1)获取头尾指针</li><li>通过len可以O(1)获取链表长度</li></ul><p>缺点：</p><ul><li>地址不连续，无法很好的利用CPU缓存</li><li>头部字段空间开销大</li></ul><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240303164244282.png" alt="image-20240303164244282"></p><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p>和HashMap很像，数据如何存储、如何解决哈希冲突、哈希函数的实现</p><p>重点来看看rehash，对于传统的rehash，涉及到大量的数据拷贝，会阻塞Redis，影响到其它的请求，Redis采用了一种<strong>渐进式rehash</strong>的办法，不再一次性拷贝所有数据，而是根据每次的读写请求到的那部分数据，在完成请求的同时同步进行数据拷贝，每次只拷贝少量的数据，避免了Redis长时间阻塞</p><p>那什么时候会进行rehash，自然就是哈希冲突比较严重的时候，判断依据就是负载因子，当负载因子超过1就要考虑rehash了<br>$$<br>负载因子 &#x3D; 总节点数 &#x2F; 数组大小<br>$$<br><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240303164901887.png" alt="image-20240303164901887"></p><h1 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h1><ul><li>zlbytes：占有多少字节数</li><li>zltail：开头到结尾的字节数</li><li>zllen：总节点个数</li><li><strong>entry</strong>：<ul><li><strong>prevlen</strong>：前一个节点的字节数<ul><li>如果<strong>前一个节点的长度小于 254 字节</strong>，那么 prevlen 属性需要用 <strong>1 字节的空间</strong>来保存这个长度值；</li><li>如果<strong>前一个节点的长度大于等于 254 字节</strong>，那么 prevlen 属性需要用 <strong>5 字节的空间</strong>来保存这个长度值；</li></ul></li><li>encoding：当前节点的类型和长度，类型主要有两种：字符串和整数</li><li>data：实际数据</li></ul></li><li>zlend：表示压缩列表的结尾</li></ul><p><strong>连锁更新问题</strong>：对于某个节点来说，如果它的前一个节点发生变化，它的prevlen可能需要改变，如果说prevlen增加可能导致后一个节点的prevlen增加，就像多米诺骨牌一样，一直往后的节点都发生prevlen的变化</p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240303170548459.png" alt="image-20240303170548459"></p><h1 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h1><p>从高层查找，高层的节点个数少（因为增高一层，需要随机数p &lt; 0.25），效率自然是logn，根据score和元素字典序对比，逐级向下找就能知道的目标</p><p><strong>为什么用跳表而不用平衡树？</strong></p><ol><li><strong>范围查找更加简单</strong>：跳表直接在最底下那一层往后遍历，而平衡树需要有序并且使用中序遍历</li><li><strong>内存占用平均更小</strong>：很大概率跳表的指针数 &lt; 平衡树的指针数，由于随机数的概率问题</li><li><strong>跳表维护成本低</strong>：增删节点只需要修改指向前后的指针，而平衡树可能需要调整子树来维持平衡</li></ol><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240303171859340.png" alt="image-20240303171859340"></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>为什么Redis日志持久化的COW机制不用子线程而是用子进程呢</title>
      <link href="/forworl.github.io/2024/03/03/%E4%B8%BA%E4%BB%80%E4%B9%88Redis%E6%97%A5%E5%BF%97%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84COW%E6%9C%BA%E5%88%B6%E4%B8%8D%E7%94%A8%E5%AD%90%E7%BA%BF%E7%A8%8B%E8%80%8C%E6%98%AF%E7%94%A8%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%91%A2/"/>
      <url>/forworl.github.io/2024/03/03/%E4%B8%BA%E4%BB%80%E4%B9%88Redis%E6%97%A5%E5%BF%97%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84COW%E6%9C%BA%E5%88%B6%E4%B8%8D%E7%94%A8%E5%AD%90%E7%BA%BF%E7%A8%8B%E8%80%8C%E6%98%AF%E7%94%A8%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%91%A2/</url>
      
        <content type="html"><![CDATA[<p>今日的话题主要集中在异步持久化保存日志，如使用 bgsave 保存RDB，或者是 bgrewriteaof 保存AOF。</p><p>使用这两个命令的时候，父进程会阻塞，调用fork()创建出一个子进程来完成异步的持久化，照理来说创建一个子线程的开销不是比创建一个子进程的开销更加的小吗，毕竟子线程共享父进程的一些资源（内存、文件描述符等），就不涉及复制一份页表之类的活了。</p><p>确实如此，但是如果父进程需要修改这份共享内存，异步子线程和修改子线程之间就会发生冲突，对于线程间的并发问题，我们通常使用锁机制来保证线程安全问题，这势必就会影响到持久化的效率；</p><p>那如果我们考虑使用子进程呢，虽然说在创建子进程的时候的开销会比创建子线程的开销略大，但是子进程和父进程对应的那个共享内存是只读的，当父进程需要修改这个共享内存的时候，就会使用COW（本质上是CPU的<strong>写保护中断</strong>，操作系统就会在中断处理函数里面进行物理内存的复制以及更改页表），这个时候主线程会被阻塞，先来拷贝一份冲突的数据到新的物理地址，修改子进程的页表，指向这个新的物理地址，这样父进程修改原来的物理地址的数据就和子进程复制新的物理地址的旧数据不会冲突了，如果有大量的冲突发生，那么加锁和COW的效率自然是COW的效率会更高。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>简单了解什么是I/O多路复用</title>
      <link href="/forworl.github.io/2024/03/03/%E4%BB%80%E4%B9%88%E6%98%AFIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
      <url>/forworl.github.io/2024/03/03/%E4%BB%80%E4%B9%88%E6%98%AFIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>进程在不同的主机间通信无论是使用TCP还是UDP，都需要用到socket，以TCP为例，服务端会调用socket()函数创建一个网络协议为IPv4，传输协议为TCP的socket，接下来给socket绑定IP地址和端口，绑定端口是为了可以找到相应的进程，绑定IP是为了知道是哪个网卡接收到的数据包，每个网卡都有一个IP地址，接下来会调用listen()监听端口，调用accept()等待客户端连接到来，accept获取到一个已连接的socket，就可以进行客户端和服务端之间的进程通信了。</p><p><strong>多进程方式</strong></p><p>对于每个accept()获取的已连接的socket，父进程都会fork()一个子进程，子进程会共享父进程的文件描述符、内存等数据，但是进程的创建和销毁的代价较大，并且一个进程会占用较多的系统资源，系统承受不了太大的并发量。</p><p><strong>多线程方式</strong></p><p>对于每个accept()获取的已连接的socket，父进程调用函数创建子线程，把文件描述符等资源传递给子线程，虽然线程的创建和销毁的代价比进程略小，因为线程只独享栈、程序计数器等私有资源，会共享进程的一些内存、文件等资源，但是系统也承受不了太大的并发量。</p><p><strong>I&#x2F;O多路复用方式</strong></p><p>那有没有什么办法可以用单进程&#x2F;单线程的方式管理多个已连接的客户端socket呢？答案就是I&#x2F;O多路复用，I&#x2F;O多路复用这种思想类似进程的并发，给每个事件都分配一定的时间，我们可以通过系统调用，把所有socket传入内核，再由内核返回有事件发生的socket交给我们处理，一般有3种方式：</p><p><strong>select&#x2F;poll</strong></p><p><strong>让内核查询有事件发生的「已连接 Socket 」</strong></p><ul><li>将已连接的 socket 都放到一个<strong>文件描述符集合</strong></li><li>将这个集合拷贝到内核态，遍历这个集合，标记可读&#x2F;可写的socket</li><li>将这个集合再拷贝回用户态，再次遍历这个集合，找到可读&#x2F;可写的socket</li></ul><p>select是用固定长度的数组存放文件描述符集合，默认最大值是1024</p><p>poll采用的是链表，受系统描述符的限制</p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240118110119789.png" alt="image-20240118110119789" style="zoom: 50%;" /><p><strong>epoll</strong></p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20231202144621662.png" alt="image-20231202144621662"></p><p>不用2次内核态和用户态之间的拷贝socket集合，因为内核维护了一个红黑树，每次只需要传入1个socket就行</p><p>同时利用事件驱动机制，当某个socket有事件发生时，通过函数回调加入到内核维护的一个链表中，不用遍历整个socket集合</p><p><strong>内部维护了一颗红黑树保存socket文件描述符，以及一个链表保存有事件的socket</strong></p><ul><li>一开始我们会调用epoll_create在内核中创建一个epoll对象</li><li>当调用了epoll_ctl，那么就会把这个socket连接放到内核的这颗红黑树</li><li>当调用了epoll_wait，那么就会把有事件的socket链表中，返回有事件的那些socket，拷贝到用户态</li></ul><h4 id="边缘触发和水平触发"><a href="#边缘触发和水平触发" class="headerlink" title="边缘触发和水平触发"></a>边缘触发和水平触发</h4><ul><li><p>边缘触发：<strong>服务器端只会从 epoll_wait 中苏醒一次</strong>，即使进程没有调用 read 函数从内核读取数据，也依然只苏醒一次</p></li><li><p>水平触发：被监控的 Socket 上有可读事件发生时，<strong>服务器端不断地从 epoll_wait 中苏醒，直到内核缓冲区数据被 read 函数读完才结束</strong></p></li></ul><p>一般来说，边缘触发的效率比水平触发的效率要高，<strong>因为边缘触发可以减少 epoll_wait 的系统调用次数</strong>，系统调用也是有一定的开销的的，毕竟也存在上下文的切换</p><p><strong>select&#x2F;poll 只有水平触发模式，epoll 默认的触发模式是水平触发</strong>，但是可以根据应用场景设置为边缘触发模式</p><p><strong>使用 I&#x2F;O 多路复用时，最好搭配非阻塞 I&#x2F;O 一起使用</strong>：当内核缓冲区没有数据可读取的时候，如果是阻塞I&#x2F;O，程序进程会被阻塞，如果是非阻塞式I&#x2F;O，那么系统调用会返回错误停止I&#x2F;O</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>简单了解什么是零拷贝</title>
      <link href="/forworl.github.io/2024/03/03/%E4%BB%80%E4%B9%88%E6%98%AF%E9%9B%B6%E6%8B%B7%E8%B4%9D/"/>
      <url>/forworl.github.io/2024/03/03/%E4%BB%80%E4%B9%88%E6%98%AF%E9%9B%B6%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<p>在讨论零拷贝之前，我们需要了解传统传输文件的问题才能更好的理解零拷贝。</p><p><strong>传统的文件传输</strong>需要经过以下几步：</p><ol><li>read()系统调用陷入内核态</li><li>CPU拷贝磁盘缓冲区的数据到Page Cache</li><li>CPU拷贝Page Cache的数据到用户态</li><li>write()系统调用陷入内核态</li><li>CPU拷贝用户态的数据到Socket缓冲区</li><li>CPU拷贝Socket缓冲区的数据到网卡</li></ol><p>总共是2次系统调用以及4次CPU拷贝。</p><p>这里CPU会被频繁的中断，所以引入了<strong>DMA拷贝技术</strong>，代替CPU在Page Cache和磁盘缓冲区之间的数据拷贝，减少了2次CPU的数据拷贝，但是还是存在2次系统调用以及2次CPU拷贝。</p><p>这时零拷贝技术就会派上用场，零拷贝技术主要是为了<strong>减少CPU拷贝次数</strong>而存在的，那零拷贝技术有两种实现方式：</p><ul><li>mmap() + write() ，也就是用mmap()代替了read()：这里会把Page Cache和用户缓冲区共享内存，CPU直接把数据拷贝到Socket缓冲区就好了，减少了1次CPU拷贝。</li><li>sendfile()：这时是真正意义上的CPU 0次拷贝，数据拷贝和用户态没有关系，数据从Page Cache会直接被SG-DMA管理器拷贝到网卡，同时从Page Cache发送一些描述符和数据长度。</li></ul><p>虽然零拷贝技术很大程度改善了传统文件传输的效率，但是<strong>对于大文件的传输，我们不适合使用零拷贝技术</strong>，大致有以下原因：</p><ul><li>传统文件传输是阻塞I&#x2F;O，进程会被阻塞，对于大文件，阻塞进程会降低系统的吞吐量，对于大文件我们应该使用异步I&#x2F;O</li><li>大文件传输会频繁的更新Page Cache，会导致其它进程的读取文件的缓存失效，降低其它进程的效率，对于大文件我们应该直接把文件从磁盘缓冲区拷贝到用户态，再从用户态拷贝到Socket缓冲区再到网卡发送</li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>简单了解对象实例化过程</title>
      <link href="/forworl.github.io/2024/03/02/%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B/"/>
      <url>/forworl.github.io/2024/03/02/%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>开始我们知道对象的创建过程包括以下几步：</p><ol><li>类加载</li><li>实例化</li><li>初始化</li><li>引用赋值</li></ol><p>这几步一般来讲是顺序进行的，不过由于硬件层面的一些优化，可能会发生指令重排的情况，导致3、4步调换位置，我们在程序中就会看到NPE空指针异常，通常可以用volatile修饰这个变量来解决，不过我们今天主要谈谈这个实例化过程，也就是给对象分配内存的过程。</p><p>在Java程序，我们绝大多数的对象都在堆内分配内存，只有少部分的对象经过JIT的逃逸分析之后会在栈上分配内存，那对于大多数对象来说，具体是在堆内的什么位置分配内存呢，我们需要首先来看看堆内更加详细的图</p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240302222528855.png" alt="image-20240302222528855"></p><p>堆内的对象会被分代存储，一个是新生代（包括Eden、From、To）和一个老年代，他们的内存大小比例默认是新生代：老年代 &#x3D; 2：1，在新生代内部，Eden：From：To的大小比例默认是8：1：1。</p><p>新对象一般会在Eden进行分配，除了一些大对象（数组、字符串）直接进入到老年代，这样可以减少GC后对这些大对象的移动（因为新生代使用的是标记-整理算法），在分配对象内存的时候我们需要考虑<strong>Eden还有哪些空闲的区域</strong>，这里JVM针对不同的垃圾回收器用了两种办法：</p><ul><li>指针碰撞：适合没有内存碎片的垃圾回收器</li><li>空闲链表：适合有内存碎片的垃圾回收器，如CMS</li></ul><p>同时考虑到分配对象内存的时候会有<strong>并发问题</strong>，JVM有两种机制来避免并发问题：</p><ul><li>一个是TLAB（这个是JVM给线程分配的一块私有的空间，大概是Eden的1%），在TLAB内分配对象是没有并发问题的</li><li>另一个是CAS + 失败重试，利用操作系统的原子指令给对象分配内存</li></ul><p>那如果发现<strong>Eden已经没有足够大小的内存</strong>来分配给对象怎么解决？</p><p>大致来说就是先考虑Young GC，如果是JVM判断Young GC是有风险的，那么需要用对象担保机制，最后的办法就是Full GC，如果是Full GC后依旧不够内存分配给新对象，JVM会抛出OOM异常</p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240415095811035.png" alt="image-20240415095811035"></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>简单了解事务和日志和锁的关系</title>
      <link href="/forworl.github.io/2024/03/02/%E4%BA%8B%E5%8A%A1%E5%92%8C%E6%97%A5%E5%BF%97%E5%92%8C%E9%94%81%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
      <url>/forworl.github.io/2024/03/02/%E4%BA%8B%E5%8A%A1%E5%92%8C%E6%97%A5%E5%BF%97%E5%92%8C%E9%94%81%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<p>先来说说什么是事务，<strong>事务是数据库并发控制的基本单位</strong>，事务内有一系列的逻辑操作，需要一起成功或者一起失败，<strong>让数据库从一个一致性状态转换到另一个一致性状态</strong>，事务和日志和锁的关系在于事务的特性需要依靠这些机制来保证。</p><p>我们可以先看看事务的四大特性：</p><ul><li><strong>原子性</strong>（使用undo log）：<strong>一个事务中的所有操作都是不可分割的</strong>，要么全部完成，要么全部失败</li><li><strong>隔离性</strong>（锁 or MVCC）：防止多个事务间并行操作时，其它事务对本事务操作数据的影响</li><li><strong>持久性</strong>（使用redo log）：事务提交后，<strong>数据被保存在磁盘中</strong>，<strong>数据不会丢失</strong></li><li><strong>一致性</strong>（所追求）：<strong>结果符合约束</strong>，比如有钱才能转账、转账双方加起来银行账户的钱总和总是不变</li></ul><p>先来说说<strong>原子性</strong>，我们知道<strong>活跃的事务一般有两种结果，失败回滚或者成功提交</strong>，对于失败回滚，我们会用到<strong>undo log</strong>，对于事务内的每次逻辑操作（也就是一条SQL语句），会把未修改前的快照行数据保存到undo log页，这也就形成了undo log版本链（本质上是每个行记录的隐藏字段roll_pointer指针指向了undo log页内的先前的快照行记录）。</p><p><strong>当发生错误需要事务回滚的时候，我们根据undo log页保存的旧数据来进行事务的回滚</strong>，保证了事物的原子性，如何保证回滚哪些记录呢，这就还要依靠行记录的另一个隐藏字段trx_id也即是事务id，只回滚undo log版本链中的本事务id的行记录。</p><p>再来谈谈<strong>持久性</strong>吧，在原子性那里说过事务可能会失败回滚，这里我们来谈谈成功提交的情况，当事务成功提交，我们需要把这些<strong>更改的行记录都保存到redo log，避免丢失</strong>.</p><p>当然在事务的途中，对行记录的修改也会被记录到redo log，redo log会根据设定的持久化策略进行刷盘，这里使用redo log有两个原因，写redo log的速度更快（因为数据量更小，只需要记录哪一页的哪个偏移量位置发生了什么变动，无需记录整条行记录），并且redo log刷盘是顺序I&#x2F;O循环写，效率更高，后期再慢慢把脏的数据页刷盘就好了。</p><p>当数据库宕机后，由于redo log刷盘了，对于已经提交的事务，可以根据redo log进行数据的恢复，对于未提交的事务，可以根据redo log配合undo log（undo log也会被redo log记录进行持久化）进行数据的恢复（本质上还是利用了undo log进行数据恢复），保证了事务的持久性。</p><p>最后来看看<strong>隔离性</strong>，主要是为了<strong>处理事务的并发问题</strong>，对于数据我们一般有读、写两种操作：</p><p>对于写操作我们一般就是上锁（索引悲观锁或者版本号乐观锁）</p><p>那么对于读操作（一种是快照读，一种是当前读）有两种解决方案，一种是上锁（对于当前读，会上独占锁，如select … for update），另一种是依靠MVCC（读已提交和可重复读的快照读，如普通select依靠这个实现），每个事务只能读到行记录的undo log版本链它有权限的部分，对于当前读可以读到所有的版本，对于快照读可以看到的版本如下：</p><ol><li>事务已提交的版本（creator_trx_id &lt; min_trx_id），可见</li><li>事务未开始的版本（creator_trx_id &gt; max_trx_id），不可见</li><li>事务活跃的版本（creator_trx_id 属于 m_ids），不可见</li></ol><p>注意到读已提交和可重复读的视图Read View产生的时机不同，Read View其实就是保存着事务ID的一个集合，读已提交每个SQL都会产生新的Read View（因为默认每个SQL都会开启一个新的事务），可重复读的Read View只会在事务开始产生，事务期间都是同一个Read View，这也是可重复读隔离级别可重复读的原因。</p><p>接下来简单谈一谈什么是MVCC吧，MVCC又称多版本并发控制，主要是利用读已提交和可重复读隔离级别下事务启动产生的Read View内的本事务id以及当前活跃的事务id集合配合undo log版本链来判断查询语句想查询的行记录本事务可见的版本。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>简单了解Redis常用数据类型的应用场景</title>
      <link href="/forworl.github.io/2024/02/29/Redis%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
      <url>/forworl.github.io/2024/02/29/Redis%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><ul><li>存储序列化后的对象</li><li>计数，整数的加减 incr decr</li><li>分布式锁 setnx</li><li>session共享</li></ul><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><p>消息队列 lpush + brpop</p><h1 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h1><p>存储对象，这里和 String 的区别是便于修改value</p><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><ul><li>存储文章对应的点赞等</li><li>交集、差集操作，共同关注 sinter、sdiff</li><li>随机抽奖 srandmember、spop</li></ul><h1 id="zSet"><a href="#zSet" class="headerlink" title="zSet"></a>zSet</h1><p>排序：</p><ul><li>取前几位（排行榜）zrange</li><li>取某个分数区间 zrangebyscore</li><li>取某些字典序的（名字、电话本）zrangebylex</li></ul><h1 id="BitMap"><a href="#BitMap" class="headerlink" title="BitMap"></a>BitMap</h1><ul><li>两个状态（登录登出、签到未签到）</li><li>某段时间打卡总次数（key 设置为某个月，offset表示哪一天）</li><li>连续打卡（每天的BitMap的offset表示用户ID，几天的BitMap做&amp;运算）</li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>简单了解一个数据包在网络的一生</title>
      <link href="/forworl.github.io/2024/02/28/%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%8C%85%E5%9C%A8%E7%BD%91%E7%BB%9C%E7%9A%84%E4%B8%80%E7%94%9F/"/>
      <url>/forworl.github.io/2024/02/28/%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%8C%85%E5%9C%A8%E7%BD%91%E7%BB%9C%E7%9A%84%E4%B8%80%E7%94%9F/</url>
      
        <content type="html"><![CDATA[<p>在主题之前，我想先谈谈目前计算机的网络模型，主要谈谈 TCP&#x2F;IP 模型：</p><ul><li><p>应用层：产生最原始的数据，常见协议如 http、ftp、websocket、DNS、QUIC</p></li><li><p>传输层：传递应用层的数据给网络层，必要时进行切割，常见协议如 TCP、UDP</p></li><li><p>网络层：目标寻址，常见协议如 IP、ARP、ICMP</p></li><li><p>网络接入层：通过物理链路传输比特流到目标主机</p></li></ul><p>接下来就正式进入主题了</p><h1 id="1-查看浏览器缓存"><a href="#1-查看浏览器缓存" class="headerlink" title="1.查看浏览器缓存"></a>1.查看浏览器缓存</h1><p>没有缓存的话才会继续往下走，否则直接使用缓存的资源</p><h1 id="2-解析URL和DNS解析"><a href="#2-解析URL和DNS解析" class="headerlink" title="2.解析URL和DNS解析"></a>2.解析URL和DNS解析</h1><p>解析URL，如果应用层协议使用http，默认端口号是80</p><p>DNS解析：</p><ul><li>第一步，先查询本地DNS缓存，如果没有这个域名对应的IP，再进行下一步</li><li>第二步，先询问本地的DNS服务器，交给本地的DNS服务器去解析这个域名，他会逐级找比较厉害的DNS服务器，最后找到域名对应的IP，比如对于<a href="http://www.baidu.com,他会先找.com,再找baidu.com,最后找到www.baidu.com/">www.baidu.com，他会先找.com，再找baidu.com，最后找到www.baidu.com</a></li></ul><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240228231336482.png" alt="image-20240228231336482"></p><h1 id="3-考虑TCP和TLS握手"><a href="#3-考虑TCP和TLS握手" class="headerlink" title="3.考虑TCP和TLS握手"></a>3.考虑TCP和TLS握手</h1><p>对于一些重要的数据（不允许丢失），我们需要先建立TCP连接，他能保证我们的数据安全到达对方，否则可以考虑UDP传输</p><h1 id="4-数据包装"><a href="#4-数据包装" class="headerlink" title="4.数据包装"></a>4.数据包装</h1><p>网络模型每次往下一层，都会给数据包增加一个头部</p><ul><li>应用层：HTTP头</li><li>传输层：TCP头，以及明文数据加密</li><li>网络层：IP头</li><li>数据接口层：MAC头</li></ul><h1 id="5-数据传输"><a href="#5-数据传输" class="headerlink" title="5.数据传输"></a>5.数据传输</h1><p>数据包在网络里被多次转发，最终要到达目的地</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>简单了解Innodb引擎如何加行锁</title>
      <link href="/forworl.github.io/2024/02/28/Innodb%E5%BC%95%E6%93%8E%E5%A6%82%E4%BD%95%E5%8A%A0%E8%A1%8C%E9%94%81/"/>
      <url>/forworl.github.io/2024/02/28/Innodb%E5%BC%95%E6%93%8E%E5%A6%82%E4%BD%95%E5%8A%A0%E8%A1%8C%E9%94%81/</url>
      
        <content type="html"><![CDATA[<p>我们说对于MYSQL加锁一般是说Innodb加锁，因为一定版本号后的MySQL默认的存储引擎就是Innodb，我们可以先来看看Innodb和MyISAM的区别</p><table><thead><tr><th></th><th>Innodb</th><th>MyISAM</th></tr></thead><tbody><tr><td>事务</td><td>√</td><td>×</td></tr><tr><td>行锁</td><td>√</td><td>×</td></tr><tr><td>索引</td><td>索引和数据耦合在一起</td><td>索引和数据分开存储，对于所有索引都是二级索引</td></tr><tr><td>文件</td><td>.frm表结构文件、.ibd数据文件</td><td>.frm表结构文件、.myd数据文件、.myi索引文件</td></tr></tbody></table><p>MySQL有三种锁：全局锁、表级锁、行级锁，对于行锁又有以下三种：</p><ul><li>记录锁 Record Lock：单点区域，读写互斥</li><li>间隙锁 Gap Lock：左开右开区域，读写不互斥</li><li>临键锁 Record Lock：左开右闭区域，读写互斥</li></ul><p>对于不同的隔离级别，锁也会有所区别，比如在读已提交的隔离级别，只有记录锁，到了可重复读的隔离级别，才会有间隙锁以及临键锁</p><p>对于行锁来说，事务提交才会释放锁</p><p><strong>如何加行锁？</strong></p><p>Innodb引擎加行锁都是加在索引上的，如果没有索引条件，默认会锁住全表（相当于锁在了其它索引或者那个隐藏的id索引）</p><p>如何避免锁住全表呢？</p><ul><li>写SQL语句的时候使用where加上索引条件</li><li>使用limit限制查询的条数</li></ul><p>哪些语句可以加锁呢？</p><ul><li>select：<ul><li>普通的select：无锁</li><li>select in share mode：共享锁</li><li>select for update：独占锁</li></ul></li><li>update：</li><li>insert：</li><li>delete：</li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何交替打印输出0~100</title>
      <link href="/forworl.github.io/2024/02/28/%E5%A6%82%E4%BD%95%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0%E8%BE%93%E5%87%BA0-100/"/>
      <url>/forworl.github.io/2024/02/28/%E5%A6%82%E4%BD%95%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0%E8%BE%93%E5%87%BA0-100/</url>
      
        <content type="html"><![CDATA[<h1 id="两个线程交替打印0-100"><a href="#两个线程交替打印0-100" class="headerlink" title="两个线程交替打印0~100"></a>两个线程交替打印0~100</h1><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JUCTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">monitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Print</span>(), <span class="string">&quot;thread-1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Print</span>(), <span class="string">&quot;thread-2&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Print</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count &lt;= MAX) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (monitor) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (count &lt;= MAX) &#123;</span><br><span class="line">                            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + count);</span><br><span class="line">                            count++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        monitor.notifyAll();</span><br><span class="line">                        monitor.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JUCTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Print</span>(), <span class="string">&quot;thread-1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Print</span>(), <span class="string">&quot;thread-2&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Print</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count &lt;= MAX) &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (count &lt;= MAX) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + count);</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    condition.signalAll();</span><br><span class="line">                    condition.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三个线程交替打印0-100"><a href="#三个线程交替打印0-100" class="headerlink" title="三个线程交替打印0~100"></a>三个线程交替打印0~100</h1><h2 id="synchronized-1"><a href="#synchronized-1" class="headerlink" title="synchronized"></a>synchronized</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// synchronized + Monitor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JUCTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">monitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Print</span>(<span class="number">0</span>));</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Print</span>(<span class="number">1</span>));</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Print</span>(<span class="number">2</span>));</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Print</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> seq;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Print</span><span class="params">(<span class="type">int</span> seq)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.seq = seq;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count &lt;= MAX)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (monitor) &#123;</span><br><span class="line">                    <span class="comment">// 注意这里是 while，不是 if</span></span><br><span class="line">                    <span class="keyword">while</span> (count % <span class="number">3</span> != seq) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            monitor.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(count &lt;= MAX)&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;thread-&quot;</span> + seq + <span class="string">&quot;: &quot;</span> + count);</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    monitor.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="ReentrantLock-1"><a href="#ReentrantLock-1" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReentrantLock + Condition</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JUCTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Print</span>(<span class="number">0</span>));</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Print</span>(<span class="number">1</span>));</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Print</span>(<span class="number">2</span>));</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Print</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> seq;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Print</span><span class="params">(<span class="type">int</span> seq)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.seq = seq;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count &lt;= MAX) &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="comment">// 注意这里是 while，不是 if</span></span><br><span class="line">                <span class="keyword">while</span> (count % <span class="number">3</span> != seq) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        condition.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (count &lt;= MAX) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;thread-&quot;</span> + seq + <span class="string">&quot;: &quot;</span> + count);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                condition.signalAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>线上问题的排查</title>
      <link href="/forworl.github.io/2024/02/28/%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98%E7%9A%84%E6%8E%92%E6%9F%A5/"/>
      <url>/forworl.github.io/2024/02/28/%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98%E7%9A%84%E6%8E%92%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="CPU使用率飙升"><a href="#CPU使用率飙升" class="headerlink" title="CPU使用率飙升"></a>CPU使用率飙升</h1><p>使用 jdk 自带的命令 jstack</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.top // 查看所有进程的CPU使用率</span><br><span class="line"></span><br><span class="line">2.top -Hp PID // 查看某个进程内的线程的CPU使用率</span><br><span class="line"></span><br><span class="line">3.printf &#x27;%x\n&#x27; TID // 查看线程ID对应的16进制数</span><br><span class="line"></span><br><span class="line">4.jstack PID | grep -A 200 TID（16进制）</span><br></pre></td></tr></table></figure><p>使用 Alibaba 的 arthas</p><h1 id="代码死锁"><a href="#代码死锁" class="headerlink" title="代码死锁"></a>代码死锁</h1><p>使用 jdk 自带的命令 jstack</p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240229093510071.png" alt="image-20240229093510071"></p><p>模拟的死锁代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyTask</span>(<span class="literal">true</span>), <span class="string">&quot;thread-1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyTask</span>(<span class="literal">false</span>), <span class="string">&quot;thread-2&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">boolean</span> flag;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">MyTask</span><span class="params">(<span class="type">boolean</span> flag)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.flag = flag;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj1)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;obj1&quot;</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (obj2)&#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;obj2&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj2)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;obj2&quot;</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (obj1)&#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;obj1&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数据库死锁"><a href="#数据库死锁" class="headerlink" title="数据库死锁"></a>数据库死锁</h1><p>使用 show engine innodb status 查看死锁日志</p><p>出现死锁的原因一般是循环等待条件满足了</p><p>对于索引加锁，如果只有主键索引，那么直接在主键索引上加锁；如果还有二级索引，那么先在二级索引加锁，再在主键索引加锁</p><h1 id="慢SQL"><a href="#慢SQL" class="headerlink" title="慢SQL"></a>慢SQL</h1><p><strong>查看慢查询日志是否开以及如何开启</strong></p><ul><li>查看慢查询日志是否开启：<code>SHOW VARIABLES LIKE &#39;%slow_query_log%&#39;;</code>。</li><li>开启慢查询日志：<code>SET GLOBAL slow_query_log = 1;</code>。<strong>使用该方法开启MySQL的慢查询日志只对当前数据库生效，如果MySQL重启后会失效。</strong></li></ul><p><strong>设置慢SQL的时间阈值</strong></p><p>时间阈值是由参数<code>long_query_time</code>控制的，默认情况下<code>long_query_time</code>的值为10秒。</p><p>MySQL中查看<code>long_query_time</code>的时间：<code>SHOW VARIABLES LIKE &#39;long_query_time%&#39;;</code>。</p><p><strong>使用explain分析</strong></p><ul><li>type：使用什么方式检索<ul><li>const：常数</li><li>eq_ref：唯一索引</li><li>ref：普通索引</li><li>range：范围</li><li>index：索引树</li><li>all：全表</li></ul></li><li>keys：具体使用哪个索引</li><li>extra：没有用到索引的原因<ul><li>using where：没有用到索引或者没有用到联合索引的前导列</li><li>using index：用到了索引覆盖</li><li>using index condition：用到了索引下推</li><li>using where；using index：索引在联合索引内，但不是前导列</li><li>using temporary：用到了临时表，通常是排序或者分组使用</li><li>using filesort：无法根据索引排序，要在内存排序</li></ul></li></ul><h1 id="OOM"><a href="#OOM" class="headerlink" title="OOM"></a>OOM</h1><h1 id="频繁Full-GC"><a href="#频繁Full-GC" class="headerlink" title="频繁Full GC"></a>频繁Full GC</h1>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>简单了解常用排序算法</title>
      <link href="/forworl.github.io/2024/02/27/%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/forworl.github.io/2024/02/27/%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>时间复杂度： O(n ^ 2)</p><p>稳定性：稳定</p><p><strong>每次把两个相邻数进行比较，大的那个换到后面</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 元素交换</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];        </span><br><span class="line">    arr[j] = arr[i];</span><br><span class="line">    arr[i] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>时间复杂度： O(n ^ 2)</p><p>稳定性：稳定</p><p><strong>每次遍历数组选出一个最小（大）的放到数组前面</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 选择排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">SelectionSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="comment">// 找到最小的值的下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每次循环更新剩余数组的第一位</span></span><br><span class="line">        swap(arr, minIndex, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>时间复杂度： O(n ^ 2)</p><p>稳定性：稳定</p><p><strong>每次从当前位置往前比较，找到合适的插入位置</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">InsertSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="comment">// 从当前位置往前找到要插入的位置</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; temp &lt; arr[j - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="comment">// 把前面的数往后移动一位</span></span><br><span class="line">            arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 插入</span></span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>时间复杂度： O(n * logn)</p><p>稳定性：不稳定</p><p><strong>自上而下，递归子问题，根据pivot把数据分成三个区间</strong></p><ol><li>小于 pivot</li><li>pivot</li><li>大于 pivot</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// partitionIndex是数组下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">partitionIndex</span> <span class="operator">=</span> partition(arr, left, right);</span><br><span class="line">    quickSort(arr, left, partitionIndex - <span class="number">1</span>);</span><br><span class="line">    quickSort(arr, partitionIndex + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="comment">// pivot 是 基准值，此时左区间长度为1</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> left;</span><br><span class="line">    <span class="comment">// index 是 左区间的右边界（包含） + 1</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> pivot + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt;= right; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt; arr[pivot])&#123;</span><br><span class="line">            swap(arr, i, index);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 基准值交换到左区间的右边界，那么左区间的右边界就是index-2</span></span><br><span class="line">    swap(arr, pivot, index - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// [0 index-2] index-1 [index length-1] </span></span><br><span class="line">    <span class="comment">// 返回基准值</span></span><br><span class="line">    <span class="keyword">return</span> index - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>时间复杂度： O(n * logn)</p><p>稳定性：稳定</p><p><strong>自上而下的递归子问题，用小问题解决大问题</strong></p><p>自下而上的适合链表，先归并短的链表，再归并长的链表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 归并排序</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span>[] MergeSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">return</span> MergeSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span>[] MergeSort(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right) &#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt; right) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(left == right) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;arr[left]&#125;;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> merge(MergeSort(arr, left, mid), MergeSort(arr, mid + <span class="number">1</span>, right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并有序数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span>[] merge(<span class="type">int</span>[] arr1, <span class="type">int</span>[] arr2) &#123;</span><br><span class="line">    <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[arr1.length + arr2.length];</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="number">0</span>, p2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt; arr1.length &amp;&amp; p2 &lt; arr2.length) &#123;</span><br><span class="line">        <span class="type">int</span> num;</span><br><span class="line">        <span class="keyword">if</span> (arr1[p1] &lt; arr2[p2]) &#123;</span><br><span class="line">            num = arr1[p1++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            num = arr2[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">        result[index++] = num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt; arr1.length) &#123;</span><br><span class="line">        result[index++] = arr1[p1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p2 &lt; arr2.length) &#123;</span><br><span class="line">        result[index++] = arr2[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>简单了解分布式锁</title>
      <link href="/forworl.github.io/2024/02/27/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
      <url>/forworl.github.io/2024/02/27/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="对于分布式锁，我们希望有如下特点"><a href="#对于分布式锁，我们希望有如下特点" class="headerlink" title="对于分布式锁，我们希望有如下特点"></a>对于分布式锁，我们希望有如下特点</h1><p><strong>资源互斥</strong>：能在分布式条件下对资源占用进行限制</p><p><strong>死锁</strong>：可重入，可超时释放，避免死锁</p><p><strong>高性能、高可用</strong>：加锁、解锁效率高</p><p><strong>安全性</strong>：锁只能被锁持有的客户端删除</p><h1 id="数据库分布式锁"><a href="#数据库分布式锁" class="headerlink" title="数据库分布式锁"></a>数据库分布式锁</h1><p>创建一个<strong>锁表</strong>，其中一个唯一字段存储需要锁的方法或者资源，比如卖票接口，锁住接口或者票的库存</p><p><strong>通过唯一字段的insert、delete操作，实现加锁、释放锁</strong></p><p><strong>缺点：</strong></p><ul><li>锁没有失效时间，可能导致死锁（定时任务扫库）</li><li>锁无法重入，同一个线程释放锁之前无法再次获得锁（参考synchronized的偏向锁，加个字段判断是否是本线程）</li><li>访问数据库涉及I&#x2F;O操作，效率较低（考虑使用缓存）</li><li>非阻塞操作失败后，需要轮询重试，占用cpu资源</li></ul><h1 id="ZooKeeper分布式锁"><a href="#ZooKeeper分布式锁" class="headerlink" title="ZooKeeper分布式锁"></a>ZooKeeper分布式锁</h1><p>暂时不了解，以后找时间再补充，性能没有Redis分布式锁好</p><h1 id="Redis分布式锁"><a href="#Redis分布式锁" class="headerlink" title="Redis分布式锁"></a>Redis分布式锁</h1><p><strong>主要关注超时释放的死锁问题、以及锁误删的安全性问题</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">加锁</span><br><span class="line">业务</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">    解锁</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Redis单机环境"><a href="#Redis单机环境" class="headerlink" title="Redis单机环境"></a>Redis单机环境</h2><h3 id="使用redis原生"><a href="#使用redis原生" class="headerlink" title="使用redis原生"></a>使用redis原生</h3><ol><li><p>第一版：setnx</p><p><strong>锁没有超时时间，可能会死锁</strong></p><ul><li>线程崩溃，可以在finally块释放锁</li><li>服务宕机，锁无法释放</li></ul></li><li><p>第二版：setnx+ expire</p><p>​<strong>无法保证加锁和添加锁过期时间的原子性，可能会死锁</strong></p></li><li><p>第三版：set key value ex nx</p><p>​<strong>存在误删</strong>，比如线程一执行时间太久，此时是线程二持有锁，释放了线程二的锁</p></li><li><p>第四版：set key value ex nx + 创建当前线程的唯一标识UUID，在执行完业务之后，对照是否是本线程再删除锁</p><p><strong>判断锁和删除锁并不是原子性的，所以可能还是会存在误删</strong></p></li><li><p>第五版：set key value ex nx + 创建当前线程的唯一标识UUID，在执行完业务之后，对照是否是本线程再删除锁 + lua</p><ol><li>减少网络开销：原本我们需要向 Redis 服务请求多次命令，可以将命令写在 Lua 脚本中，这样执行只会发起一次网络请求。</li><li>原子操作：Redis 会将 Lua 脚本中的命令当作一个整体执行，中间不会插入其它命令。</li><li>复用：客户端发送的脚步会存储 Redis 中，其他客户端可以复用这一脚本而不需要使用代码完成相同的逻辑。</li></ol></li></ol><p><strong>缺点</strong>：</p><ul><li>过期时间不好控制，需要略大于业务时间，否则业务还未结束锁就被释放了</li><li>非阻塞操作失败后，需要轮询重试，占用cpu资源</li></ul><h3 id="使用Redisson框架"><a href="#使用Redisson框架" class="headerlink" title="使用Redisson框架"></a>使用Redisson框架</h3><ol><li><p>第六版：Redisson分布式锁</p><p>底层使用了看门狗机制，每10s检查一次锁，自动续期，保证业务完成锁才释放</p><p><strong>缺点</strong>：主从复制不及时没有同步锁信息的同时，主节点宕机，导致锁被重复获取</p></li></ol><h2 id="Redis集群环境"><a href="#Redis集群环境" class="headerlink" title="Redis集群环境"></a>Redis集群环境</h2><ol><li><p>第七版：RedLock + Redisson</p><p>Redis集群的处理方式，获取到半数以上主节点的锁才能算上锁成功</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>简单了解静态代理和动态代理的区别</title>
      <link href="/forworl.github.io/2024/02/26/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/forworl.github.io/2024/02/26/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是代理？"><a href="#什么是代理？" class="headerlink" title="什么是代理？"></a>什么是代理？</h1><p>我们不直接访问某个对象，而是<strong>通过代理对象去访问某个对象</strong>，并且可以对功能进行拓展，有个设计模式就叫做代理模式</p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240112091741429.png" alt="image-20240112091741429"></p><h1 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h1><p>我们会有一个代理类来替代 Cook类 访问方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyCook</span> <span class="keyword">implements</span> <span class="title class_">Cook</span>&#123;</span><br><span class="line">    Cook cook;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProxyCook</span><span class="params">(Cook cook)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cook = cook;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cookDinner</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;厨师前置动作...&quot;</span>);</span><br><span class="line">        cook.cookDinner();</span><br><span class="line">        System.out.println(<span class="string">&quot;厨师后置动作...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态代理可以在不修改目标对象的功能前提下, 能通过代理对象对目标功能扩展；静态代理的不足在于只能对某一个方法拓展，如果实体类增加了方法，需要修改代理类的代码。</p><h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><p>有两个方法实现动态代理，一个是JDK自带的，一个是Cglib的代理方法</p><p>JDK代理的代理对象是利用反射机制动态生成，而Cglib的代理对象是利用拦截机制动态生成。</p><p><strong>JDK自带的（要求被代理对象至少实现一个接口）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyJDK</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 被代理的对象</span></span><br><span class="line">    Object proxyTarget;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getProxyInstance</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.proxyTarget = target;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;厨师前置动作...&quot;</span>);</span><br><span class="line">        <span class="comment">// 反射调用真正的方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> method.invoke(proxyTarget, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;厨师后置动作...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Cglib的代理方法（被代理对象可以不实现接口）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyCglib</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 被代理对象</span></span><br><span class="line">    Object proxyTarget;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getProxyInstance</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.proxyTarget = target;</span><br><span class="line">        <span class="keyword">return</span> Enhancer.create(target.getClass(), target.getClass().getInterfaces(), <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;厨师前置动作Cglib...&quot;</span>);</span><br><span class="line">        <span class="comment">// 反射调用真正的方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> method.invoke(proxyTarget, args);</span><br><span class="line">        <span class="comment">// Object obj = methodProxy.invokeSuper(proxy, args);</span></span><br><span class="line">        System.out.println(<span class="string">&quot;厨师后置动作Cglib...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="静态代理和动态代理的区别？"><a href="#静态代理和动态代理的区别？" class="headerlink" title="静态代理和动态代理的区别？"></a>静态代理和动态代理的区别？</h1><p>静态代理被代理对象和代理对象之间的关系在编译期就已经确定；动态代理被代理对象和代理对象之间的关系要在运行期（比如通过反射这样的机制）才能确定</p><p>如果你需要对多个方法进行相同的拓展，动态代理是更好的选择</p><h1 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正常调用&quot;</span>);</span><br><span class="line">        <span class="type">Cook</span> <span class="variable">cook</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CookImpl</span>();</span><br><span class="line">        cook.cookDinner();</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;静态代理&quot;</span>);</span><br><span class="line">        <span class="type">ProxyCook</span> <span class="variable">proxyCook</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyCook</span>(cook);</span><br><span class="line">        proxyCook.cookDinner();</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;JDK动态代理&quot;</span>);</span><br><span class="line">        <span class="type">Cook</span> <span class="variable">proxyJDK</span> <span class="operator">=</span> (Cook) <span class="keyword">new</span> <span class="title class_">ProxyJDK</span>().getProxyInstance(cook);</span><br><span class="line">        proxyJDK.cookDinner();</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Cglib动态代理&quot;</span>);</span><br><span class="line">        <span class="type">Cook</span> <span class="variable">proxyCglib</span> <span class="operator">=</span> (Cook) <span class="keyword">new</span> <span class="title class_">ProxyCglib</span>().getProxyInstance(cook);</span><br><span class="line">        proxyCglib.cookDinner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java SE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>简单了解高并发、高性能、高可用</title>
      <link href="/forworl.github.io/2024/02/26/%E9%AB%98%E5%B9%B6%E5%8F%91%E3%80%81%E9%AB%98%E6%80%A7%E8%83%BD%E3%80%81%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
      <url>/forworl.github.io/2024/02/26/%E9%AB%98%E5%B9%B6%E5%8F%91%E3%80%81%E9%AB%98%E6%80%A7%E8%83%BD%E3%80%81%E9%AB%98%E5%8F%AF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>参考<a href="https://zhuanlan.zhihu.com/p/375847349">关于“高性能、高并发、高可用”的问题解决方案 - 知乎 (zhihu.com)</a></p><h1 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h1><p>QPS（每秒请求数）</p><p>对共享资源并发问题的解决</p><h1 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h1><p>系统的稳定性（避免服务宕机或者中间件宕机导致系统不可用）</p><h1 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h1><p>接口的响应时间</p><p>系统吞吐量</p><p>TPS（每秒事务数）</p><h1 id="高可用的系统如何在高并发的条件下实现高性能？"><a href="#高可用的系统如何在高并发的条件下实现高性能？" class="headerlink" title="高可用的系统如何在高并发的条件下实现高性能？"></a>高可用的系统如何在高并发的条件下实现高性能？</h1><h2 id="1-缓存"><a href="#1-缓存" class="headerlink" title="1.缓存"></a>1.缓存</h2><p><strong>什么是缓存？</strong></p><p>缓存是一种用<strong>空间换时间</strong>的思想，由于计算机访问数据有局部性，数据被分为两部分，一部分我们称作热点数据、另一部分我们称作冷数据</p><p>我们根据需要一般会将热点数据存放在缓存中，减少对数据库的访问，访问内存是比访问磁盘快的</p><p>我们常见的缓存，比如redis这类的非关系数据库，CPU的多级缓存，数据库日志的buffer等</p><p><strong>缓存分类</strong></p><ul><li><p><strong>本地缓存</strong></p><p>我们在单机进程中对数据缓存，适合简单的场景，不需要考虑数据一致性、过期时间、删除策略等问题</p></li><li><p><strong>分布式缓存</strong></p><p>分布式架构下，不同服务器进程代表一个数据分片，对于热点数据的存储我们根据一致性hash算法分配到不同的分片</p></li></ul><p><strong>适合缓存的场景</strong></p><ul><li>读多写少</li><li>计算量耗时大，实时性低（不需要经常更新）</li></ul><p><strong>不适合缓存的场景</strong></p><ul><li>写多读少</li><li>没有热点数据</li><li>对数据一致性严格</li></ul><p><strong>缓存更新策略</strong></p><h2 id="2-预先延后"><a href="#2-预先延后" class="headerlink" title="2.预先延后"></a>2.预先延后</h2><p><strong>预先处理</strong></p><p>我们可以先对系统进行预热，对一些热点数据存放的缓存中</p><p><strong>延后处理</strong></p><p>把某些耗时长的操作后放，比如通过MQ的异步处理数据库操作（减小TPS）、COW（写时复制）</p><h2 id="3-池化"><a href="#3-池化" class="headerlink" title="3.池化"></a>3.池化</h2><p>内存、连接、线程这些都是资源，创建线程、分配内存、数据库连接这些操作都有一个特征（频繁创建销毁过程带来的系统调用以及网络I&#x2F;O），我们运用各种池来避免资源的频繁创建、销毁</p><p><strong>连接池</strong></p><p>常见的比如数据库连接池、HTTP请求连接池等</p><p><strong>线程池</strong></p><ol><li>管理器（Manager）: 用于创建并管理线程池。</li><li>工作线程（Worker）: 执行任务的线程。</li><li>任务接口（Task）: 每个具体的任务必须实现任务接口，工作线程将调用该接口来完成具体的任务。</li><li>任务队列（TaskQueue）: 存放还未执行的任务。</li></ol><h2 id="4-异步（回调）"><a href="#4-异步（回调）" class="headerlink" title="4.异步（回调）"></a>4.异步（回调）</h2><ul><li>同步：串行化执行，下个任务在本任务执行后才能执行</li><li>异步：下个任务和本任务可以同时执行，本任务执行完成回调给下个任务知道本任务完成，比如异步编排CompletableFuture、AIO（异步I&#x2F;O）、线程异步</li></ul><h2 id="5-MQ"><a href="#5-MQ" class="headerlink" title="5.MQ"></a>5.MQ</h2><p>解耦、异步、削峰</p><p><strong>好处</strong></p><ul><li>服务解耦</li><li>部分任务异步执行，提高服务的并发度</li></ul><p><strong>问题</strong></p><ul><li>降低了数据一致性，从强一致性变为最终一致（弱一致性）</li><li>有消息丢失的风险，比如宕机，需要有容灾机制</li></ul><h2 id="6-批量处理"><a href="#6-批量处理" class="headerlink" title="6.批量处理"></a>6.批量处理</h2><p>涉及到 I&#x2F;O 考虑批量处理，比如数据库的批量更新，以及redis的管道或者是lua脚本</p><h2 id="7-数据库优化"><a href="#7-数据库优化" class="headerlink" title="7.数据库优化"></a>7.数据库优化</h2><p><strong>索引</strong></p><p>合理使用索引</p><p><strong>读写分离</strong></p><p>配置主从架构</p><p><strong>分库分表</strong></p><h2 id="8-零拷贝"><a href="#8-零拷贝" class="headerlink" title="8. 零拷贝"></a>8. 零拷贝</h2><h2 id="9-无锁化"><a href="#9-无锁化" class="headerlink" title="9. 无锁化"></a>9. 无锁化</h2><p><strong>CAS（Compare And Swap）</strong></p><p>什么是 CAS，CAS 有三个操作数，内存里当前值 M、预期值 E、修改的新值 N</p><h2 id="10-序列化与反序列化"><a href="#10-序列化与反序列化" class="headerlink" title="10.序列化与反序列化"></a>10.序列化与反序列化</h2><p>将数据转化为二进制，减少文本大小，利于数据在网络中传输</p>]]></content>
      
      
      <categories>
          
          <category> 系统架构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring的bean的几种声明方式</title>
      <link href="/forworl.github.io/2024/02/26/Spring%E7%9A%84bean%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A3%B0%E6%98%8E%E6%96%B9%E5%BC%8F/"/>
      <url>/forworl.github.io/2024/02/26/Spring%E7%9A%84bean%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A3%B0%E6%98%8E%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="组件声明"><a href="#组件声明" class="headerlink" title="组件声明"></a>组件声明</h1><p>@Component</p><p>@Controller</p><p>@Service</p><p>@Repository</p><h1 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h1><p>@Configuration + @Bean</p><p>@ConponentScan用来搜索配置了@Conponent的类，通常和@Configuration配合使用</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ整合SpringBoot快速使用</title>
      <link href="/forworl.github.io/2024/02/24/RocketMQ%E6%95%B4%E5%90%88SpringBoot%E5%BF%AB%E9%80%9F%E4%BD%BF%E7%94%A8/"/>
      <url>/forworl.github.io/2024/02/24/RocketMQ%E6%95%B4%E5%90%88SpringBoot%E5%BF%AB%E9%80%9F%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="快速使用"><a href="#快速使用" class="headerlink" title="快速使用"></a>快速使用</h1><p><strong>1.pom添加依赖</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;rocketmq-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>2.yml添加配置</strong></p><p>version 2.2.0以上才是这么配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rocketmq:</span><br><span class="line">  name-server: $&#123;serverip&#125;:9876</span><br><span class="line">  producer:</span><br><span class="line">    group: message-producer-group</span><br></pre></td></tr></table></figure><p><strong>3.编写Producer</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest(classes = RocketMQApplication.class)</span></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">commonProducer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RocketMQTemplate rocketMQTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步消息</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendSyncMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;我是一个同步消息&quot;</span>;</span><br><span class="line">        rocketMQTemplate.syncSend(<span class="string">&quot;commonSyncTopic&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步消息</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendAsyncMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;我是一个异步消息&quot;</span>;</span><br><span class="line">        rocketMQTemplate.asyncSend(<span class="string">&quot;commonAsyncTopic&quot;</span>, msg, <span class="keyword">new</span> <span class="title class_">SendCallback</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(SendResult sendResult)</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;成功&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onException</span><span class="params">(Throwable throwable)</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;失败&quot;</span> + throwable.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单向消息</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendOneWayMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;我是一个单向消息&quot;</span>;</span><br><span class="line">        rocketMQTemplate.syncSend(<span class="string">&quot;commonOneWayTopic&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 延迟消息</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendDelayMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        Message&lt;String&gt; message = MessageBuilder.withPayload(<span class="string">&quot;我是一个延迟消息&quot;</span>).build();</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        <span class="comment">// 1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h</span></span><br><span class="line">        rocketMQTemplate.syncSend(<span class="string">&quot;commonDelayTopic&quot;</span>, message,<span class="number">3000</span>,<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4.编写Consumer</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种写法: MessageExt有消息头 + 消息体</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RocketMQMessageListener(</span></span><br><span class="line"><span class="meta">        consumerGroup = &quot;commonAsyncMessage-consumer-group&quot;,</span></span><br><span class="line"><span class="meta">        topic = &quot;commonAsyncTopic&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonAsyncConsumer</span> <span class="keyword">implements</span> <span class="title class_">RocketMQListener</span>&lt;MessageExt&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(MessageExt messageExt)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接收到消息&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(messageExt.getBody()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种写法: 只有消息体</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RocketMQMessageListener(</span></span><br><span class="line"><span class="meta">        consumerGroup = &quot;commonAsyncMessage-consumer-group&quot;,</span></span><br><span class="line"><span class="meta">        topic = &quot;commonAsyncTopic&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonAsyncConsumer</span> <span class="keyword">implements</span> <span class="title class_">RocketMQListener</span>&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接收到消息&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5.发送消息</strong></p><p>启动producer内的测试方法，以及启动项目的启动类</p>]]></content>
      
      
      <categories>
          
          <category> xxx </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何学习一个新东西</title>
      <link href="/forworl.github.io/2024/02/22/%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%AA%E6%96%B0%E4%B8%9C%E8%A5%BF/"/>
      <url>/forworl.github.io/2024/02/22/%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%AA%E6%96%B0%E4%B8%9C%E8%A5%BF/</url>
      
        <content type="html"><![CDATA[<p>这个东西我们把它称作 x 吧</p><p>学东西切记走马观花，不是越快越好，在你学过一遍之后，一定要及时的输出（笔记或者是小demo），建议列一个思维导图，方便快速回忆起 x 的一些总体框架，具体细节可以看笔记</p><p><strong>基本步骤</strong></p><p>1.我们需要了解这个东西的概念，是用来干嘛的，有什么特性，有没有同类别的产品</p><p>2.快速上手，我们需要学习一些 x 的基本用法，可以做一些小 demo</p><p>3.深入了解当中的一些功能，它的底层源码是如何实现这个功能的，一般会涉及到一些设计模式</p><p>4.融会贯通，这一步是自然而然随时间的累计会达成的</p><p>最后，加油！！！</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>简单了解ArrayList和LinkedList</title>
      <link href="/forworl.github.io/2024/02/20/ArrayList%E5%92%8CLinkedList/"/>
      <url>/forworl.github.io/2024/02/20/ArrayList%E5%92%8CLinkedList/</url>
      
        <content type="html"><![CDATA[<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p><strong>ArrayList和LinkedList本质上的区别是数组和链表之间的增删改查的区别，ArrayList多一个扩容机制而已</strong></p><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><h5 id="底层是数组"><a href="#底层是数组" class="headerlink" title="底层是数组"></a>底层是数组</h5><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240115100728681.png" alt="image-20240115100728681"></p><h5 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h5><p>先判断是否需要扩容</p><p>再插入</p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240115100830425.png" alt="image-20240115100830425"></p><h5 id="grow"><a href="#grow" class="headerlink" title="grow()"></a>grow()</h5><p>1.5倍扩容，如果初始为0，那么扩容到1；如果初始为1，那么扩容到2</p><p>new一个新的数组，Arrays.copyof() 将旧的数组copy过去</p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240115101353211.png" alt="image-20240115101353211"></p><h5 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h5><p>检查位置是否合法，然后删除，需要调用native方法移动数组元素</p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240115102204254.png" alt="image-20240115102204254"></p><h5 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h5><p>根据下标直接返回元素</p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240115103317507.png" alt="image-20240115103317507"></p><h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><h5 id="底层是双向链表，一头头节点，一个尾节点"><a href="#底层是双向链表，一头头节点，一个尾节点" class="headerlink" title="底层是双向链表，一头头节点，一个尾节点"></a>底层是双向链表，一头头节点，一个尾节点</h5><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240115102442807.png" alt="image-20240115102442807"></p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240115102719636.png" alt="image-20240115102719636"></p><h5 id="add-1"><a href="#add-1" class="headerlink" title="add()"></a>add()</h5><p>尾插法插入新的节点</p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240115102842291.png" alt="image-20240115102842291"></p><h5 id="remove-1"><a href="#remove-1" class="headerlink" title="remove()"></a>remove()</h5><p>拿到待删除节点的前后节点，进行双向链表那样的删除</p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240115102922252.png" alt="image-20240115102922252"></p><h5 id="get-1"><a href="#get-1" class="headerlink" title="get()"></a>get()</h5><p>会用二分法先优化一下，索引位置和链表长度&#x2F;2先比对一下，然后在左半边遍历还是右半边遍历</p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240115103138904.png" alt="image-20240115103138904"></p>]]></content>
      
      
      <categories>
          
          <category> Java SE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Nginx</title>
      <link href="/forworl.github.io/2024/01/17/Nginx/"/>
      <url>/forworl.github.io/2024/01/17/Nginx/</url>
      
        <content type="html"><![CDATA[<p><strong>Nginx是什么？</strong></p><p>Nginx是一个轻量级&#x2F;高性能的反向代理Web服务器，它的主要功能就是反向代理、负载均衡、配置SSL证书、防盗链、解决跨域问题、缓存、限流、动静资源分离等等。</p><h2 id="区别正向代理和反向代理"><a href="#区别正向代理和反向代理" class="headerlink" title="区别正向代理和反向代理"></a>区别正向代理和反向代理</h2><ul><li><p>正向代理：比如VPN，也就是翻墙（防火墙），比如Google限制了中国的ip的访问，我们就需要把请求发到代理客户端的服务器上，</p><p>再由代理服务器向真正的目标服务器转发请求</p></li><li><p>反向代理：比如我们访问<a href="http://www.baidu.com这个代理服务器的域名,再转发到真正工作的服务器(可能很多台)/">www.baidu.com这个代理服务器的域名，再转发到真正工作的服务器（可能很多台）</a></p></li></ul><p><strong>总的来说，正向代理代理的是客户端，反向代理代理的是服务端</strong></p><h2 id="nginx配置文件的编写"><a href="#nginx配置文件的编写" class="headerlink" title="nginx配置文件的编写"></a>nginx配置文件的编写</h2><p>http有很多server</p><p>server有很多location</p><p>一个server可以理解为一个服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#1.全局配置------------------------------------------------------------------------</span><br><span class="line">...              </span><br><span class="line"></span><br><span class="line">#events 配置--------------------------------------------------------------------</span><br><span class="line">2.events &#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line">#http 配置----------------------------------------------------------------------</span><br><span class="line">http</span><br><span class="line">&#123;</span><br><span class="line">#3.http 全局配置</span><br><span class="line">    ...</span><br><span class="line">    #4.server 全局配置，在这里负载均衡</span><br><span class="line">    upstream test &#123;</span><br><span class="line">        server localhost:8080;</span><br><span class="line">        server localhost:8081;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    server //这里是转发的主要代码</span><br><span class="line">    &#123; </span><br><span class="line">    #5.server全局配置</span><br><span class="line">        listen       80;                                                         </span><br><span class="line">        server_name  localhost;                                               </span><br><span class="line">        client_max_body_size 1024M;  </span><br><span class="line">        </span><br><span class="line">        #6.location配置，在这里动静分离</span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://localhost:8080; // 如果负载均衡 proxy_pass http://test;</span><br><span class="line">            proxy_set_header Host $host:$server_port;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;                                                         </span><br><span class="line">    server_name  localhost;                                               </span><br><span class="line">    client_max_body_size 1024M;</span><br><span class="line"></span><br><span class="line">    location ~ \.(html)$ &#123; // 访问html的话就转发</span><br><span class="line">           root   e:\wwwroot;</span><br><span class="line">           index  index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>为什么要动静分离？</strong></p><p>因为访问动态资源的话是需要转发到服务器的，途中需要时间，但是静态资源可以放在nginx服务器内，响应更快</p><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>可以设置权重、使用ip_hash、fair（响应时间短的优先）、url_hash</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream backserver &#123; </span><br><span class="line"> server 192.168.1.1; </span><br><span class="line"> server 192.168.1.2; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><strong>为什么要负载均衡？</strong></p><p>多台机器同时跑一个程序的话，前端不用管后端的集群的那些服务是哪个接口，只需要请求某个接口，交给Nginx转发就好了</p><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>待办</p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>cookie、session、token区别</title>
      <link href="/forworl.github.io/2024/01/14/cookie%E3%80%81session%E3%80%81token%E5%8C%BA%E5%88%AB/"/>
      <url>/forworl.github.io/2024/01/14/cookie%E3%80%81session%E3%80%81token%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>参考：<a href="https://zhuanlan.zhihu.com/p/625995458">一文讲透Token与Cookie、Session的区别 - 知乎 (zhihu.com)</a></p><h1 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h1><p>由于 HTTP 的无状态，引入了 cookie，是通信双方用来传递信息的，保存在client</p><h1 id="session"><a href="#session" class="headerlink" title="session"></a>session</h1><p>对用户身份的认证机制</p><p><strong>cookie是实现session的一种方式，保存在server</strong></p><p>如果不能用cookie（比如跨域），那么sessionId无法用cookie传递</p><p><strong>什么是跨域？</strong></p><p>答：跨域就违反了同源策略，请求了不同的IP或者端口的资源，导致跨域</p><p>同源策略：浏览器只能请求 相同协议、IP、端口的资源</p><h1 id="token"><a href="#token" class="headerlink" title="token"></a>token</h1><p>对用户身份的认证机制</p><p>保存在client，和seesion的校验机制不一样</p><p>解决跨域不能共享 Cookie 的问题和 CSRF 攻击，不然用cookie包装sessionId也一样效果</p><p><strong>JWT是token的一种实现方式</strong></p><ol><li>header：指定了签名算法</li><li>payload：可以指定用户 id，过期时间等非敏感数据</li><li>Signature: 签名，server 根据 header 知道它该用哪种签名算法，再用密钥根据此签名算法对 head + payload 生成签名，这样一个 token 就生成了。</li></ol><p><strong>CSRF 攻击</strong>：<strong>由于相同域名的请求会自动带上 cookie</strong>，而 cookie 里带有正常登录用户的 sessionid，类似转账操作在 server 就会成功，会造成极大的安全风险</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们本质上使用的是用于认证用户身份的sessionid或者是token，他们都是对用户身份的认证机制，只不过方式不同</p><p>cookie是用来实现session的</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/forworl.github.io/2024/01/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/forworl.github.io/2024/01/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="面对对象三大特性"><a href="#面对对象三大特性" class="headerlink" title="面对对象三大特性"></a>面对对象三大特性</h1><p>封装、继承、多态</p><h1 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h1><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240104164237808.png" alt="image-20240104164237808"></p><h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><p>父子继承</p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240104164319006.png" alt="image-20240104164319006"></p><h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><p>实现接口</p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240104164341390.png" alt="image-20240104164341390"></p><h2 id="关联关系"><a href="#关联关系" class="headerlink" title="关联关系"></a>关联关系</h2><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240104164400756.png" alt="image-20240104164400756"></p><h2 id="聚合关系"><a href="#聚合关系" class="headerlink" title="聚合关系"></a>聚合关系</h2><p>弱包含关系，B可以不是A的一部分</p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240104164417747.png" alt="image-20240104164417747"></p><h2 id="组合关系"><a href="#组合关系" class="headerlink" title="组合关系"></a>组合关系</h2><p>强包含关系，B是A的一部分</p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240104164428624.png" alt="image-20240104164428624"></p><h2 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h2><p>强耦合</p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240104164504261.png" alt="image-20240104164504261"></p><h1 id="六大设计原则"><a href="#六大设计原则" class="headerlink" title="六大设计原则"></a>六大设计原则</h1><p>单一职责原则：一个类只负责一个功能</p><p>开放-封闭原则：对于拓展开放、对于更改封闭，只对需要频繁修改的那部分抽象（抽象类）</p><p>依赖倒转原则：细节依赖抽象（面向接口编程）</p><p>里氏代换原则：子类可以替换其父类，这让开放-封闭原则成为可能</p><p>迪米特法则：前提是类封装的思想，强调类间的松耦合</p><h1 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h1><p>隐藏创建类对象的过程，体现高内聚、低耦合</p><p><strong>工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式</strong></p><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>比如要实现一个计算器功能，我们用 switch 或者 if 根据符号来判断用哪个工厂生成答案，如果需要增加复杂的运算，只需要 switch 多加一个选择，多加一个工厂类就可以了</p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240104171815675.png" alt="image-20240104171815675"></p><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>工厂模式是对简单工厂模式的抽象和拓展，每个产品都有相对应的工厂，避免了修改源代码（switch加分支）破坏开放-封闭原则，但是却需要增加产品类和工厂类</p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240112092605378.png" alt="image-20240112092605378"></p><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>每个工厂可以生产不止一种产品，而是同一系列（同一家公司）的很多种产品</p><p>抽象工厂模式每次新增一个抽象产品类要修改的代码太多，既要新增产品类，还要修改原有工厂类，这个时候可以采用简单工厂模式 + 抽象工厂模式代替</p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240118092215680.png" alt="image-20240118092215680"></p><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>该类只有全局唯一实例化对象</p><p>饿汉式：优点是无线程安全问题，类加载就创建对象；缺点是占内存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton01</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton01</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton01</span>();<span class="comment">//声明对象同时私有化</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton01 <span class="title function_">getInstance</span><span class="params">()</span>&#123;<span class="comment">//向外声明访问该类对象的方法</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>懒汉式：优点是延迟加载，创建后才占用内存；缺点是有线程安全问题，需要双重检查锁保证</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.线程不安全 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton02</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">Singleton02</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//声明对象，不实例化</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton02 <span class="title function_">getInstance</span><span class="params">()</span>&#123;<span class="comment">//向外提供访问该类对象的方法</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton02</span>();</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2.double-check锁保证线程安全</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton02</span> &#123;</span><br><span class="line">    <span class="comment">// 由于锁已经保证了可见性，这里volatile的作用是防止new过程中的指令重排</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">Singleton02</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//声明对象，不实例化</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton02 <span class="title function_">getInstance</span><span class="params">()</span>&#123;<span class="comment">//向外提供访问该类对象的方法</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton02.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton02</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240119092547006.png" alt="image-20240119092547006"></p><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>Director包装了Buider，然后传入不同的ConcreteBuider，可以实现不同细节、但是相同工序的包装</p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240116094545444.png" alt="image-20240116094545444"></p><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>原型模式通过拷贝来产生新的对象，而不是new，并且可以根据自己的需求修改对象的属性</p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240114094925346.png" alt="image-20240114094925346"></p><h1 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h1><p>隐藏了真正功能对象的行为</p><p><strong>适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式</strong></p><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240118094746255.png" alt="image-20240118094746255"></p><h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><p>Decorator类包装了Component类，具体的表现为几个ConcreteDecoration类按顺序包装了ConcreteComponent类</p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240110095518675.png" alt="image-20240110095518675"></p><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理类Proxy通过调用真实对象的方法，代替真实对象RealObject来做事情，并且可以对功能进行拓展</p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240112091741429.png" alt="image-20240112091741429"></p><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p>提供一个Facade解除客户端和系统的耦合度，调用系统的功能也只需要通过Facade调用即可，完美体现了依赖倒置原则和迪米特法则</p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240115095208923.png" alt="image-20240115095208923"></p><h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p>把抽象部分分离，就是可以按某个抽象分类，也可以按别的抽象分类，手机品牌、手机软件，然后将他们组合代替继承</p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240119094414641.png" alt="image-20240119094414641"></p><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>对于用户来说不用关心访问的是树枝还是树叶，他们在外观表现上没有任何区别，只不过树枝里面还能有树叶罢了</p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240119091433198.png" alt="image-20240119091433198"></p><h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p>共享一些系统资源（CPU、内存），让一些类的对象可以复用（如串池的String），内部实现不变，外部实现可以改变</p><p>FlyweighFactory生产Flyweigh，分为要复ConcreteFlyweigh用的和独享的UnsharedConcreteFlyweigh</p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240121092245279.png" alt="image-20240121092245279"></p><h1 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h1><p><strong>策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式</strong></p><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>Strategy策略类定义了某个各种算法的公共方法，不同的算法类通过继承Strategy策略类，实现自己的算法</p><p>Context的作用是减少客户端和Strategy策略类之间的耦合，客户端只需要调用Context并且传递相应的算法参数，来调用不同的算法，Context的内部实现可以用简单工厂模式</p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240104171319410.png" alt="image-20240104171319410"></p><h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><p>将一些不变的行为放到父类中，需要变化的行为交给子类实现，其实是对继承、多态的运用</p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240115093959050.png" alt="image-20240115093959050"></p><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p>遍历某个集合的时候，无需关心它的每个元素之间的区别以及其内部结构</p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240119092344227.png" alt="image-20240119092344227"></p><h2 id="观察者模式（发布-订阅模式）"><a href="#观察者模式（发布-订阅模式）" class="headerlink" title="观察者模式（发布 - 订阅模式）"></a>观察者模式（发布 - 订阅模式）</h2><p>观察者根据主题类的状态变化来改变自身状态</p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240117095129017.png" alt="image-20240117095129017"></p><h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><p>让某个请求能够被链上某个处理器处理，也可能不处理</p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240121090952473.png" alt="image-20240121090952473"></p><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>利用命令类Invoker解耦了Client和Receiver，也减少了Receiver的职责，符合单一职责，<strong>如果说Client的要求是需要能够改动的，那么在Invoker类就可以随之修改</strong></p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240119095308963.png" alt="image-20240119095308963"></p><h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><p>其实就是用一个类保存了一些需要恢复的信息，某件事情结束以后，利用这个对象恢复原来的状态</p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240119090842850.png" alt="image-20240119090842850"></p><h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><p>根据不同的状态来让类表现出不同的行为，这样想修改某个状态的时候只需要修改某个状态子类就可以</p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240118094238438.png" alt="image-20240118094238438"></p><h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><p>一般不用，保证Vistor只有固定的几类，否则会破坏开放-封闭原则</p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240121093233652.png" alt="image-20240121093233652"></p><h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><p>减少ConcreteColleague之间的耦合，任何一个ConcreteColleague发生改变不影响其它，有一个中介着类来解耦合ConcreteColleagues</p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240121091556646.png" alt="image-20240121091556646"></p><h2 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h2><p>暂时跳过</p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240121092814691.png" alt="image-20240121092814691"></p><h1 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h1><p><strong>策略模式和简单工厂模式的区别？</strong></p><p>策略模式的这些算法都是在完成一件事，只不过实现不同；简单工厂模式的这些工厂生产的是不同的产品</p><p>当然我个人认为，从代码实现的角度看，Context 等价于 Factory，然后工厂模式没有 Strategy 这一层，直接是不同工厂继承父工厂，有点类似吧</p><p><strong>简单工厂模式和工厂模式的却区别？</strong></p><p>简单工厂模式的拓展只需增加新的对象类，修改switch分支，工厂模式需要额外新增新的工厂类，修改客户端代码</p><p>但是工厂模式可以避免破坏开放-封闭原则</p><p>总的来说，简单工厂模式减少了工厂类的数量，并且在抽象工厂模式的时候配合使用可以避免工厂类的修改</p><p><strong>工厂模式和抽象工厂模式的却区别？</strong></p><p>工厂模式一个工厂类生产一种产品</p><p>抽象工厂模式一个工厂类生产一系列很多种产品</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>spring源码</title>
      <link href="/forworl.github.io/2023/12/20/Spring%E6%BA%90%E7%A0%81/"/>
      <url>/forworl.github.io/2023/12/20/Spring%E6%BA%90%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="一些阅读的总结"><a href="#一些阅读的总结" class="headerlink" title="一些阅读的总结"></a>一些阅读的总结</h1><p>阅读源码的时候利用好断点和堆栈来 debug</p><p>思考一些常用功能（如 xml 或 注解 自动装配、根据名字或类型如何获取 bean）是如何实现的</p><p>Spring 使用了大量的设计模式，如模板模式</p><p>Spring 使用组合大于继承，一个类可能包含很多其他类或接口</p><p>注意一些关键的类就可以大致了解 Spring 的功能</p><p>由于途中会经常的使用 BeanDefinition，调试的时候在 RootBeanDefinition 的构造器打上断点</p><h1 id="待解决的问题"><a href="#待解决的问题" class="headerlink" title="待解决的问题"></a>待解决的问题</h1><p><strong>IoC是什么？</strong></p><p><strong>我们通常理解的IoC就是存储bean的容器，实际上IoC的本意是反转控制（把bean的管理交给Spring实现），存储bean的容器实际上是Spring框架里面的一个成员变量map&lt;beanName, bean&gt;</strong></p><p><strong>DI 依赖注入，是bean管理中的一个重要的环节，当初始化的注入属性环节需要使用，涉及到循环依赖问题的解决</strong></p><p>优点：代码解耦（不用自己new），单例模式（如果需要），不用关注创建的细节（属性注入）</p><p>实现：从 xml 文件或者通过@xxx注解方式将bean注入到IOC容器内（一个HashMap，&lt;beanName, bean&gt;）</p><p><strong>AOP如何实现的？</strong></p><p>面向切面编程，对方法的拓展</p><p>优点：</p><p>实现：代理模式实现，JDK原生的动态代理或者Cglib的动态代理</p><p><strong>属性注入以及Spring如何解决循环依赖的？</strong></p><p>Spring有两种方式进行属性注入，setter和构造器</p><ul><li>setter方式出现的循环依赖：三级缓存</li><li>构造器方式出现的循环依赖：@Lazy 标记在类上，表示类会延迟初始化</li></ul><p><strong>bean的生命周期？</strong></p><p><strong>事务？</strong></p><p><strong>springboot的启动流程？</strong></p><h1 id="涉及的设计模式"><a href="#涉及的设计模式" class="headerlink" title="涉及的设计模式"></a>涉及的设计模式</h1><h1 id="源码整体架构"><a href="#源码整体架构" class="headerlink" title="源码整体架构"></a>源码整体架构</h1><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20231208202836925.png" alt="image-20231208202836925"></p><ol><li><strong>spring-aop</strong>：切面编程</li><li><strong>spring-aspects</strong>：实现AspectJ框架的集成，生成增强后的Class文件</li><li><strong>spring-beans</strong>：定义了大量和Bean有关的接口，类及注解，BeanDefinition、BeanFactory、@Autowired&#x2F;Qualifier&#x2F;Value</li><li><strong>spring-context</strong>：Spring的上下文，ApplicationContext接口</li><li>spring-context-indexer：加快启动速度</li><li>spring-context-support：Spring上下文的一些扩展模块，例如实现邮件服务、视图解析、缓存</li><li><strong>spring-core</strong>：Spring的核心功能，控制反转(IOC)、依赖注入(DI)、asm以及cglib的实现</li><li>spring-expression：提供Spring表达式语言的支持，SPEL</li><li>spring-framework-bom：解决Spring中的模块与其他框架整合时产生jar包版本的冲突</li><li><strong>spring-instrument</strong>：实现的是类级别或者ClassLoader级别的代理功能</li><li>spring-jcl：统一管理日志的框架</li><li>spring-jdbc：模板设计模式将数据库的操作和具体业务分离</li><li>spring-jms：对Java消息服务的支持</li><li>spring-messaging：实现基于消息来构建服务的功能</li><li>spring-orm：支持与第三方ORM框架进行整合，例如：MyBatis，Hibernate，Spring JPA等</li><li><strong>spring-oxm</strong>：完成xml和object对象的相互转换</li><li>spring-test：Spring对Junit测试框架的简单封装</li><li>spring-tx：声明式事务或者编程式事务支持，例如：Hibernate，MyBatis，JPA等</li><li>spring-web：用来支持Web系统的功能，例如：文件上传，与JSF的集成，过滤器Filter的支持等</li><li>spring-webflux：响应式编程来实现web功能的框架</li><li>spring-webmvc：包括了和SpringMVC框架相关的所有类或者接口</li><li>spring-websocket：Spring对websocket的简单封装</li></ol><h1 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h1><p><strong>bean声明</strong></p><p>类上：@Component、@Controller、@Service、@Reposity、@Configuration</p><p>方法上：@bean</p><p><strong>注入方式</strong></p><p>@Autowired、@Resource</p><p><strong>初始化调用</strong></p><p>@PostConstructor（初始化阶段，在构造函数执行之后执行）</p><h1 id="核心接口和类"><a href="#核心接口和类" class="headerlink" title="核心接口和类"></a>核心接口和类</h1><h2 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h2><p><strong>资源Resource类型</strong></p><ul><li>File</li><li>URL</li><li>ClassPath</li></ul><h2 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h2><p>bean的定义信息</p><h2 id="ResourceLoader"><a href="#ResourceLoader" class="headerlink" title="ResourceLoader"></a>ResourceLoader</h2><p>加载Resource成BeanDefinition</p><h2 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h2><p>HierarchicalBeanFactory：只是定义了父子关系，作用不大</p><p>AutowireCapableBeanFactory：自动装配</p><p>ListableBeanFactory：实现是DefaultListableBeanFactory，档案馆，保存了BeanDefinition，底层是map（beanName -&gt; BeanDefinition）</p><h1 id="项目启动过程"><a href="#项目启动过程" class="headerlink" title="项目启动过程"></a>项目启动过程</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">AnnotationConfigApplicationContext</span><span class="params">(Class&lt;?&gt;... componentClasses)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建 reader，加载 Spring 内置的一些后置处理器的 BeanDefinition，还有创建 scanner</span></span><br><span class="line">    <span class="built_in">this</span>();</span><br><span class="line">    <span class="comment">// 注册用户自己添加的配置类的 BeanDefinition</span></span><br><span class="line">    register(componentClasses);</span><br><span class="line">    <span class="comment">// 刷新 BeanFactory</span></span><br><span class="line">    refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="refresh-12大步"><a href="#refresh-12大步" class="headerlink" title="refresh() 12大步"></a>refresh() 12大步</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 重点1</span><br><span class="line">invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">// 重点2</span><br><span class="line">finishBeanFactoryInitialization(beanFactory);</span><br></pre></td></tr></table></figure><h1 id="bean创建流程和生命周期"><a href="#bean创建流程和生命周期" class="headerlink" title="bean创建流程和生命周期"></a>bean创建流程和生命周期</h1><p>bean的生命周期包括创建、使用、销毁</p><p>我们具体关注创建流程，通过xml文件或者注解的方式拿到bean的定义信息，通过bean的定义信息完成bean的创建流程</p><p><strong>bean创建流程如下</strong></p><ol><li>获取bean的定义信息BeanDefinition（xml方式或者注解方式）</li><li>实例化bean</li><li>初始化bean<ol><li>属性赋值</li><li>BeanPostProcessor前置处理</li><li>执行初始化方法</li><li>BeanPostProcessor后置处理</li></ol></li></ol><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20231215210630926.png" alt="image-20231215210630926"></p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20231215210655571.png" alt="image-20231215210655571"></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Sharding-JDBC</title>
      <link href="/forworl.github.io/2023/12/20/Sharding-JDBC/"/>
      <url>/forworl.github.io/2023/12/20/Sharding-JDBC/</url>
      
        <content type="html"><![CDATA[<h1 id="分库分表的几种方式"><a href="#分库分表的几种方式" class="headerlink" title="分库分表的几种方式"></a>分库分表的几种方式</h1><p>垂直分表、垂直分库、水平分表、水平分库</p><h2 id="垂直分表"><a href="#垂直分表" class="headerlink" title="垂直分表"></a>垂直分表</h2><p>按照字段拆分，增加页内能存储的的行数据来减少IO的次数，以及减少对行锁竞争</p><h2 id="垂直分库"><a href="#垂直分库" class="headerlink" title="垂直分库"></a>垂直分库</h2><p>按照业务拆分，减少业务间的耦合，转库专用，不同业务的库可以部署在不同服务器减少对硬件资源的压力</p><h2 id="水平分库"><a href="#水平分库" class="headerlink" title="水平分库"></a>水平分库</h2><p>解决单库数据量大问题，把单库数据平摊到多个库，可以用ID取模或者hash确定数据在哪个数据库，减小单库的压力 </p><p><strong>和垂直分库对比</strong></p><p>垂直分库是根据业务把不同业务的表拆分到不同数据库</p><p>水平分库是把相同业务的表复制一份到不同数据库</p><h2 id="水平分表"><a href="#水平分表" class="headerlink" title="水平分表"></a>水平分表</h2><p>解决单表数据量大问题，把单表数据平摊到多个表，减小单表数据量，减少IO</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在系统设计的时候，就要根据需求，设计好垂直分库分表</p><p>在业务上线后，如果数据量增大，先考虑用缓存、读写分离、索引等方式优化，如果业务数据量持续增大，再考虑用水平分库分表</p><h1 id="分库分表带来的一些问题"><a href="#分库分表带来的一些问题" class="headerlink" title="分库分表带来的一些问题"></a>分库分表带来的一些问题</h1><h2 id="事务一致性问题"><a href="#事务一致性问题" class="headerlink" title="事务一致性问题"></a>事务一致性问题</h2><p>需要操作多个数据库的时候，需要分布式事务</p><h2 id="跨界点关联查询"><a href="#跨界点关联查询" class="headerlink" title="跨界点关联查询"></a>跨界点关联查询</h2><p>由于表在不同数据库内，在写SQL语句的时候无法通过联表查询</p><h2 id="跨节点分页、排序函数"><a href="#跨节点分页、排序函数" class="headerlink" title="跨节点分页、排序函数"></a>跨节点分页、排序函数</h2><p>由于表在不同数据库内，在写SQL语句的时候需要查询多次，在内存中排序</p><h2 id="主键避重"><a href="#主键避重" class="headerlink" title="主键避重"></a>主键避重</h2><p>不同数据库主键重复问题，分布式ID</p><h2 id="公共表"><a href="#公共表" class="headerlink" title="公共表"></a>公共表</h2><p>每个数据库都有一些公共表，公共表的数据一致性问题</p><h1 id="Sharding-JDBC流程"><a href="#Sharding-JDBC流程" class="headerlink" title="Sharding-JDBC流程"></a>Sharding-JDBC流程</h1><h2 id="SQL解析"><a href="#SQL解析" class="headerlink" title="SQL解析"></a>SQL解析</h2><p>将SQL语句根据单词拆分解析成语法树，树节点包括关键字、变量等</p><p>在这里就可以确定哪些是需要被替换的逻辑表</p><h2 id="SQL路由"><a href="#SQL路由" class="headerlink" title="SQL路由"></a>SQL路由</h2><p>将逻辑表映射到真实的物理节点</p><p>尽量使用分片键进行路由，WHERE条件包括 &#x3D; 、IN 、BETWEEN，否则会走全局路由（扫描所有库同名的所有表），联表的话不用分片键也会产生笛卡尔积</p><p>总的来说，分片键配合分片策略可以很好的减少SQL查询的行数，加快查询速度</p><h2 id="SQL改写"><a href="#SQL改写" class="headerlink" title="SQL改写"></a>SQL改写</h2><p>将逻辑表改写为真实表</p><p>如果有排序条件，将排序条件补充到查询条件中</p><h2 id="SQL执行"><a href="#SQL执行" class="headerlink" title="SQL执行"></a>SQL执行</h2><h3 id="内存限制模式"><a href="#内存限制模式" class="headerlink" title="内存限制模式"></a>内存限制模式</h3><p>不限制数据库连接数，多线程处理，加快查询速度</p><h3 id="连接限制模式"><a href="#连接限制模式" class="headerlink" title="连接限制模式"></a>连接限制模式</h3><p>限制数据库连接数，通常用于事务控制</p><h2 id="结果归并"><a href="#结果归并" class="headerlink" title="结果归并"></a>结果归并</h2><p>略</p><h1 id="如何编写分库分表配置文件"><a href="#如何编写分库分表配置文件" class="headerlink" title="如何编写分库分表配置文件"></a>如何编写分库分表配置文件</h1><p>配置数据源</p><p>配置主从关系</p>]]></content>
      
      
      <categories>
          
          <category> 分库分表 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leetcode</title>
      <link href="/forworl.github.io/2023/12/12/%E7%AE%97%E6%B3%95/"/>
      <url>/forworl.github.io/2023/12/12/%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="年度回顾"><a href="#年度回顾" class="headerlink" title="年度回顾"></a>年度回顾</h1><p><a href="https://leetcode.cn/rewind/2023/?source=discuss">力扣 Rewind’23 - 年度回顾 (leetcode.cn)</a></p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20231221191916111.png" alt="image-20231221191916111" style="zoom:50%;" /><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="一维"><a href="#一维" class="headerlink" title="一维"></a>一维</h2><h3 id="除自身以外数组的乘积"><a href="#除自身以外数组的乘积" class="headerlink" title="除自身以外数组的乘积"></a>除自身以外数组的乘积</h3><p><a href="https://leetcode.cn/problems/product-of-array-except-self/description/?envType=study-plan-v2&envId=top-100-liked">238. 除自身以外数组的乘积 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] productExceptSelf(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">    <span class="comment">// 数组的含义是当前位置左边或者右边的乘积</span></span><br><span class="line">    <span class="type">int</span>[] L = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">    <span class="type">int</span>[] R = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">    L[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        L[i] = L[i - <span class="number">1</span>] * nums[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    R[len - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        R[i] = R[i + <span class="number">1</span>] * nums[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        ans[i] = L[i] * R[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="下一个排列"><a href="#下一个排列" class="headerlink" title="下一个排列"></a>下一个排列</h3><p><a href="https://leetcode.cn/problems/next-permutation/description/">31. 下一个排列 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nextPermutation</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 3621 后往前找，找到第一个不是递增的3，找到第一个比前面大的6，交换</span></span><br><span class="line">    <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[i + <span class="number">1</span>])&#123;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[j])&#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(nums, i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> start, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        swap(nums, left, right);</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="按规则计算统计结果"><a href="#按规则计算统计结果" class="headerlink" title="按规则计算统计结果"></a>按规则计算统计结果</h3><p><a href="https://leetcode.cn/problems/gou-jian-cheng-ji-shu-zu-lcof/description/">LCR 191. 按规则计算统计结果 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] statisticalResult(<span class="type">int</span>[] arrayA) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arrayA.length == <span class="number">0</span>) <span class="keyword">return</span> arrayA;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arrayA.length;</span><br><span class="line">    <span class="comment">// 当前位置左边的所有乘积</span></span><br><span class="line">    <span class="type">int</span>[] L = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">    <span class="comment">// 当前位置右边的所有乘积</span></span><br><span class="line">    <span class="type">int</span>[] R = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">    L[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        L[i] = L[i - <span class="number">1</span>] * arrayA[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    R[len - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        R[i] = R[i + <span class="number">1</span>] * arrayA[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        ans[i] = L[i] * R[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组中重复的数据"><a href="#数组中重复的数据" class="headerlink" title="数组中重复的数据"></a>数组中重复的数据</h3><p><a href="https://leetcode.cn/problems/find-all-duplicates-in-an-array/description/">442. 数组中重复的数据 - 力扣（LeetCode）</a></p><p><strong>下标交换法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="comment">// 把每个数都放到下标位置，比如nums[0] = 4，那么看nums[3]是否是4，不是就交换</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (nums[i] != nums[nums[i] - <span class="number">1</span>]) &#123;</span><br><span class="line">            swap(nums, i, nums[i] - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果下标位置和对应的值不符合，就说明重复了</span></span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != nums[i] - <span class="number">1</span>) &#123;</span><br><span class="line">            res.add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> index1, <span class="type">int</span> index2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[index1];</span><br><span class="line">    nums[index1] = nums[index2];</span><br><span class="line">    nums[index2] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>负号标记法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> Math.abs(nums[i]);</span><br><span class="line">        <span class="comment">// 如果下标位置&gt;0，说明第一次遇到，把他标记为负号</span></span><br><span class="line">        <span class="keyword">if</span> (nums[x - <span class="number">1</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            nums[x - <span class="number">1</span>] = -nums[x - <span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则，加入结果集</span></span><br><span class="line">            res.add(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缺失的第一个正数"><a href="#缺失的第一个正数" class="headerlink" title="缺失的第一个正数"></a>缺失的第一个正数</h3><p><a href="https://leetcode.cn/problems/first-missing-positive/description/">41. 缺失的第一个正数 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">firstMissingPositive</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="comment">// 让 nums 里面的数字属于 [1~n]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// 第一个不存在的整数最大也就是 n + 1</span></span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt;= <span class="number">0</span>) nums[i] = n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// i 是下标</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// num 代表当前下标的数字绝对值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Math.abs(nums[i]);</span><br><span class="line">        <span class="comment">// 这个数字要当下标，就要 - 1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> num - <span class="number">1</span>;</span><br><span class="line">       <span class="comment">// 符合下标范围的就 负号</span></span><br><span class="line">        <span class="keyword">if</span>(index &lt; n)&#123;</span><br><span class="line">            nums[index] = -Math.abs(nums[index]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第一个不是负号的就是缺失的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 下标范围被占满了</span></span><br><span class="line">    <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在排序数组中查找元素的第一个和最后一个位置"><a href="#在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="在排序数组中查找元素的第一个和最后一个位置"></a>在排序数组中查找元素的第一个和最后一个位置</h3><p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/">34. 在排序数组中查找元素的第一个和最后一个位置 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    <span class="comment">// 找左值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> lowerBound(nums, target);</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= nums.length || nums[left] != target) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找右值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> lowerBound(nums, target + <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;left, right&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写法二：左闭右闭区间</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">lowerBound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 左闭右闭区间</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 相等就一直找最左的</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt;= target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写法二：左闭右开区间</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">lowerBound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length;</span><br><span class="line">    <span class="comment">// 左闭右开区间</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 相等就一直找最左的</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt;= target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二维"><a href="#二维" class="headerlink" title="二维"></a>二维</h2><h3 id="旋转图像"><a href="#旋转图像" class="headerlink" title="旋转图像"></a>旋转图像</h3><p><a href="https://leetcode.cn/problems/rotate-image/description/?envType=study-plan-v2&envId=top-100-liked">48. 旋转图像 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 左上-右下 对角交换</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; count; j++) &#123;</span><br><span class="line">            swap(matrix, i, j, j, i);</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 中间垂直线交换</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n / <span class="number">2</span>; j++) &#123;</span><br><span class="line">            swap(matrix, i, j, i, n - <span class="number">1</span> - j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> a1, <span class="type">int</span> b1, <span class="type">int</span> a2, <span class="type">int</span> b2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> matrix[a1][b1];</span><br><span class="line">    matrix[a1][b1] = matrix[a2][b2];</span><br><span class="line">    matrix[a2][b2] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="矩阵置零"><a href="#矩阵置零" class="headerlink" title="矩阵置零"></a>矩阵置零</h3><p><a href="https://leetcode.cn/problems/set-matrix-zeroes/description/?envType=study-plan-v2&envId=top-100-liked">73. 矩阵置零 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setZeroes</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">    <span class="comment">// 用第一行和第一列记录此行或者此列是否需要被修改</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flagRow0</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flagCol0</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//由于后面会被修改，所以提前记录好是否需要改变这一行或列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            flagCol0 = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix[<span class="number">0</span>][j] == <span class="number">0</span>) &#123;</span><br><span class="line">            flagRow0 = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 标记</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                matrix[<span class="number">0</span>][j] = matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 替换0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[<span class="number">0</span>][j] == <span class="number">0</span> || matrix[i][<span class="number">0</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">                matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 替换标志位</span></span><br><span class="line">    <span class="keyword">if</span> (flagCol0) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flagRow0) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h3><p><a href="https://leetcode.cn/problems/spiral-matrix/description/?utm_source=LCUS&utm_medium=ip_redirect&utm_campaign=transfer2china">54. 螺旋矩阵 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">spiralOrder</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="comment">// 四个变量控制</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> <span class="number">0</span>, bottom = m - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 剩余要打印的数字</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> m * n;</span><br><span class="line">    <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> left; j &lt;= right &amp;&amp; count &gt; <span class="number">0</span>; j++) &#123;</span><br><span class="line">            res.add(matrix[top][j]);</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">        top++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> top; i &lt;= bottom &amp;&amp; count &gt; <span class="number">0</span>; i++) &#123;</span><br><span class="line">            res.add(matrix[i][right]);</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">        right--;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> right; j &gt;= left &amp;&amp; count &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">            res.add(matrix[bottom][j]);</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">        bottom--;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> bottom; i &gt;= top &amp;&amp; count &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            res.add(matrix[i][left]);</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="搜索二维矩阵-II"><a href="#搜索二维矩阵-II" class="headerlink" title="搜索二维矩阵 II"></a>搜索二维矩阵 II</h3><p><a href="https://leetcode.cn/problems/search-a-2d-matrix-ii/description/">240. 搜索二维矩阵 II - 力扣（LeetCode）</a></p><p><strong>z字法</strong>：对某个节点来说，上边是小的，右边是大的，组成一个you’xu</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">searchMatrix</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> matrix.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 从左下角开始往右上角走</span></span><br><span class="line">    <span class="keyword">while</span> (row &gt;= <span class="number">0</span> &amp;&amp; col &lt; matrix[<span class="number">0</span>].length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix[row][col] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (matrix[row][col] &gt; target) &#123;</span><br><span class="line">            row--;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            col++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h3><p><a href="https://leetcode.cn/problems/merge-intervals/">56. 合并区间 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">    <span class="comment">// 合并区间，自然需要有序，两个元素，第一个有序</span></span><br><span class="line">    Arrays.sort(intervals, (v1, v2) -&gt; v1[<span class="number">0</span>] - v2[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span>[][] ans = <span class="keyword">new</span> <span class="title class_">int</span>[intervals.length][<span class="number">2</span>];</span><br><span class="line">    ans[<span class="number">0</span>] = intervals[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 当前答案区间的位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; intervals.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 合并，当前区间的左边界 &lt;= 答案区间的右边界 [1,6][3,4]</span></span><br><span class="line">        <span class="keyword">if</span> (ans[index][<span class="number">1</span>] &gt;= intervals[i][<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="comment">// 更换答案右边界</span></span><br><span class="line">            ans[index][<span class="number">1</span>] = Math.max(ans[index][<span class="number">1</span>], intervals[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不合并</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当前区间加入答案</span></span><br><span class="line">            ans[++index] = intervals[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOf(ans, index + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="字符串相加"><a href="#字符串相加" class="headerlink" title="字符串相加"></a>字符串相加</h2><p><a href="https://leetcode.cn/problems/add-strings/">415. 字符串相加 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">addStrings</span><span class="params">(String num1, String num2)</span> &#123;</span><br><span class="line">    <span class="comment">// 双指针，从后往前，需要一个进位标志</span></span><br><span class="line">    <span class="type">char</span>[] s1 = num1.toCharArray();</span><br><span class="line">    <span class="type">char</span>[] s2 = num2.toCharArray();</span><br><span class="line">    <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> s1.length - <span class="number">1</span>, p2 = s2.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">while</span> (p1 &gt;= <span class="number">0</span> || p2 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 短的字符串已经处理完了</span></span><br><span class="line">        <span class="keyword">if</span> (p1 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            num = s2[p2--] - <span class="string">&#x27;0&#x27;</span> + flag;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p2 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            num = s1[p1--] - <span class="string">&#x27;0&#x27;</span> + flag;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对位两数相加</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            num = s2[p2--] - <span class="string">&#x27;0&#x27;</span> + s1[p1--] - <span class="string">&#x27;0&#x27;</span> + flag;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取余，进位</span></span><br><span class="line">        <span class="keyword">if</span> (num &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            num %= <span class="number">10</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 添加到答案</span></span><br><span class="line">        ans.append(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 还有个进位要处理</span></span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">        ans.append(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans.reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h2><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p><p><strong>找不到原题了</strong></p><p><a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/description/">LCR 122. 路径加密 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 计算出有多少空格</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 申请char[]存储空间</span></span><br><span class="line">    <span class="type">char</span>[] res = <span class="keyword">new</span> <span class="title class_">char</span>[s.length() + <span class="number">2</span> * cnt];</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 遍历s ，空格替换</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">        <span class="keyword">if</span>(c != <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            res[index++] = c;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res[index++] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">            res[index++] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">            res[index++] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反转字符串中的单词"><a href="#反转字符串中的单词" class="headerlink" title="反转字符串中的单词"></a>反转字符串中的单词</h2><p><a href="https://leetcode.cn/problems/reverse-words-in-a-string/description/">151. 反转字符串中的单词 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="comment">// 用 Java 的 split 函数</span></span><br><span class="line">    String[] words = s.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> words.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">word</span> <span class="operator">=</span> words[i];</span><br><span class="line">        <span class="keyword">if</span> (!word.isEmpty()) &#123;</span><br><span class="line">            sb.append(word).append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="comment">// 用 Java 的 split 函数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> s.length() - <span class="number">1</span>, right = s.length();</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="comment">// 后往前遍历</span></span><br><span class="line">    <span class="keyword">while</span> (left &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 找单词</span></span><br><span class="line">        <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; s.charAt(left) != <span class="string">&#x27; &#x27;</span>) left--;</span><br><span class="line">        <span class="comment">// 此时left是空格</span></span><br><span class="line">        sb.append(s.substring(left + <span class="number">1</span>, right)).append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="comment">// 去除连续空格</span></span><br><span class="line">        <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; s.charAt(left) == <span class="string">&#x27; &#x27;</span>) left--;</span><br><span class="line">        right = left + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 结尾会多一个空格，开头可能也会多</span></span><br><span class="line">    <span class="keyword">return</span> sb.toString().trim();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h2><p><a href="https://leetcode.cn/problems/longest-palindromic-substring/description/">5. 最长回文子串 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="comment">// 两种可能</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> expandAroundCenter(s, i, i);</span><br><span class="line">        <span class="type">int</span> <span class="variable">len2</span> <span class="operator">=</span> expandAroundCenter(s, i, i + <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> Math.max(len1, len2);</span><br><span class="line">        <span class="comment">// 更新返回的区间</span></span><br><span class="line">        <span class="keyword">if</span> (len &gt; end - start + <span class="number">1</span>) &#123;</span><br><span class="line">            start = i - (len - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            end = i + len / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substring(start, end + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">expandAroundCenter</span><span class="params">(String s, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="comment">// 中心向两边遍历，直到两个字符不相等</span></span><br><span class="line">    <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) &#123;</span><br><span class="line">        left--;</span><br><span class="line">        right++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right - left - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p><strong>数组、set、map</strong></p><p>是否出现相同元素、同类元素、有某种关系的元素（如相加为x）</p><h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><p><a href="https://leetcode.cn/problems/two-sum/description/">1. 两数之和 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    <span class="comment">// hash表记录之前遍历过的</span></span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> target - nums[i];</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(x)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;map.get(x), i&#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="和为-K-的子数组（和两数之和相似）"><a href="#和为-K-的子数组（和两数之和相似）" class="headerlink" title="和为 K 的子数组（和两数之和相似）"></a>和为 K 的子数组（和两数之和相似）</h2><p>当前节点还要一次遍历，考虑用哈希表</p><p><a href="https://leetcode.cn/problems/subarray-sum-equals-k/?envType=study-plan-v2&envId=top-100-liked">560. 和为 K 的子数组 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarraySum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 和为0的数组有一个空的</span></span><br><span class="line">    map.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">preNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        preNum += num;</span><br><span class="line">        <span class="comment">// 某种关系</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> preNum - k;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(x)) &#123;</span><br><span class="line">            ans += map.get(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 维护哈希表</span></span><br><span class="line">        map.put(preNum, map.getOrDefault(preNum, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="路径总和-III"><a href="#路径总和-III" class="headerlink" title="路径总和 III"></a>路径总和 III</h2><p><a href="https://leetcode.cn/problems/path-sum-iii/description/?envType=study-plan-v2&envId=top-100-liked">437. 路径总和 III - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">    <span class="comment">// 当前所有的前缀和</span></span><br><span class="line">    Map&lt;Long, Integer&gt; prefix = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Long, Integer&gt;();</span><br><span class="line">    <span class="comment">// 用来判断根节点是否自己是一个路径</span></span><br><span class="line">    prefix.put(<span class="number">0L</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> dfs(root, prefix, <span class="number">0</span>, targetSum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从下往上计算，路径和是当前节点前缀和-之前的某个节点的前缀和</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, Map&lt;Long, Integer&gt; prefix, <span class="type">long</span> curr, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cur是当前的前缀和</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    curr += root.val;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算当前节点的前缀和是否符合条件</span></span><br><span class="line">    ret = prefix.getOrDefault(curr - targetSum, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 加入前缀和</span></span><br><span class="line">    prefix.put(curr, prefix.getOrDefault(curr, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 加上左右子树的答案</span></span><br><span class="line">    ret += dfs(root.left, prefix, curr, targetSum);</span><br><span class="line">    ret += dfs(root.right, prefix, curr, targetSum);</span><br><span class="line">    <span class="comment">// 退出前缀和</span></span><br><span class="line">    prefix.put(curr, prefix.getOrDefault(curr, <span class="number">0</span>) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字母异位词分组"><a href="#字母异位词分组" class="headerlink" title="字母异位词分组"></a>字母异位词分组</h2><p><a href="https://leetcode.cn/problems/group-anagrams/description/?envType=study-plan-v2&envId=top-100-liked">49. 字母异位词分组 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">    <span class="comment">// map存放（排序后的字符串，所有字母异位词的集合）</span></span><br><span class="line">    <span class="keyword">final</span> HashMap&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">        <span class="comment">// 转成数组排序</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">char</span>[] array = str.toCharArray();</span><br><span class="line">        <span class="type">String</span> <span class="variable">oldArray</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(array);</span><br><span class="line">        Arrays.sort(array);</span><br><span class="line">        List&lt;String&gt; strings = map.get(<span class="keyword">new</span> <span class="title class_">String</span>(array));</span><br><span class="line">        <span class="keyword">if</span> (strings == <span class="literal">null</span>) &#123;</span><br><span class="line">            strings = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        strings.add(oldArray);</span><br><span class="line">        map.put(<span class="keyword">new</span> <span class="title class_">String</span>(array), strings);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    map.forEach((key, value) -&gt; &#123;</span><br><span class="line">        res.add(map.get(key));</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长连续序列"><a href="#最长连续序列" class="headerlink" title="最长连续序列"></a>最长连续序列</h2><p><a href="https://leetcode.cn/problems/longest-consecutive-sequence/description/?envType=study-plan-v2&envId=top-100-liked">128. 最长连续序列 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestConsecutive</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="comment">// 数组转成set，方便后续查找</span></span><br><span class="line">    <span class="keyword">final</span> HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        set.add(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">longestStreak</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">currentNum</span> <span class="operator">=</span> num;</span><br><span class="line">        <span class="comment">// 遍历set，如果没有比当前值小1的值，就继续往后遍历，HashSet查找</span></span><br><span class="line">        <span class="keyword">if</span> (!set.contains(num - <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">currentStreak</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (set.contains(currentNum + <span class="number">1</span>)) &#123;</span><br><span class="line">                currentNum += <span class="number">1</span>;</span><br><span class="line">                currentStreak += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            longestStreak = Math.max(longestStreak, currentStreak);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> longestStreak;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串中的第一个唯一字符"><a href="#字符串中的第一个唯一字符" class="headerlink" title="字符串中的第一个唯一字符"></a>字符串中的第一个唯一字符</h2><p><a href="https://leetcode.cn/problems/first-unique-character-in-a-string/description/">387. 字符串中的第一个唯一字符 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">firstUniqChar</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">char</span>[] dictionary = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line">    <span class="comment">// 遍历两次，第二次就知道字母是否有重复了，&gt;1 就是重复</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : chars) &#123;</span><br><span class="line">        dictionary[c - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dictionary[chars[i] - <span class="string">&#x27;a&#x27;</span>] == <span class="number">1</span>) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="栈、队列"><a href="#栈、队列" class="headerlink" title="栈、队列"></a>栈、队列</h1><p>单调栈有感，一个是接雨水维护单调递减的栈，一个是计算矩形最大面积维护单调递增的栈，两者都可以从某个柱子往左往右找到更大或者更小的值，这样就会形成凹槽或者突起，那么单调栈可以降低时间复杂度到O(n)，用空间换取时间，每次元素的出栈，都意味着这个元素的右边是第一个更大&#x2F;更小的元素，弹出后的栈顶元素是左边是第一个更大&#x2F;更小的元素，这样就可以计算了。</p><h2 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h2><p><a href="https://leetcode.cn/problems/implement-queue-using-stacks/description/">232. 用栈实现队列 - 力扣（LeetCode）</a></p><p>用s1作为主栈，s2为辅助栈</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"></span><br><span class="line">    Stack&lt;Integer&gt; S1, S2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        S1 = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">        S2 = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        S1.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(!S1.isEmpty())&#123;</span><br><span class="line">            S2.push(S1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> S2.pop();</span><br><span class="line">        <span class="keyword">while</span>(!S2.isEmpty())&#123;</span><br><span class="line">            S1.push(S2.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(!S1.isEmpty())&#123;</span><br><span class="line">            S2.push(S1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> S2.peek();</span><br><span class="line">        <span class="keyword">while</span>(!S2.isEmpty())&#123;</span><br><span class="line">            S1.push(S2.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> S1.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h2><p><a href="https://leetcode.cn/problems/valid-parentheses/description/">20. 有效的括号 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line">    <span class="comment">// 用栈的特性，或者快慢指针也行应该</span></span><br><span class="line">    Stack&lt;Character&gt; S = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    HashMap&lt;Character, Character&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">    map.put(<span class="string">&#x27;(&#x27;</span>, <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">    map.put(<span class="string">&#x27;[&#x27;</span>, <span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">    map.put(<span class="string">&#x27;&#123;&#x27;</span>, <span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : chars) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span> || c == <span class="string">&#x27;[&#x27;</span> || c == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">            S.push(c);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(S.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">Character</span> <span class="variable">popC</span> <span class="operator">=</span> S.pop();</span><br><span class="line">                <span class="keyword">if</span> (!map.get(popC).equals(c)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> S.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h2><p><a href="https://leetcode.cn/problems/trapping-rain-water/description/">42. 接雨水 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">    <span class="comment">// 维护一个单调递减的栈，存放下标</span></span><br><span class="line">    Stack&lt;Integer&gt; S = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">    S.push(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 返回值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 循环遍历每个柱子</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; height.length; i++) &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">top</span> <span class="operator">=</span> S.peek();</span><br><span class="line">        <span class="comment">// 发现柱子高度比栈顶元素小，加入栈</span></span><br><span class="line">        <span class="keyword">if</span> (height[i] &lt; height[top]) &#123;</span><br><span class="line">            S.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 高度相同，取右边的柱子计算</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (height[i] == height[top]) &#123;</span><br><span class="line">            S.pop();</span><br><span class="line">            S.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 大于说明有坑，则弹出栈顶元素为底部，开始计算横向，底部和两边的最小差值和左右两边距离的乘积</span></span><br><span class="line">        <span class="comment">// 循环计算，一直到栈顶元素比当前柱子高，才说明没有坑了</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(!S.isEmpty() &amp;&amp; height[i] &gt; height[S.peek()])&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> S.pop();</span><br><span class="line">                <span class="keyword">if</span>(!S.isEmpty())&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> S.peek();</span><br><span class="line">                    <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> i - left - <span class="number">1</span>;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> Math.min(height[i], height[left]) - height[mid];</span><br><span class="line">                    sum += width * high;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            S.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最小栈"><a href="#最小栈" class="headerlink" title="最小栈"></a>最小栈</h2><p><a href="https://leetcode.cn/problems/min-stack/description/">155. 最小栈 - 力扣（LeetCode）</a></p><p><strong>辅助栈</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再用一个存放最小值的栈</span></span><br><span class="line">    <span class="comment">// 如果在栈内存放一个值，那么需要判断是否是当前所有元素中最小的</span></span><br><span class="line">    <span class="comment">// 如果在栈弹出一个值，那么直接弹出就好了，因为下一层的最小值和本层无关</span></span><br><span class="line">    <span class="comment">// 最小栈每层代表的是当前层往前的元素的最小值</span></span><br><span class="line"></span><br><span class="line">    Deque&lt;Integer&gt; xStack;</span><br><span class="line">    Deque&lt;Integer&gt; minStack;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> &#123;</span><br><span class="line">        xStack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        minStack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        minStack.push(Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        xStack.push(val);</span><br><span class="line">        minStack.push(Math.min(minStack.peek(), val));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        xStack.pop();</span><br><span class="line">        minStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> xStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>辅助数字代替辅助栈</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"></span><br><span class="line">    Deque&lt;Integer&gt; xStack;</span><br><span class="line">    <span class="comment">// 用一个数字代替最小栈</span></span><br><span class="line">    <span class="comment">// 当push的时候看看当前值，如果比最小值小，那么需要记录下最小值（也就是在push当前值之前先push最小值）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> &#123;</span><br><span class="line">        xStack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="comment">// 当前值更小</span></span><br><span class="line">        <span class="keyword">if</span>(val &lt;= min)&#123;   </span><br><span class="line">            <span class="comment">// 将之前的最小值保存</span></span><br><span class="line">            xStack.push(min);</span><br><span class="line">            <span class="comment">// 更新最小值</span></span><br><span class="line">            min = val;</span><br><span class="line">        &#125;</span><br><span class="line">        xStack.push(val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> xStack.pop();</span><br><span class="line">        <span class="comment">// 如果当前是最小值，说明还需要再pop一个，看push就懂了</span></span><br><span class="line">        <span class="keyword">if</span>(val == min)&#123;</span><br><span class="line">            min = xStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> xStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="验证栈序列"><a href="#验证栈序列" class="headerlink" title="验证栈序列"></a>验证栈序列</h2><p><a href="https://leetcode.cn/problems/validate-stack-sequences/description/?utm_source=LCUS&utm_medium=ip_redirect&utm_campaign=transfer2china">946. 验证栈序列 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validateStackSequences</span><span class="params">(<span class="type">int</span>[] pushed, <span class="type">int</span>[] popped)</span> &#123;</span><br><span class="line">    Stack&lt;Integer&gt; S = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> pushed.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 模拟栈的弹出</span></span><br><span class="line">    <span class="comment">// 一直加，直到当前 pushed[] 的元素 == popped[] 位置的元素，说明要弹出了</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        S.push(pushed[i]);</span><br><span class="line">        <span class="keyword">while</span> (!S.isEmpty() &amp;&amp; S.peek() == popped[j])&#123;</span><br><span class="line">            S.pop();</span><br><span class="line">            <span class="comment">// 更换下次比较的元素</span></span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> S.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="重排链表"><a href="#重排链表" class="headerlink" title="重排链表"></a>重排链表</h2><p><a href="https://leetcode.cn/problems/reorder-list/description/">143. 重排链表 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reorderList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1.找到中点 mid</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head, fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast.next != <span class="literal">null</span> &amp;&amp; fast.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">mid</span> <span class="operator">=</span> slow;</span><br><span class="line">    <span class="comment">// 2.反转后半链表</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">l1</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">l2</span> <span class="operator">=</span> mid.next;</span><br><span class="line">    mid.next = <span class="literal">null</span>;</span><br><span class="line">    l2 = reverseList(l2);</span><br><span class="line">    <span class="comment">// 3.合并链表</span></span><br><span class="line">    mergeList(l1, l2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">mergeList</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">    ListNode p1, p2;</span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 记住下一个</span></span><br><span class="line">        p1 = l1.next;</span><br><span class="line">        p2 = l2.next;</span><br><span class="line">        <span class="comment">// 连接</span></span><br><span class="line">        l1.next = l2;</span><br><span class="line">        l2.next = p1;</span><br><span class="line">        <span class="comment">// 移动指针</span></span><br><span class="line">        l2 = p2;</span><br><span class="line">        l1 = p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">nex</span> <span class="operator">=</span> cur.next;</span><br><span class="line">        cur.next = prev;</span><br><span class="line">        prev = cur;</span><br><span class="line">        cur = nex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="相交链表"><a href="#相交链表" class="headerlink" title="相交链表"></a>相交链表</h2><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/description/">160. 相交链表 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (headA == <span class="literal">null</span> || headB == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pA</span> <span class="operator">=</span> headA, pB = headB;</span><br><span class="line">    <span class="comment">// 两个指针同时遍历，空了就从对方头重新走一遍对方的路，终会遇见</span></span><br><span class="line">    <span class="keyword">while</span> (pA != pB) &#123;</span><br><span class="line">        pA = pA == <span class="literal">null</span> ? pB : pA.next;</span><br><span class="line">        pB = pB == <span class="literal">null</span> ? pA : pB.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 相遇或者走完两个链表最后到了null</span></span><br><span class="line">    <span class="keyword">return</span> pA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h2><p><a href="https://leetcode.cn/problems/linked-list-cycle/description/">141. 环形链表 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        <span class="keyword">if</span> (slow == fast) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="环形链表-II"><a href="#环形链表-II" class="headerlink" title="环形链表 II"></a>环形链表 II</h2><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/description/">142. 环形链表 II - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">// 环结构都可以用快慢指针，满指针一次走一步，快指针一次走两步</span></span><br><span class="line">    <span class="comment">// 数学推导，当快慢指针第一次相遇，只需要让两个指针，一个从起点开始走，一个从相遇点开始走，两个指针会在环的入口相遇</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head, fast = head;</span><br><span class="line">    <span class="comment">// while循环的条件，首先是考虑遍历链表，即会不会无环</span></span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;  </span><br><span class="line">        <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">p2</span> <span class="operator">=</span> slow;</span><br><span class="line">            <span class="keyword">while</span> (p1 != p2) &#123;</span><br><span class="line">                p1 = p1.next;</span><br><span class="line">                p2 = p2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> p1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除链表中的节点（特殊）"><a href="#删除链表中的节点（特殊）" class="headerlink" title="删除链表中的节点（特殊）"></a>删除链表中的节点（特殊）</h2><p><a href="https://leetcode.cn/problems/delete-node-in-a-linked-list/submissions/488467568/">237. 删除链表中的节点 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteNode</span><span class="params">(ListNode node)</span> &#123;</span><br><span class="line">    <span class="comment">// 把后一个节点的值赋给自己</span></span><br><span class="line">    node.val = node.next.val;</span><br><span class="line">    <span class="comment">// 此时只需要假装自己是下一个节点，把下一个节点当成自己，把自己删掉就好了</span></span><br><span class="line">    node.next = node.next.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除排序链表中的重复元素-II"><a href="#删除排序链表中的重复元素-II" class="headerlink" title="删除排序链表中的重复元素 II"></a>删除排序链表中的重复元素 II</h2><p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/">82. 删除排序链表中的重复元素 II - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// prev用来删除元素</span></span><br><span class="line">    <span class="comment">// slow作为基准对比元素是否需要删除</span></span><br><span class="line">    <span class="comment">// fast用来遍历</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">hair</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">    hair.next = head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> hair;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head, fast = head.next;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isDelete</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; slow.val == fast.val) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            isDelete = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此时 slow 和 fast 不同</span></span><br><span class="line">        <span class="comment">// 确定是否需要删除</span></span><br><span class="line">        <span class="keyword">if</span> (isDelete) &#123;</span><br><span class="line">   <span class="comment">// 此时前驱节点不用变化</span></span><br><span class="line">            prev.next = fast;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 此时前驱节点需要往后一位</span></span><br><span class="line">            prev = slow;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新基准</span></span><br><span class="line">        slow = fast;</span><br><span class="line">        <span class="comment">// 指针移动</span></span><br><span class="line">        <span class="keyword">if</span>(fast != <span class="literal">null</span>) fast = fast.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hair.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><p><a href="https://leetcode.cn/problems/reverse-linked-list/submissions/489138910/">206. 反转链表 - 力扣（LeetCode）</a></p><p><strong>迭代法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">// 三指针，prev，cur，nex</span></span><br><span class="line">    <span class="comment">// cur -&gt; nex 要转成 cur -&gt; prev</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">nex</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 记录cur的下一个节点，否则无法继续反转</span></span><br><span class="line">        nex = cur.next;</span><br><span class="line">        <span class="comment">// 反转</span></span><br><span class="line">        cur.next = prev;</span><br><span class="line">        <span class="comment">// 指针移动，执行下一次反转</span></span><br><span class="line">        prev = cur;</span><br><span class="line">        cur = nex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>递归法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> reverseList(<span class="literal">null</span>, head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode p1, ListNode p2)</span> &#123;</span><br><span class="line">        <span class="comment">// 没有下一个节点，返回当前节点</span></span><br><span class="line">        <span class="keyword">if</span> (p2 == <span class="literal">null</span>) <span class="keyword">return</span> p1;</span><br><span class="line">        <span class="comment">// 记录cur的下一个节点，否则无法继续递归反转</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">nex</span> <span class="operator">=</span> p2.next;</span><br><span class="line">        <span class="comment">// 每次都让后面的指向前面的就好了，即 p2 -&gt; p1</span></span><br><span class="line">        p2.next = p1;</span><br><span class="line">        <span class="keyword">return</span> reverseList(p2, nex);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="反转链表-II"><a href="#反转链表-II" class="headerlink" title="反转链表 II"></a>反转链表 II</h2><p><a href="https://leetcode.cn/problems/reverse-linked-list-ii/description/">92. 反转链表 II - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">hair</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">    hair.next = head;</span><br><span class="line">    <span class="comment">// 一个前驱节点，一个后继节点，方便连接反转后的链表</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> hair, nex = <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> hair;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 循环结束， p == left</span></span><br><span class="line">    <span class="keyword">while</span> (count &lt; left) &#123;</span><br><span class="line">        prev = p;</span><br><span class="line">        p = p.next;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 反转的子链表的左边开头</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">start</span> <span class="operator">=</span> p;</span><br><span class="line">    <span class="comment">// 循环结束， p == right</span></span><br><span class="line">    <span class="keyword">while</span> (count &lt; right) &#123;</span><br><span class="line">        p = p.next;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 反转的子链表的右边结尾</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">end</span> <span class="operator">=</span> p;</span><br><span class="line">    nex = end.next;</span><br><span class="line">    <span class="comment">// 断开连接</span></span><br><span class="line">    prev.next = <span class="literal">null</span>;</span><br><span class="line">    reverse(start, end);</span><br><span class="line">    prev.next = end;</span><br><span class="line">    start.next = nex;</span><br><span class="line">    <span class="keyword">return</span> hair.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(ListNode leftNode, ListNode rightNode)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> leftNode;</span><br><span class="line">    ListNode nex;</span><br><span class="line">    <span class="keyword">while</span> (pre != rightNode) &#123;</span><br><span class="line">        nex = cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = nex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="K-个一组翻转链表"><a href="#K-个一组翻转链表" class="headerlink" title="K 个一组翻转链表"></a>K 个一组翻转链表</h2><p><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">hair</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="comment">// 子链表的开头、结尾</span></span><br><span class="line">    ListNode start, end;</span><br><span class="line">    <span class="comment">// 用于前后连接 反转后的子链表</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> hair, nex;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">        start = p;</span><br><span class="line">        <span class="comment">// 找到一组需要反转的子链表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            p = p.next;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> hair.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        end = p;</span><br><span class="line">        nex = end.next;</span><br><span class="line">        <span class="comment">// 反转子链表</span></span><br><span class="line">        reverse(start, end);</span><br><span class="line">        <span class="comment">// 这里 end -&gt; ... -&gt; start -&gt; null</span></span><br><span class="line">        start.next = nex;</span><br><span class="line">        prev.next = end;</span><br><span class="line">        <span class="comment">// 移动指针，下一轮循环</span></span><br><span class="line">        prev = start;</span><br><span class="line">        p = start.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hair.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(ListNode head, ListNode tail)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    ListNode nex;</span><br><span class="line">    <span class="keyword">while</span> (prev != tail) &#123;</span><br><span class="line">        nex = cur.next;</span><br><span class="line">        cur.next = prev;</span><br><span class="line">        prev = cur;</span><br><span class="line">        cur = nex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="随机链表的复制"><a href="#随机链表的复制" class="headerlink" title="随机链表的复制"></a>随机链表的复制</h2><p><a href="https://leetcode.cn/problems/copy-list-with-random-pointer/description/">138. 随机链表的复制 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// cur是用来遍历的指针</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="comment">// 第一次遍历把 1 -&gt; 2 -&gt; 3 变成 1 -&gt; 1&#x27; -&gt; 2 -&gt; 2&#x27; -&gt; 3 -&gt; 3&#x27;</span></span><br><span class="line">    <span class="comment">// 此时 next指针已经复制完成，还差 random指针</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">nex</span> <span class="operator">=</span> cur.next;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(cur.val);</span><br><span class="line">        cur.next = newNode;</span><br><span class="line">        newNode.next = nex;</span><br><span class="line">        cur = nex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第二次遍历搞定复制 random指针</span></span><br><span class="line">    cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.random != <span class="literal">null</span>) cur.next.random = cur.random.next;</span><br><span class="line">        cur = cur.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 分离链表</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">hair</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(-<span class="number">1</span>);</span><br><span class="line">    <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> hair;</span><br><span class="line">    cur = head;</span><br><span class="line">    <span class="comment">// cur指向1，p指向1‘，交替向后分离</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        p.next = cur.next;</span><br><span class="line">        p = cur.next;</span><br><span class="line">        cur.next = p.next;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hair.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Hash表法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建一个哈希表，key是原节点，value是新节点</span></span><br><span class="line">    Map&lt;Node,Node&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Node,Node&gt;();</span><br><span class="line">    <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="comment">//将原节点和新节点放入哈希表中</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(p.val);</span><br><span class="line">        map.put(p,newNode);</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    p = head;</span><br><span class="line">    <span class="comment">//遍历原链表，设置新节点的next和random</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> map.get(p);</span><br><span class="line">        <span class="comment">//p是原节点，map.get(p)是对应的新节点，p.next是原节点的下一个</span></span><br><span class="line">        <span class="comment">//map.get(p.next)是原节点下一个对应的新节点</span></span><br><span class="line">        <span class="keyword">if</span>(p.next!=<span class="literal">null</span>) &#123;</span><br><span class="line">            newNode.next = map.get(p.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//p.random是原节点随机指向</span></span><br><span class="line">        <span class="comment">//map.get(p.random)是原节点随机指向  对应的新节点 </span></span><br><span class="line">        <span class="keyword">if</span>(p.random!=<span class="literal">null</span>) &#123;</span><br><span class="line">            newNode.random = map.get(p.random);</span><br><span class="line">        &#125;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回头结点，即原节点对应的value(新节点)</span></span><br><span class="line">    <span class="keyword">return</span> map.get(head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h2><p><a href="https://leetcode.cn/problems/merge-two-sorted-lists/description/?utm_source=LCUS&utm_medium=ip_redirect&utm_campaign=transfer2china">21. 合并两个有序链表 - 力扣（LeetCode）</a></p><p><strong>递归法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode list1, ListNode list2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (list2 == <span class="literal">null</span>) <span class="keyword">return</span> list1;</span><br><span class="line">    <span class="keyword">if</span> (list1 == <span class="literal">null</span>) <span class="keyword">return</span> list2;</span><br><span class="line">    <span class="keyword">if</span> (list1.val &lt; list2.val) &#123;</span><br><span class="line">        list1.next = mergeTwoLists(list1.next, list2);</span><br><span class="line">        <span class="keyword">return</span> list1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        list2.next = mergeTwoLists(list1, list2.next);</span><br><span class="line">        <span class="keyword">return</span> list2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>迭代法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode list1, ListNode list2)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">hair</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> hair;</span><br><span class="line">    <span class="comment">// 比较，然后小的给新链表</span></span><br><span class="line">    <span class="keyword">while</span> (list1 != <span class="literal">null</span> &amp;&amp; list2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (list1.val &lt; list2.val) &#123;</span><br><span class="line">            cur.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(list1.val);</span><br><span class="line">            list1 = list1.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(list2.val);</span><br><span class="line">            list2 = list2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (list1 != <span class="literal">null</span>) cur.next = list1;</span><br><span class="line">    <span class="keyword">if</span> (list2 != <span class="literal">null</span>) cur.next = list2;</span><br><span class="line">    <span class="keyword">return</span> hair.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合并-K-个升序链表"><a href="#合并-K-个升序链表" class="headerlink" title="合并 K 个升序链表"></a>合并 K 个升序链表</h2><p><a href="https://leetcode.cn/problems/merge-k-sorted-lists/description/">23. 合并 K 个升序链表 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> merge(lists, <span class="number">0</span>, lists.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ListNode <span class="title function_">merge</span><span class="params">(ListNode[] lists, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> lists[l];</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 用自底向上的归并排序</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">leftMerge</span> <span class="operator">=</span> merge(lists, l, mid);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">rightMerge</span> <span class="operator">=</span> merge(lists, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">return</span> mergeTwoList(leftMerge, rightMerge);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 合并两个有序链表</span></span><br><span class="line"><span class="keyword">private</span> ListNode <span class="title function_">mergeTwoList</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="literal">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span> (l2 == <span class="literal">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">    <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">        l1.next = mergeTwoList(l1.next, l2);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l2.next = mergeTwoList(l1, l2.next);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="排序链表"><a href="#排序链表" class="headerlink" title="排序链表"></a>排序链表</h2><p><a href="https://leetcode.cn/problems/sort-list/submissions/498067921/">148. 排序链表 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 自底向上归并排序</span></span><br><span class="line">    <span class="comment">// 获取链表长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">        p = p.next;</span><br><span class="line">        length++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">hair</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">    hair.next = head;</span><br><span class="line">    <span class="comment">// 每次合并两个子链表，子链表长度每次 * 2</span></span><br><span class="line">    <span class="comment">// len是当前合并的每条子链表的长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>; len &lt; length; len *= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> hair, cur = hair.next;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">l1</span> <span class="operator">=</span> cur;</span><br><span class="line">            <span class="comment">// 找到第一个子链表尾巴</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len &amp;&amp; cur.next != <span class="literal">null</span>; i++) &#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">l2</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            <span class="comment">// 避免影响合并，断开连接</span></span><br><span class="line">            cur.next = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 找到第二个子链表尾巴</span></span><br><span class="line">            cur = l2;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len &amp;&amp; cur != <span class="literal">null</span> &amp;&amp; cur.next != <span class="literal">null</span>; i++) &#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">nex</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 避免影响合并，断开连接</span></span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">                nex = cur.next;</span><br><span class="line">                cur.next = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 合并完连接到前驱节点</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">merged</span> <span class="operator">=</span> merge(l1, l2);</span><br><span class="line">            prev.next = merged;</span><br><span class="line">            <span class="comment">// 移动前驱节点</span></span><br><span class="line">            <span class="keyword">while</span> (prev.next != <span class="literal">null</span>) &#123;</span><br><span class="line">                prev = prev.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 移动指针，下一次合并</span></span><br><span class="line">            cur = nex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hair.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 合并有序链表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> ListNode <span class="title function_">merge</span><span class="params">(ListNode head1, ListNode head2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head1 == <span class="literal">null</span>) <span class="keyword">return</span> head2;</span><br><span class="line">    <span class="keyword">if</span> (head2 == <span class="literal">null</span>) <span class="keyword">return</span> head1;</span><br><span class="line">    <span class="keyword">if</span> (head1.val &lt;= head2.val) &#123;</span><br><span class="line">        head1.next = merge(head1.next, head2);</span><br><span class="line">        <span class="keyword">return</span> head1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        head2.next = merge(head2.next, head1);</span><br><span class="line">        <span class="keyword">return</span> head2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h2 id="数组中的第K个最大元素"><a href="#数组中的第K个最大元素" class="headerlink" title="数组中的第K个最大元素"></a>数组中的第K个最大元素</h2><p><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/description/">215. 数组中的第K个最大元素 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="comment">// 小顶堆</span></span><br><span class="line">    PPriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(k, (n1, n2) -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> n1 - n2;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        minHeap.add(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">topNode</span> <span class="operator">=</span> minHeap.peek();</span><br><span class="line">        <span class="comment">// 保证里面k个数是数组中最大的k个数，每次淘汰k个数中最小的</span></span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; topNode) &#123;</span><br><span class="line">            minHeap.poll();</span><br><span class="line">            minHeap.add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 堆顶就是第k大</span></span><br><span class="line">    <span class="keyword">return</span> minHeap.peek();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据流的中位数"><a href="#数据流的中位数" class="headerlink" title="数据流的中位数"></a>数据流的中位数</h2><p><a href="https://leetcode.cn/problems/find-median-from-data-stream/description/">295. 数据流的中位数 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue&lt;Integer&gt; queMin;</span><br><span class="line">PriorityQueue&lt;Integer&gt; queMax;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">MedianFinder</span><span class="params">()</span> &#123;</span><br><span class="line">    queMin = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((n1, n2) -&gt; (n2 - n1));</span><br><span class="line">    queMax = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((n1, n2) -&gt; (n1 - n2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (queMin.isEmpty()) &#123;</span><br><span class="line">        queMin.offer(num);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; queMin.peek()) &#123;</span><br><span class="line">        queMin.offer(num);</span><br><span class="line">        <span class="comment">// 维持大小根堆的长度差值 &lt; 1</span></span><br><span class="line">        <span class="keyword">if</span> (queMin.size() &gt; queMax.size() + <span class="number">1</span>) &#123;</span><br><span class="line">            queMax.offer(queMin.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 包括queMax.isEmpty() || num &gt;= queMin.peek()</span></span><br><span class="line">        queMax.offer(num);</span><br><span class="line">        <span class="comment">// 维持小根堆的长度 &gt;= 大根堆的长度，这样返回中位数比较好判断</span></span><br><span class="line">        <span class="keyword">if</span>(queMax.size() &gt; queMin.size())&#123;</span><br><span class="line">            queMin.offer(queMax.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedian</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (queMin.size() == queMax.size() + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> queMin.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (queMin.peek() + queMax.peek()) / <span class="number">2.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="丑数-II"><a href="#丑数-II" class="headerlink" title="丑数 II"></a>丑数 II</h2><p><a href="https://leetcode.cn/problems/ugly-number-ii/description/">264. 丑数 II - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nthUglyNumber</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] factors = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">// 为了丑数堆没有重复元素</span></span><br><span class="line">    Set&lt;Long&gt; seen = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Long&gt;();</span><br><span class="line">    <span class="comment">// 丑数堆</span></span><br><span class="line">    PriorityQueue&lt;Long&gt; minHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">    seen.add(<span class="number">1L</span>);</span><br><span class="line">    minHeap.offer(<span class="number">1L</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// 如果 x 是丑数，那么 2x、3x、5x也是丑数，添加到丑数堆里</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">curr</span> <span class="operator">=</span> minHeap.poll();</span><br><span class="line">        ans = (<span class="type">int</span>) curr;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> factor : factors) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">next</span> <span class="operator">=</span> curr * factor;</span><br><span class="line">            <span class="keyword">if</span> (seen.add(next)) &#123;</span><br><span class="line">                minHeap.offer(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>三指针法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nthUglyNumber</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 每个位置代表第几个丑数</span></span><br><span class="line">    <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    ans[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">1</span>, i3 = <span class="number">1</span>, i5 = <span class="number">1</span>, i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">// ans[]是丑数，那么 a,b,c 也是丑数，每次找出最小的存入ans，也就维护了一个递增的丑数组</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2</span> * ans[i2];</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">3</span> * ans[i3];</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">5</span> * ans[i5];</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Math.min(a, Math.min(b, c));</span><br><span class="line">        <span class="comment">// 比较过一次就不能再用了</span></span><br><span class="line">        <span class="keyword">if</span> (min == a) i2++;</span><br><span class="line">        <span class="keyword">if</span> (min == b) i3++;</span><br><span class="line">        <span class="keyword">if</span> (min == c) i5++;</span><br><span class="line">        <span class="comment">// 更新丑数组</span></span><br><span class="line">        ans[i] = min;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p>递归的时间复杂度：目前不清楚</p><p>递归的空间复杂度：目前不清楚</p><p>树的题目首先要想的就是递归去解决，因为每个节点都有左子树和右子树这样相同的结构</p><p>遍历的话，一般dfs就是用递归，还有一个是bfs层序遍历，很多题目都是在遍历的基础上去做的</p><p>中序遍历二叉搜索树的话，是一个递增的数组</p><p>如果要修改树的结构，可能需要用到pre指针记录父节点位置</p><h2 id="二叉树的前序遍历"><a href="#二叉树的前序遍历" class="headerlink" title="二叉树的前序遍历"></a>二叉树的前序遍历</h2><p><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/description/">144. 二叉树的前序遍历 - 力扣（LeetCode）</a></p><p>迭代法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; S = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 根 左 右</span></span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">null</span> || !S.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            S.push(root);</span><br><span class="line">            <span class="comment">// 根</span></span><br><span class="line">            ans.add(root.val);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左完的根</span></span><br><span class="line">        root = S.pop();</span><br><span class="line">        <span class="comment">// 右</span></span><br><span class="line">        root = root.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a>二叉树的中序遍历</h2><p><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/description/">94. 二叉树的中序遍历 - 力扣（LeetCode）</a></p><p><strong>递归法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; ans;</span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    dfs(root.left);</span><br><span class="line">    ans.add(root.val);</span><br><span class="line">    dfs(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>迭代法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; S = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 左 根 右</span></span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">null</span> || !S.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 左</span></span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            S.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根</span></span><br><span class="line">        root = S.pop();</span><br><span class="line">        ans.add(root.val);</span><br><span class="line">        <span class="comment">// 右</span></span><br><span class="line">        root = root.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h2><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/description/?utm_source=LCUS&utm_medium=ip_redirect&utm_campaign=transfer2china">102. 二叉树的层序遍历 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            ans.add(node.val);</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>) queue.add(node.left);</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>) queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(ans));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的右视图"><a href="#二叉树的右视图" class="headerlink" title="二叉树的右视图"></a>二叉树的右视图</h2><p><a href="https://leetcode.cn/problems/binary-tree-right-side-view/description/">199. 二叉树的右视图 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 二叉树的锯齿形层序遍历</span><br><span class="line"></span><br><span class="line">[<span class="number">103.</span> 二叉树的锯齿形层序遍历 - 力扣（LeetCode）](https:<span class="comment">//leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/description/)</span></span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">zigzagLevelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="comment">// 一个队列</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>)<span class="keyword">return</span> res;</span><br><span class="line">    LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="comment">// 变量控制是否需要反转，第一次不用反转</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 层序遍历</span></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">        <span class="comment">// for循环，一个变量控制是否需要反转</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        LinkedList&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            ans.add(node.val);</span><br><span class="line">            <span class="keyword">if</span>(node.left!=<span class="literal">null</span>) queue.add(node.left);</span><br><span class="line">            <span class="keyword">if</span>(node.right!=<span class="literal">null</span>) queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) Collections.reverse(ans);</span><br><span class="line">        flag = !flag;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(ans));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉搜索树中第K小的元素"><a href="#二叉搜索树中第K小的元素" class="headerlink" title="二叉搜索树中第K小的元素"></a>二叉搜索树中第K小的元素</h2><p><a href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/description/">230. 二叉搜索树中第K小的元素 - 力扣（LeetCode）</a></p><p><strong>递归法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> count;</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthSmallest</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    count = k;</span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    dfs(root.left);</span><br><span class="line">    <span class="comment">// 根，处理</span></span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (--count == <span class="number">0</span>) &#123;</span><br><span class="line">        ans = root.val;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>迭代法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthSmallest</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    Stack&lt;TreeNode&gt; S = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">null</span> || !S.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 左</span></span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            S.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根，开始逻辑处理</span></span><br><span class="line">        root = S.pop();</span><br><span class="line">        <span class="keyword">if</span> (--k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 右</span></span><br><span class="line">        root = root.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h2><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/">104. 二叉树的最大深度 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="comment">// 叶子节点没有深度</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line">    <span class="comment">// 左右子树最大深度 + 自己的 1 个深度</span></span><br><span class="line">    <span class="keyword">return</span> Math.max(l, r) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h2><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">    <span class="comment">// 递归返回条件</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span> || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="comment">// 目标节点是否在左子树，不是返回null</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">    <span class="comment">// 目标节点是否在右子树，不是返回null</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">    <span class="keyword">if</span> (left == <span class="literal">null</span>) <span class="keyword">return</span> right;</span><br><span class="line">    <span class="keyword">if</span> (right == <span class="literal">null</span>) <span class="keyword">return</span> left;</span><br><span class="line">    <span class="comment">// 两边都有目标节点，根节点就是答案</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉搜索树的最近公共祖先"><a href="#二叉搜索树的最近公共祖先" class="headerlink" title="二叉搜索树的最近公共祖先"></a>二叉搜索树的最近公共祖先</h2><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/description/">235. 二叉搜索树的最近公共祖先 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) &#123;</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) &#123;</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="验证二叉树的前序序列化"><a href="#验证二叉树的前序序列化" class="headerlink" title="验证二叉树的前序序列化"></a>验证二叉树的前序序列化</h2><p>用数组的方式来进行树的遍历，有点意思的</p><p><a href="https://leetcode.cn/problems/verify-preorder-serialization-of-a-binary-tree/description/">331. 验证二叉树的前序序列化 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">String[] s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidSerialization</span><span class="params">(String preorder)</span> &#123;</span><br><span class="line">    s = preorder.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">    dfs();</span><br><span class="line">    <span class="keyword">return</span> s.length - <span class="number">1</span> == index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(index &gt;= s.length) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (Objects.equals(s[index], <span class="string">&quot;#&quot;</span>)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 递归左子树</span></span><br><span class="line">    index++;</span><br><span class="line">    dfs();</span><br><span class="line">    <span class="comment">// 递归右子树</span></span><br><span class="line">    index++;</span><br><span class="line">    dfs();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的序列化与反序列化"><a href="#二叉树的序列化与反序列化" class="headerlink" title="二叉树的序列化与反序列化"></a>二叉树的序列化与反序列化</h2><p><a href="https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/description/">297. 二叉树的序列化与反序列化 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化方法</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    rserialize(root);</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rserialize</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="comment">// 前序遍历，序列化</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        str += <span class="string">&quot;None,&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        str += str.valueOf(root.val) + <span class="string">&quot;,&quot;</span>;</span><br><span class="line">        rserialize(root.left);</span><br><span class="line">        rserialize(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化方法</span></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">deserialize</span><span class="params">(String data)</span> &#123;</span><br><span class="line">    String[] dataArray = data.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">    LinkedList&lt;String&gt; dataList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;String&gt;(Arrays.asList(dataArray));</span><br><span class="line">    <span class="keyword">return</span> rdeserialize(dataList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">rdeserialize</span><span class="params">(LinkedList&lt;String&gt; dataList)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(dataList.getFirst().equals(<span class="string">&quot;None&quot;</span>))&#123;</span><br><span class="line">        dataList.removeFirst();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将数组转化为树</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(dataList.getFirst()));</span><br><span class="line">    dataList.removeFirst();</span><br><span class="line">    root.left = rdeserialize(dataList);</span><br><span class="line">    root.right = rdeserialize(dataList);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉搜索树与双向链表"><a href="#二叉搜索树与双向链表" class="headerlink" title="二叉搜索树与双向链表"></a>二叉搜索树与双向链表</h2><p><a href="https://www.nowcoder.com/practice/947f6eb80d944a84850b0538bf0ec3a5?tpId=13&tqId=11179&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">https://www.nowcoder.com/practice/947f6eb80d944a84850b0538bf0ec3a5?tpId=13&amp;tqId=11179&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;TreeNode&gt; nodeList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">Convert</span><span class="params">(TreeNode pRootOfTree)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pRootOfTree == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 中序遍历，把数转化为有序数组，然后把数组再转化为链表</span></span><br><span class="line">        inorder(pRootOfTree);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nodeList.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            nodeList.get(i).right = nodeList.get(i + <span class="number">1</span>);</span><br><span class="line">            nodeList.get(i + <span class="number">1</span>).left = nodeList.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nodeList.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        inorder(root.left);</span><br><span class="line">        nodeList.add(root);</span><br><span class="line">        inorder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在遍历的时候就构建好了链表，利用二叉搜索树的中序遍历的有序性，栈内依次弹出较小的节点</span></span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">Convert</span><span class="params">(TreeNode pRootOfTree)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (pRootOfTree == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 中序遍历，把数转化为有序数组，然后把数组再转化为链表</span></span><br><span class="line">    inorder(pRootOfTree);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    inorder(root.left);</span><br><span class="line">    <span class="comment">// prev == null，说明是二叉搜索树中最小的节点</span></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="literal">null</span>) &#123;</span><br><span class="line">        head = root;</span><br><span class="line">        prev = root;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// prev不为null，构建链表</span></span><br><span class="line">        prev.right = root;</span><br><span class="line">        root.left = prev;</span><br><span class="line">        prev = root;</span><br><span class="line">    &#125;</span><br><span class="line">    inorder(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="从前序与中序遍历序列构造二叉树"><a href="#从前序与中序遍历序列构造二叉树" class="headerlink" title="从前序与中序遍历序列构造二叉树"></a>从前序与中序遍历序列构造二叉树</h2><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solutions/255811/cong-qian-xu-yu-zhong-xu-bian-li-xu-lie-gou-zao-9/?utm_source=LCUS&utm_medium=ip_redirect&utm_campaign=transfer2china">105. 从前序与中序遍历序列构造二叉树 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;Integer, Integer&gt; indexMap;</span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> preorder.length;</span><br><span class="line">    <span class="comment">// 构造哈希映射，帮助我们快速定位根节点</span></span><br><span class="line">    indexMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        indexMap.put(inorder[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buildTree(preorder, inorder, <span class="number">0</span>, preorder.length - <span class="number">1</span>, <span class="number">0</span>, inorder.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder, <span class="type">int</span> pre_start, <span class="type">int</span> pre_end, <span class="type">int</span> in_start, <span class="type">int</span> in_end)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (pre_start &gt; pre_end) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 子树的根节点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">root_val</span> <span class="operator">=</span> preorder[pre_start];</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(root_val);</span><br><span class="line">    <span class="comment">// 找到根节点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> indexMap.get(root_val);</span><br><span class="line">    <span class="comment">// 根节点左边有多少个数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">leftNum</span> <span class="operator">=</span> index - in_start;</span><br><span class="line">    <span class="comment">// 构建左右子树</span></span><br><span class="line">    root.left = buildTree(preorder, inorder, pre_start + <span class="number">1</span>, pre_start + leftNum, in_start, index - <span class="number">1</span>);</span><br><span class="line">    root.right = buildTree(preorder, inorder, pre_start + leftNum + <span class="number">1</span>, pre_end, index + <span class="number">1</span>, in_end);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="另一棵树的子树"><a href="#另一棵树的子树" class="headerlink" title="另一棵树的子树"></a>另一棵树的子树</h2><p><a href="https://leetcode.cn/problems/subtree-of-another-tree/description/">572. 另一棵树的子树 - 力扣（LeetCode）</a></p><p><strong>暴力递归法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubtree</span><span class="params">(TreeNode root, TreeNode subRoot)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> dfs(root, subRoot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历大树的节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(TreeNode s, TreeNode t)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> check(s, t) || dfs(s.left, t) || dfs(s.right, t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测这个节点开始的子树和目标子树的相同情况</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(TreeNode s, TreeNode t)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> &amp;&amp; t == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || t == <span class="literal">null</span> || s.val != t.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> check(s.left, t.left) &amp;&amp; check(s.right, t.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h2><p><a href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树 - 力扣（LeetCode）</a></p><p><strong>递归法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 每层递归都是交换左右子树</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">leftNode</span> <span class="operator">=</span> root.left;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">rightNode</span> <span class="operator">=</span> root.right;</span><br><span class="line">    root.left = rightNode;</span><br><span class="line">    root.right = leftNode;</span><br><span class="line">    invertTree(root.left);</span><br><span class="line">    invertTree(root.right);</span><br><span class="line">    <span class="comment">// 返回</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>层序遍历法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="comment">// 层序遍历</span></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        <span class="comment">// 循环每行的每个节点，调换节点的左右子节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">leftNode</span> <span class="operator">=</span> node.left;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">rightNode</span> <span class="operator">=</span> node.right;</span><br><span class="line">            node.left = rightNode;</span><br><span class="line">            node.right = leftNode;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>) queue.add(node.right);</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>) queue.add(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h2><p><a href="https://leetcode.cn/problems/symmetric-tree/description/">101. 对称二叉树 - 力扣（LeetCode）</a></p><p><strong>递归法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> isSymmetric(root.left, root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode leftNode, TreeNode rightNode)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 都为null，符合条件</span></span><br><span class="line">    <span class="keyword">if</span> (leftNode == <span class="literal">null</span> &amp;&amp; rightNode == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 一个为null，不符合条件</span></span><br><span class="line">    <span class="keyword">if</span> (leftNode == <span class="literal">null</span> || rightNode == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 都不为null，数值不同，不符合条件</span></span><br><span class="line">    <span class="keyword">if</span> (leftNode.val != rightNode.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 继续递归</span></span><br><span class="line">    <span class="keyword">return</span> isSymmetric(leftNode.left, rightNode.right) &amp;&amp; isSymmetric(leftNode.right, rightNode.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>迭代法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> check(root, root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(TreeNode u, TreeNode v)</span> &#123;</span><br><span class="line">    <span class="comment">// 层序遍历</span></span><br><span class="line">    LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">    queue.offer(u);</span><br><span class="line">    queue.offer(v);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        u = queue.poll();</span><br><span class="line">        v = queue.poll();</span><br><span class="line">        <span class="comment">// 判断条件，是否需要继续迭代</span></span><br><span class="line">        <span class="keyword">if</span> (u == <span class="literal">null</span> &amp;&amp; v == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((u == <span class="literal">null</span> || v == <span class="literal">null</span>) || (u.val != v.val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 两个一组加入，注意这里是左左和右右，左右和右左</span></span><br><span class="line">        queue.offer(u.left);</span><br><span class="line">        queue.offer(v.right);</span><br><span class="line"></span><br><span class="line">        queue.offer(u.right);</span><br><span class="line">        queue.offer(v.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="路径总和"><a href="#路径总和" class="headerlink" title="路径总和"></a>路径总和</h2><p><a href="https://leetcode.cn/problems/path-sum/description/">112. 路径总和 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> dfs(root, targetSum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 叶子节点才比较</span></span><br><span class="line">    <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> root.val == targetSum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归左右子树</span></span><br><span class="line">    <span class="keyword">return</span> dfs(root.left, targetSum - root.val) || dfs(root.right, targetSum - root.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="路径总和-II"><a href="#路径总和-II" class="headerlink" title="路径总和 II"></a>路径总和 II</h2><p><a href="https://leetcode.cn/problems/path-sum-ii/description/">113. 路径总和 II - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">LinkedList&lt;TreeNode&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">    dfs(root, targetSum);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 路径添加</span></span><br><span class="line">    path.add(root);</span><br><span class="line">    <span class="comment">// 叶子节点才比较</span></span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.val == targetSum) &#123;</span><br><span class="line">            <span class="comment">// 符合条件，加入答案</span></span><br><span class="line">            LinkedList&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (TreeNode treeNode : path) &#123;</span><br><span class="line">                ans.add(treeNode.val);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(ans));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归左子树</span></span><br><span class="line">    dfs(root.left, targetSum - root.val);</span><br><span class="line">    <span class="comment">// 回溯</span></span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="literal">null</span>) path.removeLast();</span><br><span class="line">    <span class="comment">// 递归右子树</span></span><br><span class="line">    dfs(root.right, targetSum - root.val);</span><br><span class="line">    <span class="comment">// 回溯</span></span><br><span class="line">    <span class="keyword">if</span> (root.right != <span class="literal">null</span>) path.removeLast();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树中的最大路径和"><a href="#二叉树中的最大路径和" class="headerlink" title="二叉树中的最大路径和"></a>二叉树中的最大路径和</h2><p><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/description/">124. 二叉树中的最大路径和 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPathSum</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">leftVal</span> <span class="operator">=</span> Math.max(dfs(root.left), <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">rightVal</span> <span class="operator">=</span> Math.max(dfs(root.right), <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 当前节点最大路径和</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">maxRoad</span> <span class="operator">=</span> root.val + leftVal + rightVal;</span><br><span class="line">    ans = Math.max(ans, maxRoad);</span><br><span class="line">    <span class="comment">// 返回的是当前节点作为子节点的贡献，只能取左边或者右边树枝的最大贡献</span></span><br><span class="line">    <span class="keyword">return</span> root.val + Math.max(leftVal, rightVal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的直径"><a href="#二叉树的直径" class="headerlink" title="二叉树的直径"></a>二叉树的直径</h2><p><a href="https://leetcode.cn/problems/diameter-of-binary-tree/description/?envType=study-plan-v2&envId=top-100-liked">543. 二叉树的直径 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 节点的个数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="comment">// 遍历的基础上，每个节点都算一次以这个节点为根节点的最长路径</span></span><br><span class="line">    depth(root);</span><br><span class="line">    <span class="comment">// 路径要节点数 - 1</span></span><br><span class="line">    <span class="keyword">return</span> ans - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">depth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 左子树的深度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> depth(root.left);</span><br><span class="line">    <span class="comment">// 右子树的深度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> depth(root.right);</span><br><span class="line">    <span class="comment">// 计算路径</span></span><br><span class="line">    ans = Math.max(ans, left + right + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 返回本节点为根节点的树的深度</span></span><br><span class="line">    <span class="keyword">return</span> Math.max(right, left) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a>岛屿数量</h2><p><a href="https://leetcode.cn/u/nettee/">nettee</a>的DFS题解无敌</p><p><a href="https://leetcode.cn/problems/number-of-islands/description/">200. 岛屿数量 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="comment">// 发现这个位置是陆地才开始遍历这个岛屿</span></span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                res++;</span><br><span class="line">                <span class="comment">// 这里遍历的意义是淹没这个岛屿，不然会重复判断</span></span><br><span class="line">                dfs(grid, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] grid, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= grid.length || j &gt;= grid[<span class="number">0</span>].length || grid[i][j] == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 淹没这个位置，保证后续不会重复遍历这个位置，只要遍历过，说明这个位置是属于同一个岛屿的</span></span><br><span class="line">    grid[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="comment">// 遍历这个岛的上下左右</span></span><br><span class="line">    dfs(grid, i + <span class="number">1</span>, j);</span><br><span class="line">    dfs(grid, i - <span class="number">1</span>, j);</span><br><span class="line">    dfs(grid, i, j + <span class="number">1</span>);</span><br><span class="line">    dfs(grid, i, j - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二分算法"><a href="#二分算法" class="headerlink" title="二分算法"></a>二分算法</h1><p>坚持一个原则，可以是左闭右闭（下标从最小到最大）</p><p>每次循环都需要缩小查找的数组的范围，right &#x3D; mid or right &#x3D; mid - 1，但是left&#x3D; mid会造成死循环（比如数组两个数的时候）</p><h3 id="x-的平方根"><a href="#x-的平方根" class="headerlink" title="x 的平方根"></a>x 的平方根</h3><p><a href="https://leetcode.cn/problems/sqrtx/description/">69. x 的平方根 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = x;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">long</span>)mid * mid == x) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="type">long</span>)mid * mid &gt; x) &#123;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p><a href="https://leetcode.cn/problems/binary-search/description/">704. 二分查找 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            r = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="搜索旋转排序数组"><a href="#搜索旋转排序数组" class="headerlink" title="搜索旋转排序数组"></a>搜索旋转排序数组</h2><p><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/description/">33. 搜索旋转排序数组 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 第一次二分，找旋转点，就是第一个 &lt; nums[0] 的</span></span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt;= nums[<span class="number">0</span>]) &#123;</span><br><span class="line">            l = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (target &gt;= nums[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="comment">// 目标在左半边数组</span></span><br><span class="line">        l = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 目标在右半边数组</span></span><br><span class="line">        l = l + <span class="number">1</span>;</span><br><span class="line">        r = nums.length - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第二次二分，找目标，我们正常的有序数组的二分</span></span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &gt; nums[mid]) &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt;= nums[mid]) &#123;</span><br><span class="line">            r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[r] == target ? r : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="寻找旋转排序数组中的最小值-II"><a href="#寻找旋转排序数组中的最小值-II" class="headerlink" title="寻找旋转排序数组中的最小值 II"></a>寻找旋转排序数组中的最小值 II</h2><p><a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/">154. 寻找旋转排序数组中的最小值 II - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMin</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 二分法</span></span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 如果mid选择和右边界比较，当 mid 和 end相等时，mid向左看，一定是先局部下降的，所以可以end-- 找最小值</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; nums[r]) l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; nums[r]) r = mid;</span><br><span class="line">        <span class="keyword">else</span> r--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[l];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><ul><li>替换数组的两个位置的元素</li><li>比较两个位置的元素是否相等</li></ul><h2 id="移动零"><a href="#移动零" class="headerlink" title="移动零"></a>移动零</h2><p><a href="https://leetcode.cn/problems/move-zeroes/description/?envType=study-plan-v2&envId=top-100-liked">283. 移动零 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="comment">// 左指针对准0，右指针对准非0</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (r &lt; nums.length) &#123;</span><br><span class="line">        <span class="comment">// 为0才有必要交换</span></span><br><span class="line">        <span class="keyword">if</span>(nums[l] == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 找非0</span></span><br><span class="line">            <span class="keyword">while</span> (r &lt; nums.length &amp;&amp; nums[r] == <span class="number">0</span>) &#123;</span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 替换0</span></span><br><span class="line">            <span class="keyword">if</span>(r &lt; nums.length)&#123;</span><br><span class="line">                nums[l] = nums[r];</span><br><span class="line">                nums[r] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//指针移动</span></span><br><span class="line">        l++;</span><br><span class="line">        r++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a>合并两个有序数组</h2><p><a href="https://leetcode.cn/problems/merge-sorted-array/description/">88. 合并两个有序数组 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> m, <span class="type">int</span>[] nums2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 倒序双指针</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> m - <span class="number">1</span>, p2 = n - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 标记答案的指针，每次选出最大的放进去</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">tail</span> <span class="operator">=</span> m + n - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 最终选择的那个数</span></span><br><span class="line">    <span class="type">int</span> cur;</span><br><span class="line">    <span class="keyword">while</span> (p1 &gt;= <span class="number">0</span> || p2 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 一个选完了，直接放另一个</span></span><br><span class="line">        <span class="keyword">if</span> (p1 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            cur = nums2[p2--];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p2 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            cur = nums1[p1--];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对比选择大的</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums1[p1] &gt; nums2[p2])&#123;</span><br><span class="line">            cur = nums1[p1--];</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            cur = nums2[p2--];</span><br><span class="line">        &#125;</span><br><span class="line">        nums1[tail--] = cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="按奇偶排序数组"><a href="#按奇偶排序数组" class="headerlink" title="按奇偶排序数组"></a>按奇偶排序数组</h2><p><a href="https://leetcode.cn/problems/sort-array-by-parity/description/?utm_source=LCUS&utm_medium=ip_redirect&utm_campaign=transfer2china">905. 按奇偶排序数组 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] sortArrayByParity(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    <span class="comment">// 两个指针，如果左指针是奇数，同时右指针是偶数，交换</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; nums.length &amp;&amp; nums[left] % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (right &gt;= <span class="number">0</span> &amp;&amp; nums[right] % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[left];</span><br><span class="line">            nums[left] = nums[right];</span><br><span class="line">            nums[right] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 刨除这两个元素，继续交换</span></span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除链表的倒数第-N-个结点"><a href="#删除链表的倒数第-N-个结点" class="headerlink" title="删除链表的倒数第 N 个结点"></a>删除链表的倒数第 N 个结点</h2><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/submissions/489136444/">19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 快慢指针，先让快指针走n + 1步，快指针为空的时候，用慢指针删除下一个节点</span></span><br><span class="line">    <span class="comment">// -1 1 2 3 4 5， n == 2</span></span><br><span class="line">    <span class="comment">// 虚拟头节点是为了不用区分删除头节点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">hair</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>, head);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> hair, fast = hair;</span><br><span class="line">    <span class="keyword">while</span> (n-- &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span>) &#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    slow.next = slow.next.next;</span><br><span class="line">    <span class="keyword">return</span> hair.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="环形链表-II-1"><a href="#环形链表-II-1" class="headerlink" title="环形链表 II"></a>环形链表 II</h2><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">// 环结构都可以用快慢指针，满指针一次走一步，快指针一次走两步</span></span><br><span class="line">    <span class="comment">// 数学推导，当快慢指针第一次相遇，只需要让两个指针，一个从起点开始走，一个从相遇点开始走，两个指针会在环的入口相遇</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head, fast = head;</span><br><span class="line">    <span class="comment">// while循环的条件，首先是考虑遍历链表，即会不会无环</span></span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">p2</span> <span class="operator">=</span> slow;</span><br><span class="line">            <span class="keyword">while</span> (p1 != p2) &#123;</span><br><span class="line">                p1 = p1.next;</span><br><span class="line">                p2 = p2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> p1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h2><p><a href="https://leetcode.cn/problems/3sum/description/">15. 三数之和 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="comment">// 排序后的比较好用双指针</span></span><br><span class="line">    <span class="comment">// for遍历确定下第一个数 注意去重</span></span><br><span class="line">    <span class="comment">// 双指针确认后面的两个数值</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="comment">// 去重，一定是在这个位置，和前一个位置（运动方向的反向）判断的</span></span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;  </span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 双指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + nums[left] + nums[right];</span><br><span class="line">            <span class="keyword">if</span>(sum &lt; <span class="number">0</span>) left++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; <span class="number">0</span>) right--;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res.add(Arrays.asList(nums[i], nums[left], nums[right]));</span><br><span class="line">                <span class="comment">// 为了避免出现重复答案，所以用了while</span></span><br><span class="line">                <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line">                <span class="comment">// 这里的可以是正常的添加完之后移动双指针</span></span><br><span class="line">                <span class="comment">// 或者是前面两个while，比如-1 0 1 1，然后经过了while右指针在第一个1，所以要移动两个指针</span></span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><p>两个指针</p><ul><li><p>右指针小于数组长度构成第一个循环</p></li><li><p>第二个内部的循环需要找到一个窗口维护的条件（一般什么东西是不大于某个值）</p></li><li><p>可以用哈希表或者另外一个数组维护需要用来判断长度的变量</p></li></ul><h2 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h2><p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/">3. 无重复字符的最长子串 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    Set&lt;Character&gt; map = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 维护窗口的指针</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 窗口的长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 答案</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line">    <span class="keyword">while</span> (right &lt; chars.length) &#123;</span><br><span class="line">        <span class="comment">// 窗口内有这个字符</span></span><br><span class="line">        <span class="keyword">if</span> (map.contains(chars[right])) &#123;</span><br><span class="line">            <span class="comment">// 左指针一直移动到找到窗口内的同样字符</span></span><br><span class="line">            <span class="keyword">while</span> (chars[left] != chars[right]) &#123;</span><br><span class="line">                <span class="comment">// 记得哈希表去掉</span></span><br><span class="line">                map.remove(chars[left]);</span><br><span class="line">                left++;</span><br><span class="line">                len--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 去掉窗口的相同字符</span></span><br><span class="line">            left++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 窗口内没有这个字符</span></span><br><span class="line">            map.add(chars[right]);</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = Math.max(ans, len);</span><br><span class="line">        <span class="comment">// 右指针往后探</span></span><br><span class="line">        right++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a>滑动窗口最大值</h2><p><a href="https://leetcode.cn/problems/sliding-window-maximum/description/">239. 滑动窗口最大值 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">    <span class="comment">// 递减队列保存的是下标</span></span><br><span class="line">    Deque&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 大值一定比小值先进入队列，否则小值不存在</span></span><br><span class="line">        <span class="comment">// 维护队列 -- 下标在窗口内</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty() &amp;&amp; queue.peekFirst() &lt; i - (k - <span class="number">1</span>)) &#123;</span><br><span class="line">            queue.pollFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 维护递减</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty() &amp;&amp; nums[i] &gt; nums[queue.peekLast()]) &#123;</span><br><span class="line">            queue.pollLast();</span><br><span class="line">        &#125;</span><br><span class="line">        queue.offer(i);</span><br><span class="line">        <span class="comment">// 返回值</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) &#123;</span><br><span class="line">            res[i - (k - <span class="number">1</span>)] = nums[queue.peekFirst()];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="找到字符串中所有字母异位词"><a href="#找到字符串中所有字母异位词" class="headerlink" title="找到字符串中所有字母异位词"></a>找到字符串中所有字母异位词</h2><p><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/description/?envType=study-plan-v2&envId=top-100-liked">438. 找到字符串中所有字母异位词 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findAnagrams</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sLen</span> <span class="operator">=</span> s.length(), pLen = p.length();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sLen &lt; pLen) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    <span class="comment">// 两个窗口</span></span><br><span class="line">    <span class="type">int</span>[] sCount = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="type">int</span>[] pCount = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pLen; ++i) &#123;</span><br><span class="line">        ++sCount[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        ++pCount[p.charAt(i) - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 每次都比较两个窗口（数组每个元素）是否相同</span></span><br><span class="line">    <span class="keyword">if</span> (Arrays.equals(sCount, pCount)) &#123;</span><br><span class="line">        ans.add(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sLen - pLen; ++i) &#123;</span><br><span class="line">        --sCount[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        ++sCount[s.charAt(i + pLen) - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Arrays.equals(sCount, pCount)) &#123;</span><br><span class="line">            ans.add(i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a>最小覆盖子串</h2><p><a href="https://leetcode.cn/problems/minimum-window-substring/description/?envType=study-plan-v2&envId=top-100-liked">76. 最小覆盖子串 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    <span class="comment">// 还需要多少这个字符，负号表示不需要</span></span><br><span class="line">    <span class="type">int</span>[] need = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">        need[t.charAt(i)]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 得出返回区间</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="comment">// count为窗口内的还需要的字符个数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> t.length();</span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(right);</span><br><span class="line">        <span class="keyword">if</span> (need[c] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">        need[c]--;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 去除不属于 t 的字符，缩小窗口长度</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; need[s.charAt(left)] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                need[s.charAt(left)]++;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新答案</span></span><br><span class="line">            <span class="keyword">if</span> (right - left + <span class="number">1</span> &lt; len) &#123;</span><br><span class="line">                len = right - left + <span class="number">1</span>;</span><br><span class="line">                start = left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 维护窗口</span></span><br><span class="line">            need[s.charAt(left)]++;</span><br><span class="line">            left++;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        right++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len == Integer.MAX_VALUE ? <span class="string">&quot;&quot;</span> : s.substring(start, start + len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1><h2 id="回溯算法的模板"><a href="#回溯算法的模板" class="headerlink" title="回溯算法的模板"></a>回溯算法的模板</h2><p>循环的次数</p><p>确定返回的条件</p><p>剪枝优化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void backtracking(参数) &#123;</span><br><span class="line">    if (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); // 递归</span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>树枝去重和数层去重，used[i - 1]为true就是树枝，false就是数层</p><ol><li><p>排列：</p></li><li><p>组合：</p><p>我举过例子，如果是一个集合来求组合的话，就需要startIndex，例如：<a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html">77.组合</a>，<a href="https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html">216.组合总和III</a>。</p><p>如果是多个集合取组合，各个集合之间相互不影响，那么就不用startIndex，例如：<a href="https://programmercarl.com/0017.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88.html">17.电话号码的字母组合</a></p><p>去重问题：数组排序才能去重</p><p>有startIndex才能树枝去重，没有的话只能数层去重</p><ul><li>used[i - 1] &#x3D;&#x3D; true，说明同一树枝candidates[i - 1]使用过</li><li>used[i - 1] &#x3D;&#x3D; false，说明同一树层candidates[i - 1]使用过</li></ul></li><li><p>子集：</p></li><li><p>分割字符串：和组合问题类似</p></li><li><p>棋盘：</p></li></ol><h2 id="括号生成"><a href="#括号生成" class="headerlink" title="括号生成"></a>括号生成</h2><p><a href="https://leetcode.cn/problems/generate-parentheses/description/">22. 括号生成 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    backTracking(<span class="number">0</span>, <span class="number">0</span>, n);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (sb.length() == <span class="number">2</span> * n) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">String</span>(sb));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 每层选左还是右</span></span><br><span class="line">    <span class="comment">// 先一直选左</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; n) &#123;</span><br><span class="line">        sb.append(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">        backTracking(left + <span class="number">1</span>, right, n);</span><br><span class="line">        sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 回溯时当左大于右 可以把之前的选左换成选右</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">        sb.append(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">        backTracking(left, right + <span class="number">1</span>, n);</span><br><span class="line">        sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><p><a href="https://leetcode.cn/problems/permutations/description/">46. 全排列 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="type">boolean</span>[] used;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    used = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">    backTraveling(nums);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backTraveling</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(path.size() == nums.length)&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for循环就是树的一层</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 选过了不选</span></span><br><span class="line">        <span class="keyword">if</span>(used[i]) <span class="keyword">continue</span>;</span><br><span class="line">        used[i] = <span class="literal">true</span>;</span><br><span class="line">        path.add(nums[i]);</span><br><span class="line">        <span class="comment">// 一次递归就进入树的下一层</span></span><br><span class="line">        backTraveling(nums);</span><br><span class="line">        path.removeLast();</span><br><span class="line">        used[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="全排列-II"><a href="#全排列-II" class="headerlink" title="全排列 II"></a>全排列 II</h2><p><a href="https://leetcode.cn/problems/permutations-ii/description/">47. 全排列 II - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="type">boolean</span>[] used;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permuteUnique</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    used = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    backTraveling(nums);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backTraveling</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.size() == nums.length) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 树枝去重，每个位置在一个路径只能用一次</span></span><br><span class="line">        <span class="keyword">if</span>(used[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 数层去重，比如[1, 1, 2]，如果第一层选2，第二层只需要选一次1，!used[i - 1]保证不是树枝</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !used[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        used[i] = <span class="literal">true</span>;</span><br><span class="line">        path.add(nums[i]);</span><br><span class="line">        backTraveling(nums);</span><br><span class="line">        path.removeLast();</span><br><span class="line">        used[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单词搜索"><a href="#单词搜索" class="headerlink" title="单词搜索"></a>单词搜索</h2><p><a href="https://leetcode.cn/problems/word-search/description/">79. 单词搜索 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exist</span><span class="params">(<span class="type">char</span>[][] board, String word)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (backTracking(board, word, i, j, <span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// i,j是当前位置，index是当前位置要匹配word的字母</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">char</span>[][] board, String word, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= board.length || j &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].length || word.charAt(index) != board[i][j])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (index == word.length() - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> ans;</span><br><span class="line">    <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> board[i][j];</span><br><span class="line">    board[i][j] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    ans = backTracking(board, word, i + <span class="number">1</span>, j, index + <span class="number">1</span>) ||</span><br><span class="line">            backTracking(board, word, i - <span class="number">1</span>, j, index + <span class="number">1</span>) ||</span><br><span class="line">            backTracking(board, word, i, j + <span class="number">1</span>, index + <span class="number">1</span>) ||</span><br><span class="line">            backTracking(board, word, i, j - <span class="number">1</span>, index + <span class="number">1</span>);</span><br><span class="line">    board[i][j] = c;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="机器人的运动范围"><a href="#机器人的运动范围" class="headerlink" title="机器人的运动范围"></a>机器人的运动范围</h2><p><a href="https://leetcode.cn/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/submissions/488231261/">LCR 130. 衣橱整理 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span>[][] visited;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">wardrobeFinishing</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> cnt)</span> &#123;</span><br><span class="line">    visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[m][n];</span><br><span class="line">    <span class="comment">// 这些位置是不可达的，先标记</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i / <span class="number">10</span> + i % <span class="number">10</span> + j / <span class="number">10</span> + j % <span class="number">10</span> &gt; cnt) &#123;</span><br><span class="line">                visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>, m, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 位置不可达，中止条件</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= m || j &gt;= n || visited[i][j]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录访问过，避免重复访问</span></span><br><span class="line">    visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + dfs(i + <span class="number">1</span>, j, m, n) + dfs(i, j + <span class="number">1</span>, m, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复原-IP-地址"><a href="#复原-IP-地址" class="headerlink" title="复原 IP 地址"></a>复原 IP 地址</h2><p><a href="https://leetcode.cn/problems/restore-ip-addresses/description/">93. 复原 IP 地址 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; ans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">restoreIpAddresses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    ans = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    backTraveling(s, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backTraveling</span><span class="params">(String s, <span class="type">int</span> start, <span class="type">int</span> pointNum)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (pointNum == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isValid(s, start, s.length() - <span class="number">1</span>)) &#123;</span><br><span class="line">            ans.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isValid(s, start, i)) <span class="keyword">break</span>;                                             </span><br><span class="line">        s = s.substring(<span class="number">0</span>, i + <span class="number">1</span>) + <span class="string">&quot;.&quot;</span> + s.substring(i + <span class="number">1</span>);    <span class="comment">//在str的后⾯插⼊⼀个逗点</span></span><br><span class="line">        pointNum++;</span><br><span class="line">        backTraveling(s, i + <span class="number">2</span>, pointNum);</span><br><span class="line">        pointNum--;</span><br><span class="line">        s = s.substring(<span class="number">0</span>, i + <span class="number">1</span>) + s.substring(i + <span class="number">2</span>);<span class="comment">// 回溯删掉逗点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s.charAt(start) == <span class="string">&#x27;0&#x27;</span> &amp;&amp; start != end) &#123; <span class="comment">// 0开头的数字不合法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) &gt; <span class="string">&#x27;9&#x27;</span> || s.charAt(i) &lt; <span class="string">&#x27;0&#x27;</span>) &#123; <span class="comment">// 遇到⾮数字字符不合法</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        num = num * <span class="number">10</span> + (s.charAt(i) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (num &gt; <span class="number">255</span>) &#123; <span class="comment">// 如果⼤于255了不合法</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><p>局部最优解堆叠成全局最优解</p><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>将问题拆成若干份小问题</p><ol><li>确定dp的含义</li><li>用0边界确定初始化</li><li>列出状态方程</li><li>优化</li></ol><h2 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h2><p><a href="https://leetcode.cn/problems/climbing-stairs/description/">70. 爬楼梯 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">2</span>];</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">// 每一层由前一层、前两层上来</span></span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h2><p><a href="https://leetcode.cn/problems/edit-distance/description/">72. 编辑距离 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> word1.length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> word2.length();</span><br><span class="line">    <span class="comment">// dp[i][j] 标识 word1从 0 ~ i-1 位变成 word2 的步数</span></span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span>[] arr1 = word1.toCharArray();</span><br><span class="line">    <span class="type">char</span>[] arr2 = word2.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="comment">// 两个指针对比字符相同</span></span><br><span class="line">            <span class="keyword">if</span> (arr1[i - <span class="number">1</span>] == arr2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 什么都不用干</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 进行替换、增加、删除</span></span><br><span class="line">                <span class="comment">// 步数 + 1</span></span><br><span class="line">                dp[i][j] = Math.min(Math.min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], dp[i][j - <span class="number">1</span>]), dp[i - <span class="number">1</span>][j]) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><p><a href="https://leetcode.cn/problems/longest-common-subsequence/description/">1143. 最长公共子序列 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> text1.length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> text2.length();</span><br><span class="line">    <span class="comment">// 标识 0~i-1 与 0~j-1 的最长公共子序列</span></span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 初始化：由于当一方为0，没有交集，不用初始化</span></span><br><span class="line">    <span class="type">char</span>[] s1 = text1.toCharArray();</span><br><span class="line">    <span class="type">char</span>[] s2 = text2.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="comment">// 两个指针对比字符相同</span></span><br><span class="line">            <span class="keyword">if</span> (s1[i - <span class="number">1</span>] == s2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 长度 + 1</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 取之前的最大值</span></span><br><span class="line">                dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="统计结果概率"><a href="#统计结果概率" class="headerlink" title="统计结果概率"></a>统计结果概率</h2><p><a href="https://leetcode.cn/problems/nge-tou-zi-de-dian-shu-lcof/description/">LCR 185. 统计结果概率 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span>[] statisticsProbability(<span class="type">int</span> num) &#123;</span><br><span class="line">    <span class="comment">// 当 i == 1，初始化 1 个骰子的概率</span></span><br><span class="line">    <span class="type">double</span>[] pre = &#123;<span class="number">1</span> / <span class="number">6d</span>, <span class="number">1</span> / <span class="number">6d</span>, <span class="number">1</span> / <span class="number">6d</span>, <span class="number">1</span> / <span class="number">6d</span>, <span class="number">1</span> / <span class="number">6d</span>, <span class="number">1</span> / <span class="number">6d</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= num; i++) &#123;</span><br><span class="line">        <span class="type">double</span>[] cur = <span class="keyword">new</span> <span class="title class_">double</span>[<span class="number">6</span> * i - (i - <span class="number">1</span>)];</span><br><span class="line">        <span class="comment">// 当前 i 个骰子，拆成 i - 1 个骰子的点数 + 1 个骰子的点数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; pre.length; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">6</span>; k++) &#123;</span><br><span class="line">                <span class="comment">// 比如说 10 点的概率 == 所有可能的 前 i - 1 个骰子的概率 * 1 个骰子的概率(1/6)</span></span><br><span class="line">                cur[j + k] += pre[j] * (<span class="number">1</span> / <span class="number">6d</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="整数拆分"><a href="#整数拆分" class="headerlink" title="整数拆分"></a>整数拆分</h2><p><a href="https://leetcode.cn/problems/integer-break/">343. 整数拆分 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">integerBreak</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 2 = 1 + 1，1 * 1 = 1</span></span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 从dp[3]开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">// i == j + (i - j)</span></span><br><span class="line">        <span class="comment">// dp[i] = dp[j] + dp[i - j]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= i - j; j++) &#123;</span><br><span class="line">            dp[i] = Math.max(dp[i], Math.max(j * (i - j), j * dp[i - j]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解码方法"><a href="#解码方法" class="headerlink" title="解码方法"></a>解码方法</h2><p><a href="https://leetcode.cn/problems/decode-ways/description/">91. 解码方法 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numDecodings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 空字符串可以有 1 种解码方法，解码出一个空字符串</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) != <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            dp[i] += dp[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">1</span> &amp;&amp; s.charAt(i - <span class="number">2</span>) != <span class="string">&#x27;0&#x27;</span> &amp;&amp; ((s.charAt(i - <span class="number">2</span>) - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + (s.charAt(i - <span class="number">1</span>) - <span class="string">&#x27;0&#x27;</span>)) &lt;= <span class="number">26</span>) &#123;</span><br><span class="line">            dp[i] += dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="珠宝的最高价值"><a href="#珠宝的最高价值" class="headerlink" title="珠宝的最高价值"></a>珠宝的最高价值</h2><p><a href="https://leetcode.cn/problems/li-wu-de-zui-da-jie-zhi-lcof/description/">LCR 166. 珠宝的最高价值 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jewelleryValue</span><span class="params">(<span class="type">int</span>[][] frame)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> frame.length, n = frame[<span class="number">0</span>].length;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// dp只和上面和左边有关，所以都是0，也就不用初始化了</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + frame[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h2><h2 id="股票"><a href="#股票" class="headerlink" title="股票"></a>股票</h2><h3 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h3><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/">121. 买卖股票的最佳时机 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="comment">// 0是没有，1是有，dp[i][j]：下标为 i 这一天结束的时候，手上持股状态为 j 时，我们持有的现金数</span></span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 第i天有股票，是从第i-1天本来就有，第i-1天没有，今天买的</span></span><br><span class="line">        <span class="comment">// 第i天有股票，是从第i-1天本来就没有，第i-1天有，今天卖的</span></span><br><span class="line">        dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], - prices[i]);</span><br><span class="line">        dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="子序列，子数组"><a href="#子序列，子数组" class="headerlink" title="子序列，子数组"></a>子序列，子数组</h2><p>一个序列 or 数组，可能和前面任何一个位置的状态都有关</p><p>两个序列 or 数组，只和 <code>dp[i - 1][j - 1]</code>、<code>dp[i][j - 1]</code>、<code>dp[i - 1][j]</code>有关</p><p><code>dp[i][j]</code>表示的意思是s的前i个字母中匹配t的前j个字母的字母个数，或者是总数</p><h3 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h3><p><a href="https://leetcode.cn/problems/longest-increasing-subsequence/">300. 最长递增子序列 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="comment">// dp 代表当前这个数在末尾的子序列长度</span></span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 遍历前面的每一个数字</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="comment">// 当前数字比前面的数字大，才说明可以成为一个递增子序列</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                <span class="comment">// 修改 dp[]</span></span><br><span class="line">                dp[i] = Math.max(dp[j] + <span class="number">1</span>, dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = Math.max(ans, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a>最大子数组和</h3><p><a href="https://leetcode.cn/problems/maximum-subarray/description/?utm_source=LCUS&utm_medium=ip_redirect&utm_campaign=transfer2china">53. 最大子数组和 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> dp[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 状态转移方程</span></span><br><span class="line">        dp[i] = Math.max(dp[i - <span class="number">1</span>] + nums[i], nums[i]);</span><br><span class="line">        res = Math.max(res, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="comment">// 常量代替数组</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        x = Math.max(x + nums[i], nums[i]);</span><br><span class="line">        res = Math.max(x, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数位dp"><a href="#数位dp" class="headerlink" title="数位dp"></a>数位dp</h2><h3 id="数字-1-的个数"><a href="#数字-1-的个数" class="headerlink" title="数字 1 的个数"></a>数字 1 的个数</h3><p><a href="https://leetcode.cn/problems/number-of-digit-one/description/">233. 数字 1 的个数 - 力扣（LeetCode）</a></p><p><strong>密码锁法，用 cur 区分左右两边的数字</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countDigitOne</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> n / <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> n % <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">digit</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 求个位的 1 的个数</span></span><br><span class="line">    <span class="keyword">while</span> (high != <span class="number">0</span> || cur != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 1204 假设当前 cur == 0，digit == 10</span></span><br><span class="line">            <span class="comment">// 其他三位从 000 ~ 124 出现了 12次 xx10 ~ xx19，即十位出现 120次 1</span></span><br><span class="line">            res += high * digit;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 1214 假设当前 cur == 1，digit == 10</span></span><br><span class="line">            <span class="comment">// 其他三位从 000 ~ 124 出现了 12次 xx10 ~ xx19，和 0 ~ 4 次 1，即十位出现 120 + 5 次 1</span></span><br><span class="line">            res += high * digit + low + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 1234 假设当前 cur == 3，digit == 10</span></span><br><span class="line">            <span class="comment">// 其他三位从 000 ~ 124 出现了 13次 xx10 ~ xx19，即十位出现 130次 1</span></span><br><span class="line">            res += (high + <span class="number">1</span>) * digit;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// low 的位数 + 1</span></span><br><span class="line">        low += cur * digit;</span><br><span class="line">        <span class="comment">// cur 往左移动</span></span><br><span class="line">        cur = high % <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// high 的位数 - 1</span></span><br><span class="line">        high /= <span class="number">10</span>;</span><br><span class="line">        digit *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    for (int j = 1; j &lt; 10 - i; j++) &#123;</span><br><span class="line">        if (nums[j - 1] &gt; nums[j]) &#123;</span><br><span class="line">            swap(nums, j - 1, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void swap(int[] nums, int i, int j) &#123;</span><br><span class="line">    int temp = nums[i] ^ nums[j];</span><br><span class="line">    nums[i] = temp ^ nums[i];</span><br><span class="line">    nums[j] = temp ^ nums[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>以第一个数为基准的写法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">private static void quicksort(int[] nums) &#123;</span><br><span class="line">    sort(nums, 0, nums.length - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void sort(int[] nums, int l, int r) &#123;</span><br><span class="line">    if (l &gt;= r) return;</span><br><span class="line">    // 递归排序基数</span><br><span class="line">    int index = partition(nums, l, r);</span><br><span class="line">    // 递归排序基数左边的数组</span><br><span class="line">    sort(nums, l, index - 1);</span><br><span class="line">    // 递归排序基数右边的数组</span><br><span class="line">    sort(nums, index + 1, r);</span><br><span class="line">&#125;</span><br><span class="line">// 递归排序基数</span><br><span class="line">private static int partition(int[] nums, int l, int r) &#123;</span><br><span class="line">    // 第一个数最为基准数</span><br><span class="line">    int temp = nums[l];</span><br><span class="line">    int i = l, j = r;</span><br><span class="line">    while (i &lt; j) &#123;</span><br><span class="line">        // 找到第一个比temp小的数字</span><br><span class="line">        while (nums[j] &gt;= temp &amp;&amp; i &lt; j) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        // 找到第一个比temp大的数字</span><br><span class="line">        while (nums[i] &lt;= temp &amp;&amp; i &lt; j) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    // 将基准数交换到合适的位置，如果数组本身有序，可能自己和自己交换</span><br><span class="line">    swap(nums, l, i);</span><br><span class="line">    return i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void swap(int[] nums, int i, int j) &#123;</span><br><span class="line">    int temp = nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三路快排优化"><a href="#三路快排优化" class="headerlink" title="三路快排优化"></a>三路快排优化</h2><p><a href="https://cloud.tencent.com/developer/article/1639304">前端学习数据结构与算法系列(八)：快速排序与三路快排-腾讯云开发者社区-腾讯云 (tencent.com)</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    quickSort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 递归排序基数</span></span><br><span class="line">    <span class="type">int</span>[] index = partition(nums, l, r);</span><br><span class="line">    <span class="comment">// 递归排序基数左边的数组</span></span><br><span class="line">    quickSort(nums, l, index[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">// 递归排序基数右边的数组</span></span><br><span class="line">    quickSort(nums, index[<span class="number">1</span>], r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span>[] partition(<span class="type">int</span>[] nums, <span class="type">int</span> l, <span class="type">int</span> r) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">base</span> <span class="operator">=</span> nums[l];</span><br><span class="line">    <span class="comment">// 总共3个区间，&lt;p、==p、&gt;p</span></span><br><span class="line">    <span class="comment">// lt代表的是&lt;p的右边界，gt代表的是&gt;p的左边界</span></span><br><span class="line">    <span class="comment">// 初始化标识三个区间都是0</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">lt</span> <span class="operator">=</span> l, gt = r + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l + <span class="number">1</span>; i &lt; gt; ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == base) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &gt; base) &#123;</span><br><span class="line">            <span class="comment">// 不 i++的原因是，i位置要一直换，直到拿到小的</span></span><br><span class="line">            swap(nums, gt - <span class="number">1</span>, i);</span><br><span class="line">            gt--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// i++的原因是，lt前面的数已经是符合条件的&lt;p，所以换个&lt;p的过来没问题</span></span><br><span class="line">            swap(nums, lt + <span class="number">1</span>, i);</span><br><span class="line">            lt++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 只剩下基准值没有交换了</span></span><br><span class="line">    swap(nums, l, lt);</span><br><span class="line">    lt--;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;lt, gt&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[left];</span><br><span class="line">    nums[left] = nums[right];</span><br><span class="line">    nums[right] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public static void gbSort(int[] nums)&#123;</span><br><span class="line">    sort(nums, 0, nums.length - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void sort(int[] nums, int l, int r) &#123;</span><br><span class="line">    if (l &gt;= r) return;</span><br><span class="line"></span><br><span class="line">    int mid = l + (r - l) / 2;</span><br><span class="line">    // 分</span><br><span class="line">    sort(nums, l, mid);</span><br><span class="line">    sort(nums, mid + 1, r);</span><br><span class="line">    // 治</span><br><span class="line">    merge(nums, l, mid, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void merge(int[] nums, int l, int mid, int r) &#123;</span><br><span class="line">    int[] temp = new int[nums.length];</span><br><span class="line">    int i = l, j = mid + 1;</span><br><span class="line">    // 区间的左边界</span><br><span class="line">    int index = l;</span><br><span class="line">    // 合并子数组，l 到 mid 是左数组，mid + 1 到 r 是右数组</span><br><span class="line">    while (i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">        if (nums[i] &lt; nums[j]) &#123;</span><br><span class="line">            temp[index++] = nums[i++];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            temp[index++] = nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while (i &lt;= mid) &#123;</span><br><span class="line">        temp[index++] = nums[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    while (j &lt;= r) &#123;</span><br><span class="line">        temp[index++] = nums[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    // 代替原来这个区间的的无序子数组</span><br><span class="line">    for (int k = l; k &lt;= r; k++) &#123;</span><br><span class="line">        nums[k] = temp[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="进制和位运算"><a href="#进制和位运算" class="headerlink" title="进制和位运算"></a>进制和位运算</h1><h2 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a>二进制中1的个数</h2><p><a href="https://leetcode.cn/problems/number-of-1-bits/">191. 位1的个数 - 力扣（LeetCode）</a></p><p><strong>循环遍历法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hammingWeight</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 每次和一位进行与操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((n &amp; (<span class="number">1</span> &lt;&lt; i)) != <span class="number">0</span>) count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>位运算优化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hammingWeight</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// n &amp; (n - 1) 可以把最后一个1去掉</span></span><br><span class="line">    <span class="comment">// 不断循环去1</span></span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">        n &amp;= (n - <span class="number">1</span>);</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Pow-x-n"><a href="#Pow-x-n" class="headerlink" title="Pow(x, n)"></a>Pow(x, n)</h2><p><a href="https://leetcode.cn/problems/powx-n/description/">50. Pow(x, n) - 力扣（LeetCode）</a></p><p><strong>递归法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">N</span> <span class="operator">=</span> n;</span><br><span class="line">    <span class="keyword">return</span> N &gt; <span class="number">0</span> ? quickMul(x, N) : <span class="number">1.0</span> / quickMul(x, -N);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">double</span> <span class="title function_">quickMul</span><span class="params">(<span class="type">double</span> x, <span class="type">long</span> N)</span> &#123;</span><br><span class="line">    <span class="comment">// 递归中止条件</span></span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">    <span class="comment">// 分治</span></span><br><span class="line">    <span class="type">double</span> <span class="variable">y</span> <span class="operator">=</span> quickMul(x, N / <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 偶数次幂</span></span><br><span class="line">    <span class="comment">// x^6 == x^3 * x^3</span></span><br><span class="line">    <span class="keyword">if</span> (N % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> y * y;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> y * y * x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>二进制拆解法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">N</span> <span class="operator">=</span> n;</span><br><span class="line">    <span class="keyword">return</span> N &gt; <span class="number">0</span> ? quickMul(x, N) : <span class="number">1.0</span> / quickMul(x, -N);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">double</span> <span class="title function_">quickMul</span><span class="params">(<span class="type">double</span> x, <span class="type">long</span> N)</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1.0</span>;</span><br><span class="line">    <span class="comment">// 初始贡献值</span></span><br><span class="line">    <span class="type">double</span> <span class="variable">x_contribution</span> <span class="operator">=</span> x;</span><br><span class="line">    <span class="comment">// 77 = (1001101)</span></span><br><span class="line">    <span class="comment">// x^77 = x * x^4 * x^8 * x^64</span></span><br><span class="line">    <span class="keyword">while</span> (N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 是1才需要记录贡献</span></span><br><span class="line">        <span class="keyword">if</span> (N % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            ans *= x_contribution;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从右向左，每一位的贡献都是右一位的两倍</span></span><br><span class="line">        x_contribution *= x_contribution;</span><br><span class="line">        N /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 骚的</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">N</span> <span class="operator">=</span> n;</span><br><span class="line">    <span class="keyword">return</span> N &gt; <span class="number">0</span> ? quickMul(x, N) : <span class="number">1.0</span> / quickMul(x, -N);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">double</span> <span class="title function_">quickMul</span><span class="params">(<span class="type">double</span> x, <span class="type">long</span> N)</span> &#123;</span><br><span class="line">   <span class="type">double</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1.0</span>;</span><br><span class="line">    <span class="comment">// 初始贡献值</span></span><br><span class="line">    <span class="type">double</span> <span class="variable">x_contribution</span> <span class="operator">=</span> x;</span><br><span class="line">    <span class="comment">// 77 = (1001101)</span></span><br><span class="line">    <span class="comment">// x^77 = x * x^4 * x^8 * x^64</span></span><br><span class="line">    <span class="keyword">while</span> (N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 是1才需要记录贡献</span></span><br><span class="line">        <span class="comment">// 和hashmap计算下标一样的操作</span></span><br><span class="line">        <span class="keyword">if</span> ((N &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            ans *= x_contribution;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从右向左，每一位的贡献都是右一位的两倍</span></span><br><span class="line">        x_contribution *= x_contribution;</span><br><span class="line">        N &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="只出现一次的数字-III"><a href="#只出现一次的数字-III" class="headerlink" title="只出现一次的数字 III"></a>只出现一次的数字 III</h2><p><a href="https://leetcode.cn/problems/single-number-iii/description/">260. 只出现一次的数字 III - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] singleNumber(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">xor</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        xor ^= num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 经过上述计算，现在的 xor 不为 0</span></span><br><span class="line">    <span class="comment">// 可以发现这两个只出现1次的数在某一位 异或 为 1，通过这一位 1 可以把他们分成两组</span></span><br><span class="line">    <span class="comment">// 不妨找出最右边的 1 ，xor &amp; (-xor) 即 xxx1000 &amp; (xxx0111 + 1)</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">lsb</span> <span class="operator">=</span> xor &amp; (-xor);</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans1</span> <span class="operator">=</span> <span class="number">0</span>, ans2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((num &amp; lsb) != <span class="number">0</span>) &#123;</span><br><span class="line">            ans1 ^= num;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans2 ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;ans1, ans2&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><h2 id="轮转数组"><a href="#轮转数组" class="headerlink" title="轮转数组"></a>轮转数组</h2><p><a href="https://leetcode.cn/problems/rotate-array/description/?envType=study-plan-v2&envId=top-100-liked">189. 轮转数组 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    k %= nums.length;</span><br><span class="line">    reverse(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    reverse(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">    reverse(nums, k, nums.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[start];</span><br><span class="line">        nums[start] = nums[end];</span><br><span class="line">        nums[end] = temp;</span><br><span class="line">        start++;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="比较版本号"><a href="#比较版本号" class="headerlink" title="比较版本号"></a>比较版本号</h2><p><a href="https://leetcode.cn/problems/compare-version-numbers/description/">165. 比较版本号 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareVersion</span><span class="params">(String version1, String version2)</span> &#123;</span><br><span class="line">    <span class="comment">// 切割字符串</span></span><br><span class="line">    String[] ss1 = version1.split(<span class="string">&quot;\\.&quot;</span>), ss2 = version2.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> ss1.length, m = ss2.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 每一部分对位比较</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n || j &lt; m) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; n) a = Integer.parseInt(ss1[i++]);</span><br><span class="line">        <span class="keyword">if</span> (j &lt; m) b = Integer.parseInt(ss2[j++]);</span><br><span class="line">        <span class="keyword">if</span> (a != b) <span class="keyword">return</span> a &gt; b ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文物朝代判断"><a href="#文物朝代判断" class="headerlink" title="文物朝代判断"></a>文物朝代判断</h2><p><a href="https://leetcode.cn/problems/bu-ke-pai-zhong-de-shun-zi-lcof/description/">LCR 186. 文物朝代判断 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkDynasty</span><span class="params">(<span class="type">int</span>[] places)</span> &#123;</span><br><span class="line">    Arrays.sort(places);</span><br><span class="line">    <span class="comment">// 0的数量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 最大牌位置在最后，那么最小牌位置在 0 + count</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; places.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (places[i] == <span class="number">0</span>) count++;</span><br><span class="line">        <span class="comment">// 不能重复</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (places[i] == places[i + <span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6 7 8 9 10 第一个非0和最大数相差 &lt;= 4，全是0也是对的</span></span><br><span class="line">    <span class="keyword">return</span> places[<span class="number">4</span>] - places[count] &lt;= <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="设计机械累加器"><a href="#设计机械累加器" class="headerlink" title="设计机械累加器"></a>设计机械累加器</h2><p><a href="https://leetcode.cn/problems/qiu-12n-lcof/description/">LCR 189. 设计机械累加器 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mechanicalAccumulator</span><span class="params">(<span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">x</span> <span class="operator">=</span> target &gt; <span class="number">1</span> &amp;&amp; (target += mechanicalAccumulator(target - <span class="number">1</span>)) &gt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="破冰游戏"><a href="#破冰游戏" class="headerlink" title="破冰游戏"></a>破冰游戏</h2><p><a href="https://leetcode.cn/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/description/">LCR 187. 破冰游戏 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">iceBreakingGame</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="comment">// 最后一个人的位置一定是0</span></span><br><span class="line">     <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 最后一轮剩下2个人s，所以从2开始反推</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= num; i++) &#123;</span><br><span class="line">        ans = (ans + target) % i; <span class="comment">// 每次循环右移，把杀的人补回去，改变活着的人的位置</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多数元素"><a href="#多数元素" class="headerlink" title="多数元素"></a>多数元素</h2><p><a href="https://leetcode.cn/problems/majority-element/description/?utm_source=LCUS&utm_medium=ip_redirect&utm_campaign=transfer2china">169. 多数元素 - 力扣（LeetCode）</a></p><p><strong>占领高地法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 占领高地法，最后一定是多数元素占领高地</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 每次派一个士兵冲上高地</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="comment">// 没人就标记我方占领高地</span></span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>)&#123;</span><br><span class="line">            ans = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 发现是队友，则我军人数+1</span></span><br><span class="line">        <span class="keyword">if</span>(ans == nums[i])&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 否则换掉对方一个人</span></span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多数元素-II"><a href="#多数元素-II" class="headerlink" title="多数元素 II"></a>多数元素 II</h2><p><a href="https://leetcode.cn/problems/majority-element-ii/description/">229. 多数元素 II - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">element1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">element2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        <span class="comment">// 每次都增强友军或者增强盟军</span></span><br><span class="line">        <span class="keyword">if</span> (count1 &gt; <span class="number">0</span> &amp;&amp; num == element1) &#123;</span><br><span class="line">            count1++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count2 &gt; <span class="number">0</span> &amp;&amp; num == element2) &#123;</span><br><span class="line">            count2++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count1 == <span class="number">0</span>) &#123;</span><br><span class="line">            element1 = num;</span><br><span class="line">            count1++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count2 == <span class="number">0</span>) &#123;</span><br><span class="line">            element2 = num;</span><br><span class="line">            count2++;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 如果和两军都敌对，则相互抵消1次</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            count1--;</span><br><span class="line">            count2--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cnt1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cnt2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count1 &gt; <span class="number">0</span> &amp;&amp; num == element1) &#123;</span><br><span class="line">            cnt1++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count2 &gt; <span class="number">0</span> &amp;&amp; num == element2) &#123;</span><br><span class="line">            cnt2++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检测元素出现的次数是否满足要求</span></span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (count1 &gt; <span class="number">0</span> &amp;&amp; cnt1 &gt; nums.length / <span class="number">3</span>) &#123;</span><br><span class="line">        res.add(element1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count2 &gt; <span class="number">0</span> &amp;&amp; cnt2 &gt; nums.length / <span class="number">3</span>) &#123;</span><br><span class="line">        res.add(element2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>tomcat如何打破双亲委派模型</title>
      <link href="/forworl.github.io/2023/12/12/tomcat%E5%A6%82%E4%BD%95%E6%89%93%E7%A0%B4%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/"/>
      <url>/forworl.github.io/2023/12/12/tomcat%E5%A6%82%E4%BD%95%E6%89%93%E7%A0%B4%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p><a href="https://developer.aliyun.com/article/1081332">Tomcat是如何打破”双亲委派”机制的?-阿里云开发者社区 (aliyun.com)</a></p><p><a href="https://www.zhihu.com/question/466696410">(25 封私信 &#x2F; 80 条消息) Tomcat为什么要JAVA破坏双亲委派机制？ - 知乎 (zhihu.com)</a></p><p><a href="https://cloud.tencent.com/developer/article/1706851">1.5 tomcat是如何打破双亲委派机制的?-腾讯云开发者社区-腾讯云 (tencent.com)</a></p><h1 id="tomcat为什么要打破双亲委派模型"><a href="#tomcat为什么要打破双亲委派模型" class="headerlink" title="tomcat为什么要打破双亲委派模型"></a>tomcat为什么要打破双亲委派模型</h1><p><strong>tomcat是一个web容器，里面可以部署很多应用程序app，每个app都可以依赖不同版本的第三方类库，根据双亲委派模型，可能导致冲突</strong></p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20231212165850649.png" alt="image-20231212165850649" style="zoom:80%;" /><h1 id="tomcat如何打破双亲委派模型"><a href="#tomcat如何打破双亲委派模型" class="headerlink" title="tomcat如何打破双亲委派模型"></a>tomcat如何打破双亲委派模型</h1><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20231212170027255.png" alt="image-20231212170027255"></p><h2 id="tomcat自定义的类加载器"><a href="#tomcat自定义的类加载器" class="headerlink" title="tomcat自定义的类加载器"></a>tomcat自定义的类加载器</h2><ul><li>Common ClassLoader：web容器和app共有的类库，避免重复类加载</li><li>Catalina ClassLoader：web容器私有的类库，避免冲突</li><li>App的类库<ul><li>WebAppClassLoader：app之间共有的类库，避免重复类加载</li><li>ShareClassLoader：app私有的类库，避免冲突</li></ul></li></ul><h2 id="重写loadClass"><a href="#重写loadClass" class="headerlink" title="重写loadClass()"></a>重写loadClass()</h2><h3 id="loadClass"><a href="#loadClass" class="headerlink" title="loadClass()"></a>loadClass()</h3><ol><li>先判断是否类被父加载器加载过了，避免加载到核心类（比如String）造成冲突</li><li>先不用父加载器加载类，默认先用WebAppClassLoader进行加载</li><li>如果WebAppClassLoader加载失败了，调用AppClassLoader加载类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 1、从本地缓存中查找是否加载过此类</span></span><br><span class="line">        clazz = findLoadedClass0(name);</span><br><span class="line">        <span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (log.isDebugEnabled())</span><br><span class="line">                log.debug(<span class="string">&quot;  Returning class from cache&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (resolve)</span><br><span class="line">                resolveClass(clazz);</span><br><span class="line">            <span class="keyword">return</span> clazz;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、从AppClassLoader中查找是否加载过此类</span></span><br><span class="line">        clazz = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (log.isDebugEnabled())</span><br><span class="line">                log.debug(<span class="string">&quot;  Returning class from cache&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (resolve)</span><br><span class="line">                resolveClass(clazz);</span><br><span class="line">            <span class="keyword">return</span> clazz;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">resourceName</span> <span class="operator">=</span> binaryNameToPath(name, <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 3、尝试用ExtClassLoader 类加载器加载类,防止应用覆盖JRE的核心类</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">javaseLoader</span> <span class="operator">=</span> getJavaseClassLoader();</span><br><span class="line">        <span class="type">boolean</span> tryLoadingFromJavaseLoader;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            URL url;</span><br><span class="line">            <span class="keyword">if</span> (securityManager != <span class="literal">null</span>) &#123;</span><br><span class="line">                PrivilegedAction&lt;URL&gt; dp = <span class="keyword">new</span> <span class="title class_">PrivilegedJavaseGetResource</span>(resourceName);</span><br><span class="line">                url = AccessController.doPrivileged(dp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                url = javaseLoader.getResource(resourceName);</span><br><span class="line">            &#125;</span><br><span class="line">            tryLoadingFromJavaseLoader = (url != <span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            tryLoadingFromJavaseLoader = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">delegateLoad</span> <span class="operator">=</span> delegate || filter(name, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、判断是否设置了delegate属性,如果设置为true那么就按照双亲委派机制加载类</span></span><br><span class="line">        <span class="keyword">if</span> (delegateLoad) &#123;</span><br><span class="line">            <span class="keyword">if</span> (log.isDebugEnabled())</span><br><span class="line">                log.debug(<span class="string">&quot;  Delegating to parent classloader1 &quot;</span> + parent);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                clazz = Class.forName(name, <span class="literal">false</span>, parent);</span><br><span class="line">                <span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (log.isDebugEnabled())</span><br><span class="line">                        log.debug(<span class="string">&quot;  Loading class from parent&quot;</span>);</span><br><span class="line">                    <span class="keyword">if</span> (resolve)</span><br><span class="line">                        resolveClass(clazz);</span><br><span class="line">                    <span class="keyword">return</span> clazz;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// Ignore</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5、默认是设置delegate是false的,那么就会先用WebAppClassLoader进行加载</span></span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled())</span><br><span class="line">            log.debug(<span class="string">&quot;  Searching local repositories&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clazz = findClass(name);</span><br><span class="line">            <span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (log.isDebugEnabled())</span><br><span class="line">                    log.debug(<span class="string">&quot;  Loading class from local repository&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (resolve)</span><br><span class="line">                    resolveClass(clazz);</span><br><span class="line">                <span class="keyword">return</span> clazz;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// Ignore</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6、如果在WebAppClassLoader没找到类，那么就委托给AppClassLoader去加载</span></span><br><span class="line">        <span class="keyword">if</span> (!delegateLoad) &#123;</span><br><span class="line">            <span class="keyword">if</span> (log.isDebugEnabled())</span><br><span class="line">                log.debug(<span class="string">&quot;  Delegating to parent classloader at end: &quot;</span> + parent);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                clazz = Class.forName(name, <span class="literal">false</span>, parent);</span><br><span class="line">                <span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (log.isDebugEnabled())</span><br><span class="line">                        log.debug(<span class="string">&quot;  Loading class from parent&quot;</span>);</span><br><span class="line">                    <span class="keyword">if</span> (resolve)</span><br><span class="line">                        resolveClass(clazz);</span><br><span class="line">                    <span class="keyword">return</span> clazz;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// Ignore</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义tomcat的war包类加载器"><a href="#自定义tomcat的war包类加载器" class="headerlink" title="自定义tomcat的war包类加载器"></a>自定义tomcat的war包类加载器</h3><p><a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://www.cnblogs.com/ITPower/p/13211490.html&source=article&objectId=1706851">https://www.cnblogs.com/ITPower/p/13211490.html</a></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>简单了解HashMap和ConcurrentHashMap</title>
      <link href="/forworl.github.io/2023/12/10/HashMap%E5%92%8CConcurrentHashMap/"/>
      <url>/forworl.github.io/2023/12/10/HashMap%E5%92%8CConcurrentHashMap/</url>
      
        <content type="html"><![CDATA[<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><h4 id="jdk1-7与jdk1-8的区别"><a href="#jdk1-7与jdk1-8的区别" class="headerlink" title="jdk1.7与jdk1.8的区别"></a>jdk1.7与jdk1.8的区别</h4><ul><li><strong>底层数据结构</strong>，jdk1.7为数组 + 链表，jdk1.8为数组 + 链表 + 红黑树</li><li><strong>链表添加元素的位置</strong>，jdk1.7为头插法（循环引用问题），jdk1.8为尾插法</li><li><strong>对于key&#x3D;&#x3D;null的处理</strong>，jdk1.7为添加前独立判断，jdk1.8为综合到hash()函数里面</li><li><strong>先添加再扩容还是先扩容再添加</strong>。jdk1.7为先扩容再添加，jdk1.8为先添加再扩容</li><li><strong>hash()函数的异或次数</strong>，jdk1.7为4次，jdk1.8为1次（高16位和低16位异或）</li></ul><p><strong>jdk1.8要比jdk1.7多一步考虑红黑树的操作</strong></p><ul><li>比如插入考虑树化，删除考虑反树化，查找考虑树的递归查找</li><li>扩容的时候会把每个索引位置后边的链表或者红黑树都拆分成两个部分（i、i + oldcap），比如 1 和 17 在容量为 16 的hashmap都是在索引为1的位置，扩容后 1 还是在索引为 1 的位置，但是 17 到了索引为 17 的位置</li></ul><h4 id="jdk1-7实现"><a href="#jdk1-7实现" class="headerlink" title="jdk1.7实现"></a>jdk1.7实现</h4><h5 id="底层是数组-链表"><a href="#底层是数组-链表" class="headerlink" title="底层是数组 + 链表"></a>底层是数组 + 链表</h5><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20231119161502326.png" alt="image-20231119161502326"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">    <span class="type">int</span> hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>调用inflateTable()方法进行初始化</p><p>初始数组大小默认为16个，负载因子为3&#x2F;4，数组达到负载因子则进行扩容</p><h5 id="hash-函数"><a href="#hash-函数" class="headerlink" title="hash()函数"></a>hash()函数</h5><p>4次异或</p><h5 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h5><ol><li>如果table[]为空，创建table[]数组</li><li>如果key &#x3D;&#x3D; null，会在下标为0位置放入</li><li>通过hash函数计算key的hashCode的hash值</li><li>通过hash值和数组长度-1进行&amp;运算（取模运算），得到key在哪个桶</li><li>如果桶内没有元素，创建新节点，直接插入</li><li>否则判断首元素是否key相同，是的话，进行 value 替换</li><li>否则，进行链表查找插入，如果找到了key相同的元素，进行value替换</li><li>否则插入元素，如果总节点数到达阈值64，先扩容，再头插法添加元素</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化table[]</span></span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// key为null的entry放到下标为0的地方</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 四次异或hashcode</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算存放的数组下标，hash和数组长度减一进行&amp;运算</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(hash, table.length);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从数组下标位置开始，遍历链表</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 比较hash和key，判断这个key是否在链表中</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// key相同，替换链表节点的值</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 当前map元素总数 + 1</span></span><br><span class="line">    modCount++;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果总节点数达到阈值并且当前下标不是null，先扩容，再头插法添加元素</span></span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前hashMap内节点数量达到阈值，并且这个下标的第一个元素不是null</span></span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="literal">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2倍扩容</span></span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 重新计算这个key在新的table[]的下标位置</span></span><br><span class="line">        hash = (<span class="literal">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h5><ol><li>如果key &#x3D;&#x3D; null，会在下标为0位置查询</li><li>通过hash函数计算出key的hashCode的hash值</li><li>如果桶内位置首元素符合，返回结果</li><li>否则遍历链表</li><li>找不到返回null</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// key为null的查找</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> getForNullKey();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历链表查找 </span></span><br><span class="line">    Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span> == entry ? <span class="literal">null</span> : entry.getValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title function_">getEntry</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// hash扰乱</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">    <span class="comment">// 计算出下标后，开始链表遍历</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">         e != <span class="literal">null</span>;</span><br><span class="line">         e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="扩容resize"><a href="#扩容resize" class="headerlink" title="扩容resize()"></a>扩容resize()</h5><ol><li>数组扩容2倍</li><li>调用transfer()函数，遍历所有桶，把每个桶内所有的元素重新rehash到新的数组</li><li>更新扩容阈值</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">int</span> newCapacity)</span> &#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> oldTable.length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 默认以两倍大小扩容</span></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> <span class="title class_">Entry</span>[newCapacity];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重新hash原来的元素放到新的table</span></span><br><span class="line">    transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">    table = newTable;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新扩容阈值</span></span><br><span class="line">    threshold = (<span class="type">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="死链问题"><a href="#死链问题" class="headerlink" title="死链问题"></a>死链问题</h5><p>扩容的时候线程并发产生的循环引用，主要是前插法同时线程并发导致的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Entry[] newTable, <span class="type">boolean</span> rehash)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">null</span> != e) &#123;</span><br><span class="line">        <span class="comment">// 这里很重要</span></span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="literal">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 重新计算下标</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash, newCapacity);</span><br><span class="line">            <span class="comment">// 头插法</span></span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">初始转态：(<span class="number">1</span>) -&gt; (<span class="number">35</span>) -&gt; <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于头插法</span></span><br><span class="line">thread1扩容成功后：(<span class="number">35</span>) -&gt; (<span class="number">1</span>) -&gt; <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// thraed阻塞前的 next 指向的是 (1)，恢复后会把(1)又插到新的数组那个位置的链表头</span></span><br><span class="line">假设thread0卡了一会才进行扩容的时候：(<span class="number">1</span>) -&gt; (<span class="number">35</span>) -&gt; (<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h5 id="数据覆盖问题"><a href="#数据覆盖问题" class="headerlink" title="数据覆盖问题"></a>数据覆盖问题</h5><p>比如A线程判断某个桶内首元素为NULL，准备插入的时候挂起，这时B线程完成插入，等A线程回来，会覆盖掉B线程插入的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><h4 id="jdk1-8实现"><a href="#jdk1-8实现" class="headerlink" title="jdk1.8实现"></a>jdk1.8实现</h4><p>数组 + 链表 + 红黑树</p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20231119161519965.png" alt="image-20231119161519965"></p><h5 id="Node结构"><a href="#Node结构" class="headerlink" title="Node结构"></a>Node结构</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="TreeNode树节点的结构"><a href="#TreeNode树节点的结构" class="headerlink" title="TreeNode树节点的结构"></a>TreeNode树节点的结构</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent; </span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// 初始化成链表用</span></span><br><span class="line">    <span class="type">boolean</span> red;   <span class="comment">//是否是红色节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h5><p>调用resize()方法创建table[]数组</p><p>初始数组大小默认为16个，负载因子为3&#x2F;4，数组达到负载因子则进行扩容</p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240119141432972.png" alt="image-20240119141432972"></p><h5 id="hash-函数-1"><a href="#hash-函数-1" class="headerlink" title="hash()函数"></a>hash()函数</h5><p>取hashCode的高低16位互相异或</p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240119141215145.png" alt="image-20240119141215145"></p><h5 id="put-1"><a href="#put-1" class="headerlink" title="put()"></a>put()</h5><ol><li>通过hash函数计算出key的hashCode的hash值</li><li>如果table[]为空，通过resize()方法创建table[]数组</li><li>通过hash值和数组长度-1进行&amp;运算，得到key在哪个桶</li><li>桶为空，创建新节点，直接插入</li><li>否则判断首元素是否key相同，是的话，进行 value 替换</li><li>否则判断首元素是否是TreeNode，是的话，红黑树查询插入</li><li>否则，进行链表查询插入，如果中途找到了key相同的元素，那么进行value替换</li><li>否则添加元素，添加完之后判断是否需要树化</li><li>++size &gt; threshold，判断是否需要扩容</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">++size &gt; threshold</span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">               <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// table[]为null，调用resize()创建table[]数组</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 如果对应下标没有元素，那么直接创建节点</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 红黑树查找</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 链表查找</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 尾插法</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 链表节点数量到达8，考虑树化，不一定树化，还需要总节点数到达64</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// p是用来遍历的指针，前面e = p.next，即p = p.next</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// key已经在hashMap中存在，只需要替换value即可</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; </span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 检查是否需要扩容，和JDK1.7相反，是先插入再检查是否需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="红黑树插入putTreeVal"><a href="#红黑树插入putTreeVal" class="headerlink" title="红黑树插入putTreeVal()"></a>红黑树插入putTreeVal()</h5><p>根据hash值来排序，放左边或者右边</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title function_">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span><br><span class="line"><span class="params">                               <span class="type">int</span> h, K k, V v)</span> &#123;</span><br><span class="line">    Class&lt;?&gt; kc = <span class="literal">null</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">searched</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    TreeNode&lt;K,V&gt; root = (parent != <span class="literal">null</span>) ? root() : <span class="built_in">this</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从根节点开始遍历红黑树</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">        <span class="type">int</span> dir, ph; K pk;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 根据hash值判断放左边还是右边</span></span><br><span class="line">        <span class="comment">// ph是当前遍历节点的 hash，h是要放置的目标节点的hash</span></span><br><span class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">            dir = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">            dir = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// hash相同，如果key相等，return p，外面的函数会对这个节点进行value覆盖</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="literal">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="comment">// hash相同，则由Comparable接口的比较方法判定</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                  (kc = comparableClassFor(k)) == <span class="literal">null</span>) ||</span><br><span class="line">                 (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 在左右子树递归的寻找 是否有key的hash相同，并且equals相同的节点</span></span><br><span class="line">            <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                searched = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (((ch = p.left) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                     (q = ch.find(h, k, kc)) != <span class="literal">null</span>) ||</span><br><span class="line">                    ((ch = p.right) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                     (q = ch.find(h, k, kc)) != <span class="literal">null</span>))</span><br><span class="line">                    <span class="keyword">return</span> q;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 否则，通过Native方法，决定放置的位置</span></span><br><span class="line">            dir = tieBreakOrder(k, pk);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入节点</span></span><br><span class="line">        TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历找到一个叶子节点为空的节点</span></span><br><span class="line">        <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="literal">null</span>) &#123;</span><br><span class="line">            Node&lt;K,V&gt; xpn = xp.next;</span><br><span class="line">            TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 根据dir在左边还是右边插入新节点</span></span><br><span class="line">            <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                xp.left = x;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                xp.right = x;</span><br><span class="line">            <span class="comment">// 还需要维护节点之间的前后关系，这里似乎同时是在维护双向链表关系</span></span><br><span class="line">            xp.next = x;</span><br><span class="line">            x.parent = x.prev = xp;</span><br><span class="line">            <span class="keyword">if</span> (xpn != <span class="literal">null</span>)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// balanceInsertion保证红黑树平衡</span></span><br><span class="line">            moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="get-1"><a href="#get-1" class="headerlink" title="get()"></a>get()</h5><ol><li>通过hash函数计算出key的hashCode的hash值</li><li>如果桶内首元素符合，返回结果</li><li>首元素是否是TreeNode，是的话，红黑树搜索</li><li>否则遍历链表</li><li>找不到返回null</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n, hash; K k;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// first代表下标位置首个元素</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; (hash = hash(key))]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果下标位置首个元素就符合，返回</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 否则</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历红黑树</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">                </span><br><span class="line">            <span class="comment">// e为指针遍历链表</span></span><br><span class="line">            <span class="comment">// 因为判断下标首个元素和遍历链表分开了，所以用do while循环</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找不到</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="红黑树搜索getTreeNode"><a href="#红黑树搜索getTreeNode" class="headerlink" title="红黑树搜索getTreeNode()"></a>红黑树搜索getTreeNode()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title function_">getTreeNode</span><span class="params">(<span class="type">int</span> h, Object k)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ((parent != <span class="literal">null</span>) ? root() : <span class="built_in">this</span>).find(h, k, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title function_">find</span><span class="params">(<span class="type">int</span> h, Object k, Class&lt;?&gt; kc)</span> &#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; p = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">// 不断遍历红黑树查找</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="type">int</span> ph, dir; K pk;</span><br><span class="line">        TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;</span><br><span class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">            p = pl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">            p = pr;</span><br><span class="line">        <span class="comment">// 如果key相同就返回节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="literal">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pl == <span class="literal">null</span>)</span><br><span class="line">            p = pr;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="literal">null</span>)</span><br><span class="line">            p = pl;</span><br><span class="line">        <span class="comment">// 调用Compare接口比较</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc != <span class="literal">null</span> ||</span><br><span class="line">                  (kc = comparableClassFor(k)) != <span class="literal">null</span>) &amp;&amp;</span><br><span class="line">                 (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>)</span><br><span class="line">            p = (dir &lt; <span class="number">0</span>) ? pl : pr;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((q = pr.find(h, k, kc)) != <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> q;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p = pl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (p != <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="扩容resize-1"><a href="#扩容resize-1" class="headerlink" title="扩容resize()"></a>扩容resize()</h5><p>如果是初始化，会默认初始化容量和加载因子</p><p>正常扩容的话</p><ol><li><p>数组两倍扩容</p></li><li><p>遍历所有桶，重新rehash桶内所有的元素</p><ol><li><p>当前桶内位置的首元素后面没有链表或者树，直接插入到新数组</p></li><li><p>首元素后面是红黑树的话，执行split()函数，遍历树所有节点，分成两部分，如果某个部分元素个数&lt;&#x3D;6，那么退化为链表</p></li><li><p>首元素后面是链表的话，根据e.hash &amp; oldCap &#x3D;&#x3D; 0，将链表分成lo，hi两个链表，一点点优化（不用rehash），分别放在下标为 j 和 j + oldCap位置</p></li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 两倍扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化走这里，默认初始化</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历Entry数组，开始扩容 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 当前下标的首元素后面没有链表或者树，直接插入</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    </span><br><span class="line">                <span class="comment">// 当前下标的首元素后面是树</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                    </span><br><span class="line">                <span class="comment">// 当前下标的首元素后面是链表</span></span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 尾插法插入</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// e.hash &amp; oldCap == 0，意思是找到分离点</span></span><br><span class="line">                        <span class="comment">// 比如oldCap = 8(1000)，如果结果为0，那么e.hash首位是0，即0~7(0111)</span></span><br><span class="line">                        <span class="comment">// lo链表放在原位置，hi链表放在j + oldCap</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 首个元素为空，直接插入</span></span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="comment">// 链表尾部插入</span></span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            <span class="comment">// 修改链表尾部</span></span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// e指针往后移动，遍历原数组当前下标的链表</span></span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 让链表尾部指向null</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="树化treeifyBin"><a href="#树化treeifyBin" class="headerlink" title="树化treeifyBin()"></a>树化treeifyBin()</h5><ol><li>遍历原链表，把Node转为TreeNode，来创建一个TreeNode链表</li><li>遍历TreeNode链表，把每个TreeNode加入到红黑树当中</li><li>没有根节点，直接创建新的根节点，颜色为黑色</li><li>否则从根节点开始遍历，对比当前节点和叶子节点的hash值得出不同的dir，判断叶子节点插入当前节点左边（-1）还是右边（1），并且要进行左旋或者右旋，来维护红黑树的特性</li><li>确保给定的根节点是所在桶的第一个节点</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> hash)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// hd指向链表头，tl指向链表尾部</span></span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// new一个TreeNode</span></span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="literal">null</span>);</span><br><span class="line">            <span class="comment">// 尾插法构造TreeNode链表</span></span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="literal">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 把链表转成树</span></span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="literal">null</span>)</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> &#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; root = <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历TreeNode链表</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="built_in">this</span>, next; x != <span class="literal">null</span>; x = next) &#123;</span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">        x.left = x.right = <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 构造黑色根节点</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            x.parent = <span class="literal">null</span>;</span><br><span class="line">            x.red = <span class="literal">false</span>;</span><br><span class="line">            root = x;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 已经设置了根节点了</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// x是当前TreeNode节点</span></span><br><span class="line">            <span class="type">K</span> <span class="variable">k</span> <span class="operator">=</span> x.key;</span><br><span class="line">            <span class="comment">// h是当前节点的hash值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> x.hash;</span><br><span class="line">            Class&lt;?&gt; kc = <span class="literal">null</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 从根节点开始遍历 准备插入叶子节点</span></span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">                <span class="type">int</span> dir, ph;</span><br><span class="line">                <span class="type">K</span> <span class="variable">pk</span> <span class="operator">=</span> p.key;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 父节点和当前节点比较hash值</span></span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    <span class="comment">// 父节点的hash值大于当前节点hash，插入左边</span></span><br><span class="line">                    dir = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    <span class="comment">// 否则插入右边</span></span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                          (kc = comparableClassFor(k)) == <span class="literal">null</span>) ||</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line">                </span><br><span class="line"><span class="comment">// 父节点</span></span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 根据上面的dir判断插入哪边</span></span><br><span class="line">                <span class="comment">// 假设为左边，左边是null就插入，不为null就继续遍历</span></span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 插入</span></span><br><span class="line">                    x.parent = xp;</span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                        xp.left = x;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 平衡二叉树，执行左旋还是右旋</span></span><br><span class="line">                    root = balanceInsertion(root, x);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 确保给定的根节点是所在桶的第一个节点</span></span><br><span class="line">    moveRootToFront(tab, root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="取消树化untreeify"><a href="#取消树化untreeify" class="headerlink" title="取消树化untreeify()"></a>取消树化untreeify()</h5><p>TreeNode转Node，树转成链表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt; untreeify(HashMap&lt;K,V&gt; map) &#123;</span><br><span class="line">        Node&lt;K,V&gt; hd = null, tl = null;</span><br><span class="line">        for (Node&lt;K,V&gt; q = this; q != null; q = q.next) &#123;</span><br><span class="line">            Node&lt;K,V&gt; p = map.replacementNode(q, null);</span><br><span class="line">            if (tl == null)</span><br><span class="line">                hd = p;</span><br><span class="line">            else</span><br><span class="line">                tl.next = p;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125;</span><br><span class="line">        return hd;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="维护红黑树特性balanceInsertion"><a href="#维护红黑树特性balanceInsertion" class="headerlink" title="维护红黑树特性balanceInsertion()"></a>维护红黑树特性balanceInsertion()</h5><p>可能涉及左旋或者右旋</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; TreeNode&lt;K,V&gt; <span class="title function_">balanceInsertion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span><br><span class="line"><span class="params">                                            TreeNode&lt;K,V&gt; x)</span> &#123;</span><br><span class="line">    <span class="comment">// 当前节点先设为红色，后面会调整的</span></span><br><span class="line">    x.red = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * x: 　  当前节点</span></span><br><span class="line"><span class="comment">     * xp: 　 x的父节点</span></span><br><span class="line"><span class="comment">     * xpp: 　x父节点的父节点</span></span><br><span class="line"><span class="comment">     * xppl:　x父节点的父节点左子节点</span></span><br><span class="line"><span class="comment">     * xppr:　x父节点的父节点右子节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 插入的是根节点，直接是黑色</span></span><br><span class="line">        <span class="keyword">if</span> ((xp = x.parent) == <span class="literal">null</span>) &#123;</span><br><span class="line">            x.red = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 插入节点的父节点是黑色或者是根节点，红黑树没有被破坏，不需要调整</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!xp.red || (xpp = xp.parent) == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 父节点是红色</span></span><br><span class="line">        <span class="comment">// 父节点是祖父节点的左节点</span></span><br><span class="line">        <span class="keyword">if</span> (xp == (xppl = xpp.left)) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 叔叔节点存在且为红色，同时父节点也是红色</span></span><br><span class="line">            <span class="keyword">if</span> ((xppr = xpp.right) != <span class="literal">null</span> &amp;&amp; xppr.red) &#123;</span><br><span class="line">                <span class="comment">// (3)</span></span><br><span class="line">                <span class="comment">// 父节点和叔叔节点都改为黑色</span></span><br><span class="line">                <span class="comment">// 祖父节点改成红色</span></span><br><span class="line">                <span class="comment">// 当前节点变成祖父节点</span></span><br><span class="line">                xppr.red = <span class="literal">false</span>;</span><br><span class="line">                xp.red = <span class="literal">false</span>;</span><br><span class="line">                xpp.red = <span class="literal">true</span>;</span><br><span class="line">                x = xpp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 叔叔节点为黑色</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// (5)当前节点的父节点是红色，且叔叔节点是黑色，当前节点是其父右子节点</span></span><br><span class="line">                <span class="keyword">if</span> (x == xp.right) &#123;</span><br><span class="line">                    <span class="comment">// 左旋转</span></span><br><span class="line">                    root = rotateLeft(root, x = xp);</span><br><span class="line">                    xpp = (xp = x.parent) == <span class="literal">null</span> ? <span class="literal">null</span> : xp.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// (4)</span></span><br><span class="line">                <span class="keyword">if</span> (xp != <span class="literal">null</span>) &#123;</span><br><span class="line">                    xp.red = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (xpp != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 右旋转</span></span><br><span class="line">                        xpp.red = <span class="literal">true</span>;</span><br><span class="line">                        root = rotateRight(root, xpp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 父节点是祖父节点的右节点，流程和上面一样，只是换了个方向而已</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (xppl != <span class="literal">null</span> &amp;&amp; xppl.red) &#123;</span><br><span class="line">                xppl.red = <span class="literal">false</span>;</span><br><span class="line">                xp.red = <span class="literal">false</span>;</span><br><span class="line">                xpp.red = <span class="literal">true</span>;</span><br><span class="line">                x = xpp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// (7)</span></span><br><span class="line">                <span class="keyword">if</span> (x == xp.left) &#123;</span><br><span class="line">                    <span class="comment">// 右旋转</span></span><br><span class="line">                    root = rotateRight(root, x = xp);</span><br><span class="line">                    xpp = (xp = x.parent) == <span class="literal">null</span> ? <span class="literal">null</span> : xp.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// (6)</span></span><br><span class="line">                <span class="keyword">if</span> (xp != <span class="literal">null</span>) &#123;</span><br><span class="line">                    xp.red = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (xpp != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 左旋转</span></span><br><span class="line">                        xpp.red = <span class="literal">true</span>;</span><br><span class="line">                        root = rotateLeft(root, xpp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; TreeNode&lt;K,V&gt; <span class="title function_">rotateLeft</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span><br><span class="line"><span class="params">                                      TreeNode&lt;K,V&gt; p)</span> &#123;</span><br><span class="line">    <span class="comment">// p: 当前节点</span></span><br><span class="line">    <span class="comment">// r: 当前节点的右儿子</span></span><br><span class="line">    <span class="comment">// rl: 当前节点的右儿子的左儿子</span></span><br><span class="line">    TreeNode&lt;K,V&gt; r, pp, rl;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">null</span> &amp;&amp; (r = p.right) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前节点的右儿子的左儿子成为当前节点的右儿子</span></span><br><span class="line">        <span class="keyword">if</span> ((rl = p.right = r.left) != <span class="literal">null</span>)</span><br><span class="line">            rl.parent = p;</span><br><span class="line">        <span class="comment">// 当前节点的右儿子成为当前节点的父节点</span></span><br><span class="line">        <span class="keyword">if</span> ((pp = r.parent = p.parent) == <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">// 如果当前节点是根节点，那么r的颜色必须是黑色</span></span><br><span class="line">            (root = r).red = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pp.left == p)</span><br><span class="line">            pp.left = r;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.right = r;</span><br><span class="line">        r.left = p;</span><br><span class="line">        p.parent = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; TreeNode&lt;K,V&gt; <span class="title function_">rotateRight</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span><br><span class="line"><span class="params">                                       TreeNode&lt;K,V&gt; p)</span> &#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; l, pp, lr;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">null</span> &amp;&amp; (l = p.left) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((lr = p.left = l.right) != <span class="literal">null</span>)</span><br><span class="line">            lr.parent = p;</span><br><span class="line">        <span class="keyword">if</span> ((pp = l.parent = p.parent) == <span class="literal">null</span>)</span><br><span class="line">            (root = l).red = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pp.right == p)</span><br><span class="line">            pp.right = l;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.left = l;</span><br><span class="line">        l.right = p;</span><br><span class="line">        p.parent = l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="左旋右旋"><a href="#左旋右旋" class="headerlink" title="左旋右旋"></a>左旋右旋</h5><p>以下红黑树部分参考<a href="https://blog.csdn.net/lyj1597374034/article/details/106880991">HashMap源码分析putTreeVal（红黑树部分）——java学习总结（11）-CSDN博客</a></p><p><strong>插入的节点一开始默认都为红色，左左（指的是父节点是祖父节点的左孩子，自己是父节点的左孩子）</strong></p><ul><li>无需调整：父节点是黑色</li><li>变色：父节点是红色并且叔父节点也是红色</li><li>变色 + 旋转：父节点是红色，叔父节点是黑色</li></ul><table><thead><tr><th><strong>无需调整</strong></th><th><strong>【变色】即可实现平衡</strong></th><th><strong>【旋转+变色】才可实现平衡</strong></th></tr></thead><tbody><tr><td>(1)当父节点为黑色时直接插入子节点</td><td>(2)空树插入根节点，将根节点红色变为黑色</td><td>(4)父节点为红色左节点，叔父节点为黑色，插入左子节点，那么通过【左左节点旋转】</td></tr><tr><td></td><td>(3)父节点和叔父节点都为红色，则将父节点和叔父结点置为黑色，再将祖父结点置为红色，再递归向上处理（将祖父结点视为新插入的结点，将父节点和叔父节点看作黑色的null）</td><td>(5)父节点为红色左节点，叔父节点为黑色，插入右子节点，那么通过【左右节点旋转】</td></tr><tr><td></td><td></td><td>(6)父节点为红色右节点，叔父节点为黑色，插入左子节点，那么通过【右左节点旋转】</td></tr><tr><td></td><td></td><td>(7)父节点为红色右节点，叔父节点为黑色，插入右子节点，那么通过【右右节点旋转】</td></tr></tbody></table><p>(4)左左节点旋转</p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20231210103427316.png" alt="image-20231210103427316"></p><p>(5)左右节点旋转</p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20231210103656888.png" alt="image-20231210103656888"></p><p>(6)右左节点旋转</p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20231210103708774.png" alt="image-20231210103708774"></p><p>(7)右右节点旋转</p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20231210103439118.png" alt="image-20231210103439118"></p><h5 id="数据覆盖问题-1"><a href="#数据覆盖问题-1" class="headerlink" title="数据覆盖问题"></a>数据覆盖问题</h5><p>比如A线程判断某个桶内首元素为NULL，准备插入的时候挂起，这时B线程完成插入，等A线程回来，会覆盖掉B线程插入的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>ConcurrentHashMap是线程并发安全的hashmap，所以他会解决hashmap的一些线程问题（使用CAS或者锁），比如jdk1.7的循环引用问题或者说是数据覆盖问题</p><h4 id="jdk1-7与jdk1-8的区别-1"><a href="#jdk1-7与jdk1-8的区别-1" class="headerlink" title="jdk1.7与jdk1.8的区别"></a>jdk1.7与jdk1.8的区别</h4><p>jdk1.7可以理解为hashmap拆成了很多份，把每个小的hashmap锁起来了，只有获取到锁才能写这个小的hashmap，读不受影响</p><p>jdk1.8沿用了原生的hashmap，只不过在写操作的时候，索引首元素用CAS，首元素后面的插入会用synchronized锁起来</p><ul><li><strong>数据结构</strong>：取消了 Segment 分段锁的数据结构，取而代之的是数组+链表+红黑树的结构。</li><li><strong>保证线程安全机制</strong>：JDK1.7 采用 Segment 的分段锁机制实现线程安全，其中 Segment 继承自 CAS + ReentrantLock 。JDK1.8 采用CAS + synchronized保证线程安全。</li><li><strong>锁的粒度降低</strong>：JDK1.7 是对需要进行数据操作的 Segment 加锁，JDK1.8 调整为对每个数组元素加锁（Node）。</li></ul><h4 id="jdk1-7实现-1"><a href="#jdk1-7实现-1" class="headerlink" title="jdk1.7实现"></a>jdk1.7实现</h4><p><strong>segment数组 + hashEntry数组 + 链表</strong></p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20231106234127885.png" alt="image-20231106234127885"></p><h5 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h5><ul><li>初始化segment数组的大小，默认为16，如果不是2^n，则向上取整（比如segment数组的大小传入10，其实还是16）</li><li>初始化entry数组的大小，默认是2，同样需要向上取整，为什么要向上取整，因为hash函数要与操作</li><li>然后segment数组首个元素先创造一个segment对象，方便之后put()快速创建新的segment对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// initialCapacity是entry数组的初始容量</span></span><br><span class="line"><span class="comment">// concurrencyLevel是segment数组的初始容量</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(<span class="type">int</span> initialCapacity,</span></span><br><span class="line"><span class="params">                         <span class="type">float</span> loadFactor, <span class="type">int</span> concurrencyLevel)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">        concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line">    <span class="comment">// Find power-of-two sizes best matching arguments</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sshift</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// segment数组的长度，一定是2的倍数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ssize</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">        ++sshift;</span><br><span class="line">        ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">    <span class="built_in">this</span>.segmentMask = ssize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="comment">// c代表每个entry数组至少要有的初始容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> initialCapacity / ssize;</span><br><span class="line">    <span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">        ++c;</span><br><span class="line">    <span class="comment">// 和c比较，找到entry数组的初始容量cap，一定是2的倍数，最小是2</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> MIN_SEGMENT_TABLE_CAPACITY;</span><br><span class="line">    <span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">        cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 创建 segments and segments[0]，创建segments[0]是为了加快以后创建segment[?]</span></span><br><span class="line">    Segment&lt;K,V&gt; s0 =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Segment</span>&lt;K,V&gt;(loadFactor, (<span class="type">int</span>)(cap * loadFactor),</span><br><span class="line">                         (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">HashEntry</span>[cap]);</span><br><span class="line">    Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Segment</span>[ssize];</span><br><span class="line">    UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="comment">// ordered write of segments[0]</span></span><br><span class="line">    <span class="built_in">this</span>.segments = ss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="put-2"><a href="#put-2" class="headerlink" title="put()"></a>put()</h5><ol><li><p>通过第一次hash函数（hashcode和segment数组长度减一进行与运算）算出key对应的segment数组的下标</p></li><li><p>判断这个位置是否需要创建segment对象，如果需要，获取segment[0]的信息可以快速创建segment对象，通过<strong>CAS</strong>保证<strong>创建segment对象</strong>是并发安全的</p></li><li><p><strong>trylock()<strong>尝试上锁，获取锁成功才能</strong>插入元素</strong>，否则进入自旋锁操作（期间可以遍历链表，看看是否要创建新元素，如果别的线程插入修改了链表的头节点，就去重新遍历链表，如果自旋次数太多就阻塞）</p></li><li><p>获取锁成功的话</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Segment&lt;K,V&gt; <span class="title function_">ensureSegment</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] ss = <span class="built_in">this</span>.segments;</span><br><span class="line">    <span class="type">long</span> <span class="variable">u</span> <span class="operator">=</span> (k &lt;&lt; SSHIFT) + SBASE; <span class="comment">// raw offset</span></span><br><span class="line">    Segment&lt;K,V&gt; seg;</span><br><span class="line">    <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 构造器有先创建segment[0]，这时候获取，方便快速生成segment[?]</span></span><br><span class="line">        Segment&lt;K,V&gt; proto = ss[<span class="number">0</span>]; <span class="comment">// use segment 0 as prototype</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> proto.table.length;</span><br><span class="line">        <span class="type">float</span> <span class="variable">lf</span> <span class="operator">=</span> proto.loadFactor;</span><br><span class="line">        <span class="type">int</span> <span class="variable">threshold</span> <span class="operator">=</span> (<span class="type">int</span>)(cap * lf);</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">HashEntry</span>[cap];</span><br><span class="line">        <span class="comment">// 双重检查，避免调用UNSAFE开销</span></span><br><span class="line">        <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">            == <span class="literal">null</span>) &#123; <span class="comment">// recheck</span></span><br><span class="line">            Segment&lt;K,V&gt; s = <span class="keyword">new</span> <span class="title class_">Segment</span>&lt;K,V&gt;(lf, threshold, tab);</span><br><span class="line">            <span class="comment">// 自旋的CAS操作compareAndSwapObject，尝试创建segment[?]，保证只有一个线程创建成功</span></span><br><span class="line">            <span class="keyword">while</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">                   == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(ss, u, <span class="literal">null</span>, seg = s))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> seg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">put</span><span class="params">(K key, <span class="type">int</span> hash, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用lock.tryLock()尝试获取锁，有了锁才能进行写操作，保证线程安全</span></span><br><span class="line">    <span class="comment">// 如果获取锁失败，调用scanAndLockForPut()等待</span></span><br><span class="line">    HashEntry&lt;K,V&gt; node = tryLock() ? <span class="literal">null</span> :</span><br><span class="line">        scanAndLockForPut(key, hash, value);</span><br><span class="line">    V oldValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="comment">// 计算出key在entry数组的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">        <span class="comment">// 遍历链表</span></span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                K k;</span><br><span class="line">                <span class="comment">// 如果key相同，则覆盖旧value</span></span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                    (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    oldValue = e.value;</span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                        e.value = value;</span><br><span class="line">                        ++modCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                e = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (node != <span class="literal">null</span>)</span><br><span class="line">                    node.setNext(first);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    node = <span class="keyword">new</span> <span class="title class_">HashEntry</span>&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> count + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// entry数组当前元素到达阈值threshold，entry数组扩容</span></span><br><span class="line">                <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    rehash(node);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// 找到了空位，直接放到entry数组对应位置</span></span><br><span class="line">                    setEntryAt(tab, index, node);</span><br><span class="line">                ++modCount;</span><br><span class="line">                count = c;</span><br><span class="line">                oldValue = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="获取锁的自旋操作scanAndLockForPut"><a href="#获取锁的自旋操作scanAndLockForPut" class="headerlink" title="获取锁的自旋操作scanAndLockForPut()"></a>获取锁的自旋操作scanAndLockForPut()</h5><p><strong>先做一些准备工作，直到获取锁</strong></p><ol><li>准备个新节点，找到它的位置</li><li>获取锁一直失败导致循环次数太多，那么直接lock()阻塞</li><li>偶数次循环的时候如果发现链表头节点变化，那么重新遍历</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> HashEntry&lt;K,V&gt; <span class="title function_">scanAndLockForPut</span><span class="params">(K key, <span class="type">int</span> hash, V value)</span> &#123;</span><br><span class="line">    HashEntry&lt;K,V&gt; first = entryForHash(<span class="built_in">this</span>, hash);</span><br><span class="line">    HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">    HashEntry&lt;K,V&gt; node = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 用于记录获取锁的次数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">retries</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// negative while locating node</span></span><br><span class="line">    <span class="comment">// 如果获取失败，就会去进行一些准备工作</span></span><br><span class="line">    <span class="keyword">while</span> (!tryLock()) &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt; f; <span class="comment">// to recheck first below</span></span><br><span class="line">        <span class="keyword">if</span> (retries &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// entry数组该位置没有元素，先准备个新节点，让获取锁后插入速度更快</span></span><br><span class="line">            <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="comment">// speculatively create node</span></span><br><span class="line">                    node = <span class="keyword">new</span> <span class="title class_">HashEntry</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断 key 是否有重复的，进行替换value就好了</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (key.equals(e.key))</span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 否则顺着链表往下走</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                e = e.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重试次数太多，使用lock()阻塞方法，避免CPU空转，消耗CPU资源</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class="line">            lock();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// (retries &amp; 1) == 0 是偶数次数才进行后面的判断</span></span><br><span class="line">        <span class="comment">// f = entryForHash(this, hash)) != first 新元素插入使得表头被改变了</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((retries &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                 (f = entryForHash(<span class="built_in">this</span>, hash)) != first) &#123;</span><br><span class="line">            <span class="comment">// 修改当前节点，重新开始遍历</span></span><br><span class="line">            e = first = f; <span class="comment">// re-traverse if entry changed</span></span><br><span class="line">            retries = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将准备工作制作好的节点返回</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="get-2"><a href="#get-2" class="headerlink" title="get()"></a>get()</h5><p><strong>无锁，因为Node的value和next是用volatile修饰了，其他线程的修改对本线程可见</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Segment&lt;K,V&gt; s; <span class="comment">// manually integrate access methods to reduce overhead</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hash(key);</span><br><span class="line">    <span class="comment">// 计算segment的下标位置</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">u</span> <span class="operator">=</span> (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">    <span class="comment">// UNSAFE.getObjectVolatile()保证segment可见性</span></span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        (tab = s.table) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历查找</span></span><br><span class="line">        <span class="comment">// UNSAFE.getObjectVolatile()确保不会和写操作产生并发问题</span></span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br><span class="line">                 (tab, ((<span class="type">long</span>)(((tab.length - <span class="number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">             e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">            K k;</span><br><span class="line">            <span class="keyword">if</span> ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))</span><br><span class="line">                <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="扩容机制rehash"><a href="#扩容机制rehash" class="headerlink" title="扩容机制rehash()"></a>扩容机制rehash()</h5><p>segment数组大小初始化之后不会改变，hashentry数组的扩容和hashMap一样</p><p><strong>遍历一遍链表，找到一个lastRun&#x2F;lastIdx（通过hashCode &amp; oldtable.length看1、0），这个节点以后都是要rehash到相同位置的</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rehash</span><span class="params">(HashEntry&lt;K,V&gt; node)</span> &#123;</span><br><span class="line">    HashEntry&lt;K,V&gt;[] oldTable = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> oldTable.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    threshold = (<span class="type">int</span>)(newCapacity * loadFactor);</span><br><span class="line">    HashEntry&lt;K,V&gt;[] newTable =</span><br><span class="line">        (HashEntry&lt;K,V&gt;[]) <span class="keyword">new</span> <span class="title class_">HashEntry</span>[newCapacity];</span><br><span class="line">    <span class="type">int</span> <span class="variable">sizeMask</span> <span class="operator">=</span> newCapacity - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; oldCapacity ; i++) &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt; e = oldTable[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="comment">// idx 是要存放的新的下标位置</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> e.hash &amp; sizeMask;</span><br><span class="line">            <span class="comment">// 只有1个节点，直接放入就好了</span></span><br><span class="line">            <span class="keyword">if</span> (next == <span class="literal">null</span>)   <span class="comment">//  Single node on list</span></span><br><span class="line">                newTable[idx] = e;</span><br><span class="line">            <span class="comment">// 遍历链表</span></span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// Reuse consecutive sequence at same slot</span></span><br><span class="line">                HashEntry&lt;K,V&gt; lastRun = e;</span><br><span class="line">                <span class="type">int</span> <span class="variable">lastIdx</span> <span class="operator">=</span> idx;</span><br><span class="line">                <span class="comment">// 找到一个lastRun，这个节点后面都是一起要放到newTable[?]或者newTable[? + oldcap]</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; last = next;</span><br><span class="line">                     last != <span class="literal">null</span>;</span><br><span class="line">                     last = last.next) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> last.hash &amp; sizeMask;</span><br><span class="line">                    <span class="comment">// 这里的意思是后续节点必须计算下标是同一个下标</span></span><br><span class="line">                    <span class="comment">// 要么都是?，要么都是? + oldcap，不断更新lastRun</span></span><br><span class="line">                    <span class="keyword">if</span> (k != lastIdx) &#123;</span><br><span class="line">                        lastIdx = k;</span><br><span class="line">                        lastRun = last;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 虽然会多遍历1次链表，但是如果lastRun在链表前半部分，这样节省很多功夫</span></span><br><span class="line">                newTable[lastIdx] = lastRun;</span><br><span class="line">                <span class="comment">// lastRun之前的节点遍历放到正确位置</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;</span><br><span class="line">                    <span class="type">V</span> <span class="variable">v</span> <span class="operator">=</span> p.value;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> p.hash;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> h &amp; sizeMask;</span><br><span class="line">                    HashEntry&lt;K,V&gt; n = newTable[k];</span><br><span class="line">                    newTable[k] = <span class="keyword">new</span> <span class="title class_">HashEntry</span>&lt;K,V&gt;(h, p.key, v, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将新的 node 放到新数组中刚刚的两个链表之一的头部</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">nodeIndex</span> <span class="operator">=</span> node.hash &amp; sizeMask; <span class="comment">// add the new node</span></span><br><span class="line">    node.setNext(newTable[nodeIndex]);</span><br><span class="line">    newTable[nodeIndex] = node;</span><br><span class="line">    table = newTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">remove</span><span class="params">(Object key, <span class="type">int</span> hash, Object value)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    <span class="keyword">if</span> (!tryLock())</span><br><span class="line">        scanAndLock(key, hash);</span><br><span class="line">    <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="comment">// 计算下标位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        HashEntry&lt;K,V&gt; e = entryAt(tab, index);</span><br><span class="line">        <span class="comment">// 前驱节点，用来删除元素</span></span><br><span class="line">        HashEntry&lt;K,V&gt; pred = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 遍历链表</span></span><br><span class="line">        <span class="keyword">while</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            K k;</span><br><span class="line">            HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="comment">// 找到了被删除的元素</span></span><br><span class="line">            <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                <span class="type">V</span> <span class="variable">v</span> <span class="operator">=</span> e.value;</span><br><span class="line">                <span class="keyword">if</span> (value == <span class="literal">null</span> || value == v || value.equals(v)) &#123;</span><br><span class="line">                    <span class="comment">// 只有下标一个元素，下标位置置为null</span></span><br><span class="line">                    <span class="keyword">if</span> (pred == <span class="literal">null</span>)</span><br><span class="line">                        setEntryAt(tab, index, next);</span><br><span class="line">                    <span class="comment">// 删除节点</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        pred.setNext(next);</span><br><span class="line">                    ++modCount;</span><br><span class="line">                    --count;</span><br><span class="line">                    oldValue = v;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pred = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="jdk1-8实现-1"><a href="#jdk1-8实现-1" class="headerlink" title="jdk1.8实现"></a>jdk1.8实现</h4><p>node数组 + 链表 + 红黑树</p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20231115091437557.png" alt="image-20231115091437557"></p><h5 id="初始化-3"><a href="#初始化-3" class="headerlink" title="初始化"></a>初始化</h5><p>如果node数组为空，利用CAS创建node数组，默认大小为16个，默认扩展因子是0.75</p><h5 id="put-3"><a href="#put-3" class="headerlink" title="put()"></a>put()</h5><ol><li>根据 key 计算出 hash</li><li>判断node数组是否已经初始化，没有就初始化node数组</li><li>hash出下标，如果为空，CAS尝试写入</li><li>如果当前位置的 <code>hash == MOVED == -1</code>,则需要进行扩容</li><li>如果都不满足，加synchronized锁，将entry加入链表或者红黑树</li><li>判断是否需要树化</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="type">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            Thread.<span class="keyword">yield</span>(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="comment">// CAS操作创建</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSetInt(<span class="built_in">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh; K fk; V fv;</span><br><span class="line">        <span class="comment">// node数组为空，先创建ndoe数组</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="comment">// 下标位置没有元素，CAS尝试放入</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 树化或者在扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (onlyIfAbsent <span class="comment">// check first node without acquiring lock</span></span><br><span class="line">                 &amp;&amp; fh == hash</span><br><span class="line">                 &amp;&amp; ((fk = f.key) == key || (fk != <span class="literal">null</span> &amp;&amp; key.equals(fk)))</span><br><span class="line">                 &amp;&amp; (fv = f.val) != <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> fv;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 当前node加synchronized锁，后面的操作和HashMap基本一样了</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> ReservationNode)</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Recursive update&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断链表是否需要树化</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 里面看看是否需要扩容</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="get-3"><a href="#get-3" class="headerlink" title="get()"></a>get()</h5><p><strong>无锁，因为Node的value和next是用volatile修饰了，其他线程的修改对本线程可见</strong></p><ol><li>根据key计算出hash</li><li>查找到指定位置，如果头节点是key相同，直接返回</li><li>如果hash&lt;0，说明在扩容或者是红黑树，查找红黑树</li><li>否则查找链表</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="type">int</span> n, eh; K ek;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 下标位置的节点就是要找的节点</span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在红黑树上或者正在扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="literal">null</span> ? p.val : <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 遍历链表</span></span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找不到返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="扩容机制transfer"><a href="#扩容机制transfer" class="headerlink" title="扩容机制transfer()"></a>扩容机制transfer()</h5><p><strong>运用到了多线程，每个线程默认处理16个桶</strong></p><p>ForwardingNode结构表示这个节点开头的那部分节点们正在迁移，<strong>用CAS操作让线程去取得迁移这个部分节点的权力</strong></p><p>当所有节点迁移完成，finish &#x3D; true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> tab.length, stride;</span><br><span class="line">    <span class="comment">// 做扩容的线程至少处理16个桶</span></span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="literal">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;uncheckzheed&quot;)</span></span><br><span class="line">            <span class="comment">// 容量翻倍</span></span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">nextn</span> <span class="operator">=</span> nextTab.length;</span><br><span class="line">    <span class="comment">// 正在被迁移的 Node</span></span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> <span class="title class_">ForwardingNode</span>&lt;K,V&gt;(nextTab);</span><br><span class="line">    <span class="comment">// 做完了一个位置的迁移工作，可以准备做下一个位置的了</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">advance</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 所有桶是否都已迁移完成</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">finishing</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> fh;</span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">            <span class="type">int</span> nextIndex, nextBound;</span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                advance = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSetInt</span><br><span class="line">                     (<span class="built_in">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                bound = nextBound;</span><br><span class="line">                i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                advance = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            <span class="type">int</span> sc;</span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                nextTable = <span class="literal">null</span>;</span><br><span class="line">                table = nextTab;</span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSetInt(<span class="built_in">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                finishing = advance = <span class="literal">true</span>;</span><br><span class="line">                i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="literal">null</span>)</span><br><span class="line">            advance = casTabAt(tab, i, <span class="literal">null</span>, fwd);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            advance = <span class="literal">true</span>; <span class="comment">// already processed</span></span><br><span class="line">        <span class="comment">// 具体的扩容迁移操作</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 下面这一块和 Java7 中的 ConcurrentHashMap 迁移是差不多的，</span></span><br><span class="line">                        <span class="comment">// 需要将链表一分为二，</span></span><br><span class="line">                        <span class="comment">//   找到原链表中的 lastRun，然后 lastRun 及其之后的节点是一起进行迁移的</span></span><br><span class="line">                        <span class="comment">//   lastRun 之前的节点需要进行克隆，然后分到两个链表中</span></span><br><span class="line">                        <span class="type">int</span> <span class="variable">runBit</span> <span class="operator">=</span> fh &amp; n;</span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="literal">null</span>; p = p.next) &#123;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> p.hash &amp; n;</span><br><span class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = <span class="literal">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = <span class="literal">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">ph</span> <span class="operator">=</span> p.hash; <span class="type">K</span> <span class="variable">pk</span> <span class="operator">=</span> p.key; <span class="type">V</span> <span class="variable">pv</span> <span class="operator">=</span> p.val;</span><br><span class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                ln = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hn = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 红黑树的迁移</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">lc</span> <span class="operator">=</span> <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> e.hash;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">                            <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = loTail) == <span class="literal">null</span>)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = hiTail) == <span class="literal">null</span>)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                         <span class="comment">// 如果一分为二后，节点数少于 8，那么将红黑树转换回链表</span></span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                            (hc != <span class="number">0</span>) ? <span class="keyword">new</span> <span class="title class_">TreeBin</span>&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                            (lc != <span class="number">0</span>) ? <span class="keyword">new</span> <span class="title class_">TreeBin</span>&lt;K,V&gt;(hi) : t;</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> ReservationNode)</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Recursive update&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="remove-1"><a href="#remove-1" class="headerlink" title="remove()"></a>remove()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">replaceNode</span><span class="params">(Object key, V value, Object cv)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span> ||</span><br><span class="line">            (f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">validated</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 获取锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">// 遍历链表</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        validated = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f, pred = <span class="literal">null</span>;;) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                <span class="type">V</span> <span class="variable">ev</span> <span class="operator">=</span> e.val;</span><br><span class="line">                                <span class="keyword">if</span> (cv == <span class="literal">null</span> || cv == ev ||</span><br><span class="line">                                    (ev != <span class="literal">null</span> &amp;&amp; cv.equals(ev))) &#123;</span><br><span class="line">                                    oldVal = ev;</span><br><span class="line">                                    <span class="keyword">if</span> (value != <span class="literal">null</span>)</span><br><span class="line">                                        e.val = value;</span><br><span class="line">                                    <span class="keyword">else</span> <span class="keyword">if</span> (pred != <span class="literal">null</span>)</span><br><span class="line">                                        pred.next = e.next;</span><br><span class="line">                                    <span class="keyword">else</span></span><br><span class="line">                                        setTabAt(tab, i, e.next);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>)</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 遍历红黑树</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        validated = <span class="literal">true</span>;</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; r, p;</span><br><span class="line">                        <span class="keyword">if</span> ((r = t.root) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                            (p = r.findTreeNode(hash, key, <span class="literal">null</span>)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="type">V</span> <span class="variable">pv</span> <span class="operator">=</span> p.val;</span><br><span class="line">                            <span class="keyword">if</span> (cv == <span class="literal">null</span> || cv == pv ||</span><br><span class="line">                                (pv != <span class="literal">null</span> &amp;&amp; cv.equals(pv))) &#123;</span><br><span class="line">                                oldVal = pv;</span><br><span class="line">                                <span class="keyword">if</span> (value != <span class="literal">null</span>)</span><br><span class="line">                                    p.val = value;</span><br><span class="line">                                <span class="keyword">else</span> <span class="keyword">if</span> (t.removeTreeNode(p))</span><br><span class="line">                                    setTabAt(tab, i, untreeify(t.first));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> ReservationNode)</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Recursive update&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (validated) &#123;</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (value == <span class="literal">null</span>)</span><br><span class="line">                        addCount(-<span class="number">1L</span>, -<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java SE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>git</title>
      <link href="/forworl.github.io/2023/12/08/git/"/>
      <url>/forworl.github.io/2023/12/08/git/</url>
      
        <content type="html"><![CDATA[<h1 id="git-结构"><a href="#git-结构" class="headerlink" title="git 结构"></a>git 结构</h1><p>工作区：电脑文件夹目录</p><p>版本库：.git文件夹，git add 添加到暂存区stage，git commit 添加到本地分支</p><p><img src="https://fuleyou-note.oss-cn-guangzhou.aliyuncs.com/noteFile/image-20240128174038886.png" alt="image-20240128174038886"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- test.txt // 用暂存区的代替工作区的</span><br></pre></td></tr></table></figure><h1 id="git-分支操作"><a href="#git-分支操作" class="headerlink" title="git 分支操作"></a>git 分支操作</h1><p><strong>看到分支合并图</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --graph</span><br></pre></td></tr></table></figure><p><strong>提交代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;本次提交的代码功能概括&quot;</span><br></pre></td></tr></table></figure><p><strong>创建分支</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch bugFix</span><br></pre></td></tr></table></figure><p><strong>切换分支</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout bugFix</span><br></pre></td></tr></table></figure><p><strong>合并分支</strong></p><p>1.merge：拿过来</p><p>把bugFix分支的所有提交合并到本分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge bugFix</span><br></pre></td></tr></table></figure><p>2.rebase：放过去（线性的提交历史）</p><p>把当前分支的所有提交合并到main分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase main</span><br></pre></td></tr></table></figure><p>3.cherry-pick：拿你想要部分提交的拿过来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick c1</span><br></pre></td></tr></table></figure><p><strong>HEAD</strong></p><p>可以指向分支或者提交过的节点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HEAD^ 往上一个提交</span><br><span class="line">HEAD~n 往上n个提交</span><br></pre></td></tr></table></figure><p>修改分支节点的位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch -f 待修改分支节点 目标位置</span><br><span class="line">git branch -f main HEAD^ // 将 mian 移动到上一个提交节点</span><br></pre></td></tr></table></figure><p><strong>撤销提交</strong></p><p>本地提交</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD^ // 把当前提交删除了</span><br></pre></td></tr></table></figure><p>远程提交</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert HEAD // 当前提交还存在，不过被跳过了</span><br></pre></td></tr></table></figure><p><strong>标签</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag v0 c1 // 给c1节点打上v0标记</span><br></pre></td></tr></table></figure><h1 id="git-查看记录"><a href="#git-查看记录" class="headerlink" title="git 查看记录"></a>git 查看记录</h1><p>配合 git reset xxx 回退</p><p><strong>查看提交历史</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure><p><strong>查看命令历史</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure><h1 id="和远程仓库相关"><a href="#和远程仓库相关" class="headerlink" title="和远程仓库相关"></a>和远程仓库相关</h1><h2 id="git-本地仓库取消关联到远程仓库"><a href="#git-本地仓库取消关联到远程仓库" class="headerlink" title="git 本地仓库取消关联到远程仓库"></a>git 本地仓库取消关联到远程仓库</h2><p>查看现有的远程连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure><p>取消与现有远程仓库的连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote remove origin</span><br></pre></td></tr></table></figure><p>重新连接远程仓库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin 仓库地址</span><br></pre></td></tr></table></figure><h2 id="git-本地仓库关联到远程仓库"><a href="#git-本地仓库关联到远程仓库" class="headerlink" title="git 本地仓库关联到远程仓库"></a>git 本地仓库关联到远程仓库</h2><p>方式一</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git init（初始化git仓库）</span><br><span class="line">git remote add origin 地址（设置远程remote地址）</span><br><span class="line">git pull origin master（拉取远程仓库master的文件）</span><br><span class="line">git branch --set-upstream-to=origin/master master（将本地master设置为远程master分支）</span><br><span class="line">git add . （将所有变更提交到本地仓库）</span><br><span class="line">git commit -m &#x27;&#x27; （提交注释）</span><br><span class="line">git push（本地仓库推送到远程仓库）</span><br></pre></td></tr></table></figure><p>方式二</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone 地址（克隆远程仓库）</span><br><span class="line">git add . （将所有变更提交到本地仓库）</span><br><span class="line">git commit -m &#x27;&#x27; （提交注释）</span><br><span class="line">git push（本地仓库推送到远程仓库）</span><br></pre></td></tr></table></figure><h1 id="git配置"><a href="#git配置" class="headerlink" title="git配置"></a>git配置</h1><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#配置用户名</span><br><span class="line">git config --global user.name &quot;fuleyou&quot;</span><br><span class="line"></span><br><span class="line">#配置邮箱</span><br><span class="line">git config --global user.email &quot;997679311@qq.com&quot;</span><br><span class="line"></span><br><span class="line">#查询配置</span><br><span class="line">git config --global --list</span><br><span class="line"></span><br><span class="line">#测试连接</span><br><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p><strong>Error：Spawn fail解决方案</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.cd C:\Users\fuleyou\.ssh</span><br><span class="line">2.创建一个config文件</span><br><span class="line">写入</span><br><span class="line">Host github.com</span><br><span class="line">Hostname ssh.github.com</span><br><span class="line">Port 443</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>tomcat和dubbo的线程池</title>
      <link href="/forworl.github.io/2023/12/04/tomcat%E5%92%8Cdubbo%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/forworl.github.io/2023/12/04/tomcat%E5%92%8Cdubbo%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<p><strong>本文主要探讨tomcat线程池以及dubbo线程池和JDK原生线程池的区别</strong></p><h1 id="SpringBoot内置tomcat线程池的实现类"><a href="#SpringBoot内置tomcat线程池的实现类" class="headerlink" title="SpringBoot内置tomcat线程池的实现类"></a>SpringBoot内置tomcat线程池的实现类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.apache.catalina.core.StandardThreadExecutor</span><br></pre></td></tr></table></figure><h2 id="初始化方法"><a href="#初始化方法" class="headerlink" title="初始化方法"></a>初始化方法</h2><p><strong>startInternal()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException &#123;</span><br><span class="line"><span class="comment">// 创建一个任务队列，容量为Integer.MAX_VALUE</span></span><br><span class="line"><span class="comment">// TaskQueue继承了LinkedBlockingQueue</span></span><br><span class="line">    <span class="built_in">this</span>.taskqueue = <span class="keyword">new</span> <span class="title class_">TaskQueue</span>(<span class="built_in">this</span>.maxQueueSize);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 线程工厂</span></span><br><span class="line">    <span class="type">TaskThreadFactory</span> <span class="variable">tf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TaskThreadFactory</span>(<span class="built_in">this</span>.namePrefix, <span class="built_in">this</span>.daemon, <span class="built_in">this</span>.getThreadPriority());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// new一个tomcat自定义的ThreadPoolExecutor，核心线程数25，最大线程数200，非核心线程销毁时间60s</span></span><br><span class="line">    <span class="built_in">this</span>.executor = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="built_in">this</span>.getMinSpareThreads(), <span class="built_in">this</span>.getMaxThreads(), (<span class="type">long</span>)<span class="built_in">this</span>.maxIdleTime, TimeUnit.MILLISECONDS, <span class="built_in">this</span>.taskqueue, tf);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置重建线程时间  1s</span></span><br><span class="line">    <span class="built_in">this</span>.executor.setThreadRenewalDelay(<span class="built_in">this</span>.threadRenewalDelay);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置parent，关联线程池对象</span></span><br><span class="line">    <span class="built_in">this</span>.taskqueue.setParent(<span class="built_in">this</span>.executor);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置线程池状态为START</span></span><br><span class="line">    <span class="built_in">this</span>.setState(LifecycleState.STARTING);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="请求执行方法"><a href="#请求执行方法" class="headerlink" title="请求执行方法"></a>请求执行方法</h2><p><strong>execute()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.executor != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 执行下面的ThreadPoolExecutor的execute()</span></span><br><span class="line">        <span class="built_in">this</span>.executor.execute(command);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(sm.getString(<span class="string">&quot;standardThreadExecutor.notStarted&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line"><span class="comment">// 这个字段统计的是队列里的任务和线程执行中的任务，原子类CAS自增</span></span><br><span class="line">    <span class="built_in">this</span>.submittedCount.incrementAndGet();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 执行类似JDK的executeInternal()</span></span><br><span class="line">        <span class="built_in">this</span>.executeInternal(command);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RejectedExecutionException var4) &#123;</span><br><span class="line">    <span class="comment">// 拒绝策略，线程达到最大线程数并且任务队列也满了</span></span><br><span class="line">    <span class="keyword">if</span> (getQueue() <span class="keyword">instanceof</span> TaskQueue) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">TaskQueue</span> <span class="variable">queue</span> <span class="operator">=</span> (TaskQueue) getQueue();</span><br><span class="line">            <span class="comment">// force()尝试把这个线程放到队列</span></span><br><span class="line">            <span class="keyword">if</span> (!queue.force(command)) &#123;</span><br><span class="line">            <span class="comment">// 放入队列失败，回滚提交计数</span></span><br><span class="line">                submittedCount.decrementAndGet();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RejectedExecutionException</span>(sm.getString(<span class="string">&quot;threadPoolExecutor.queueFull&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            submittedCount.decrementAndGet();</span><br><span class="line">            <span class="keyword">throw</span> rx;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">executeInternal</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">    <span class="comment">// 当前线程数小于核心线程数，创建线程</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试添加到任务队列中</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command)) &#123;</span><br><span class="line">            reject(command);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>) &#123;</span><br><span class="line">            addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 任务队列添加失败则创建新的线程</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>)) &#123;</span><br><span class="line">        reject(command);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="调整JDK对任务的处理办法"><a href="#调整JDK对任务的处理办法" class="headerlink" title="调整JDK对任务的处理办法"></a>调整JDK对任务的处理办法</h2><p>JDK对任务的处理办法是</p><ol><li>先判断有没有到达核心线程数，没有就创建核心线程执行任务</li><li>否则放入队列，如果队列也满了，判断是否到达最大线程数，没有就创建非核心线程执行任务</li><li>否则执行拒绝策略</li></ol><p>tomcat更换了处理办法，核心线程满了之后，如果任务数大于当前线程数，考虑先创建非核心线程，再放入队列</p><p><strong>tomcat自定义TaskQueue，覆盖第2步 workQueue.offer(command)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(Runnable runnable)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用 LinkedBlockingQueue 的 offer()，把任务放入队列</span></span><br><span class="line">    <span class="keyword">if</span> (parent==<span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.offer(o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前线程数到达最大线程数，不可能创建非核心线程，所以任务加入队列</span></span><br><span class="line">    <span class="keyword">if</span> (parent.getPoolSizeNoLock() == parent.getMaximumPoolSize()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.offer(o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他情况说明，可能可以创建非核心线程</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 提交任务数 &lt; 当前线程的数量，线程可以直接复用，直接丢到队列让空闲的运行线程去拉去就行，没必要新建线程执行</span></span><br><span class="line">    <span class="keyword">if</span> (parent.getSubmittedCount() &lt;= parent.getPoolSizeNoLock()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.offer(o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 到这里说明任务数比当前线程数多了，又当前线程数 &lt; 最大线程数，返回false，就去调用原生JDK去创建非核心线程了</span></span><br><span class="line">    <span class="keyword">if</span> (parent.getPoolSizeNoLock() &lt; parent.getMaximumPoolSize()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if we reached here, we need to add it to the queue</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.offer(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="添加任务失败后先尝试把任务放进队列"><a href="#添加任务失败后先尝试把任务放进队列" class="headerlink" title="添加任务失败后先尝试把任务放进队列"></a>添加任务失败后先尝试把任务放进队列</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">force</span><span class="params">(Runnable o)</span> &#123;</span><br><span class="line"><span class="comment">// 线程池状态处于SHUTDOWN状态，抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (parent == <span class="literal">null</span> || parent.isShutdown()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RejectedExecutionException</span>(sm.getString(<span class="string">&quot;taskQueue.notRunning&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用 LinkedBlockingQueue 的 offer()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.offer(o); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把任务放进队列</span></span><br><span class="line"> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="comment">// 当前在队列或者线程运行中的所有任务数量，和submittedCount一个东西</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.count;</span><br><span class="line">    <span class="keyword">if</span> (count.get() == capacity)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> c;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; node = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(e);</span><br><span class="line">    <span class="comment">// 获取锁，保证只有一个线程的任务可以放入队列</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">putLock</span> <span class="operator">=</span> <span class="built_in">this</span>.putLock;</span><br><span class="line">    putLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count.get() == capacity)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 任务放入队列</span></span><br><span class="line">        enqueue(node);</span><br><span class="line">        <span class="comment">// count++</span></span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line">        <span class="comment">// 如果队列还有空位置，通过AQS内的Condition的signal()唤醒其他阻塞的线程来放入任务到队列中</span></span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不是太懂</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>再来看看dubbo的线程池实现</strong></p><h1 id="Dubbo线程池的其中一个实现类"><a href="#Dubbo线程池的其中一个实现类" class="headerlink" title="Dubbo线程池的其中一个实现类"></a>Dubbo线程池的其中一个实现类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.apache.dubbo.common.threadpool.support.eager.EagerThreadPoolExecutor</span><br></pre></td></tr></table></figure><h2 id="初始化方法-1"><a href="#初始化方法-1" class="headerlink" title="初始化方法"></a>初始化方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用了ThreadPoolExecutor的构造器</span></span><br><span class="line"><span class="built_in">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler);</span><br></pre></td></tr></table></figure><h2 id="请求执行方法-1"><a href="#请求执行方法-1" class="headerlink" title="请求执行方法"></a>请求执行方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 调用原生JDK ThreadPoolExecutor的excute()</span></span><br><span class="line">        <span class="built_in">super</span>.execute(command);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RejectedExecutionException rx) &#123;</span><br><span class="line">        <span class="comment">// retry to offer the task into queue.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">TaskQueue</span> <span class="variable">queue</span> <span class="operator">=</span> (TaskQueue) <span class="built_in">super</span>.getQueue();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!queue.retryOffer(command, <span class="number">0</span>, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RejectedExecutionException</span>(<span class="string">&quot;Queue capacity is full.&quot;</span>, rx);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException x) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RejectedExecutionException</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">    <span class="comment">// 当前线程数小于核心线程数，创建线程</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试添加到任务队列中</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command)) &#123;</span><br><span class="line">            reject(command);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>) &#123;</span><br><span class="line">            addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 任务队列添加失败则创建新的线程</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>)) &#123;</span><br><span class="line">        reject(command);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="调整JDK对任务的处理办法-1"><a href="#调整JDK对任务的处理办法-1" class="headerlink" title="调整JDK对任务的处理办法"></a>调整JDK对任务的处理办法</h2><p><strong>可以看到，只有两种可能，就是创建非核心线程，或者加入队列</strong></p><p><strong>那我们判断什么时候加入队列</strong></p><ul><li>当前线程数 &#x3D;&#x3D; 最大线程数，这时不能再创建非核心线程，任务只能加入队列</li><li>提交线程数 &lt; 当前线程数，说明有线程闲着，任务直接放进队列，让空闲线程拉取就行</li></ul><p><strong>其他情况下，一般来说，当前线程数不够提交线程数，基本就是创建非核心线程了</strong></p><p>提交线程数的意思就是，当前正在执行任务的线程数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(Runnable runnable)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (executor == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RejectedExecutionException</span>(<span class="string">&quot;The task queue does not have executor!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// currentPoolThreadSize是当前线程数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">currentPoolThreadSize</span> <span class="operator">=</span> executor.getPoolSize();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 提交线程数 &lt; 当前线程数，有空闲线程，直接放入队列</span></span><br><span class="line">    <span class="keyword">if</span> (executor.getActiveCount() &lt; currentPoolThreadSize) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.offer(runnable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前线程数 &lt; 最大线程数，返回false，调用JDK的offer流程，创建非核心线程</span></span><br><span class="line">    <span class="keyword">if</span> (currentPoolThreadSize &lt; executor.getMaximumPoolSize()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前线程数 == 最大线程数，加入队列</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.offer(runnable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="添加任务失败后先尝试把任务放进队列-1"><a href="#添加任务失败后先尝试把任务放进队列-1" class="headerlink" title="添加任务失败后先尝试把任务放进队列"></a>添加任务失败后先尝试把任务放进队列</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">retryOffer</span><span class="params">(Runnable o, <span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (executor.isShutdown()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RejectedExecutionException</span>(<span class="string">&quot;Executor is shutdown!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用 LinkedBlockingQueue 的 offer()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.offer(o, timeout, unit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e, <span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="type">long</span> <span class="variable">nanos</span> <span class="operator">=</span> unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> c;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">putLock</span> <span class="operator">=</span> <span class="built_in">this</span>.putLock;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.count;</span><br><span class="line">    <span class="comment">// 上可打断锁，保证每次只有一个线程可以任务放入队列</span></span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 队列满了，循环等待，直到任务可以入队，或者等待超时返回</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            nanos = notFull.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 任务放入队列</span></span><br><span class="line">        enqueue(node);</span><br><span class="line">        <span class="comment">// count++</span></span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line">        <span class="comment">// 如果队列还有空位置，通过AQS内的Condition的signal()唤醒其他阻塞的线程来放入任务到队列中</span></span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
